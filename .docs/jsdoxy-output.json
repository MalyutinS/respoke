{
    "respoke.Call": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.Call"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "augments",
                    "otherClass": "respoke.EventEmitter"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.instanceId",
                    "description": "- client id"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "params.caller",
                    "description": "- whether or not we initiated the call"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "params.remoteEndpoint",
                    "description": "- The endpoint who is being called."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": "- The connection ID of the remoteEndpoint."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalOffer",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalConnected",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalAnswer",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalHangup",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalReport",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalCandidate",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for the remote video element."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for when the call is ended, whether or not\nit was ended in a graceful manner. TODO: add the hangup reason to the Event."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- Callback for when the browser gives us access to the\nuser's media. This event gets called even if the allow process is automatic, i. e., permission and media is\ngranted by the browser without asking the user to approve it."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "params.videoLocalElement",
                    "description": "- Pass in an optional html video element to have local video attached to it."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "params.videoRemoteElement",
                    "description": "- Pass in an optional html video element to have remote video attached to it."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>A <code>respoke.Call</code> is Respoke&#39;s interface into a WebRTC call, including getUserMedia, path and codec negotation,\nand call state.</p>\n<p>There are several methods on an instance of <code>respoke.Client</code> which return a <code>respoke.Call</code>.</p>\n",
                "summary": "<p>A <code>respoke.Call</code> is Respoke&#39;s interface into a WebRTC call, including getUserMedia, path and codec negotation,\nand call state.</p>\n",
                "body": "<p>There are several methods on an instance of <code>respoke.Client</code> which return a <code>respoke.Call</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "module.exports = function (params) {\n    \"use strict\";\n    params = params || {};",
            "ctx": {
                "type": "method",
                "receiver": "module",
                "name": "respoke.Call",
                "string": "module.exports()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "instanceId"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Call</p>\n",
                "summary": "<p>@memberof! respoke.Call</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;",
            "ctx": {
                "type": "declaration",
                "name": "instanceId",
                "value": "params.instanceId",
                "string": "instanceId",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>A name to identify the type of object.</p>\n",
                "summary": "<p>A name to identify the type of object.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.Call';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.Call'",
                "string": "that.className",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "name",
                    "string": "caller"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>Whether or not the client is the caller of the call.</p>\n",
                "summary": "<p>Whether or not the client is the caller of the call.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.caller = !!that.caller;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "caller",
                "value": "!!that.caller",
                "string": "that.caller",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "name",
                    "string": "id"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>The call ID.</p>\n",
                "summary": "<p>The call ID.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.id = that.caller ? respoke.makeGUID() : that.id;\n\n    if (!that.id) {\n        throw new Error(\"Can't start a new call without a call id.\");\n    }",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "id",
                "value": "that.caller ? respoke.makeGUID() : that.id",
                "string": "that.id",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "name",
                    "string": "defMedia"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "Promise"
                    ]
                }
            ],
            "description": {
                "full": "<p>Promise used to trigger actions dependant upon having received media or a datachannel.</p>\n",
                "summary": "<p>Promise used to trigger actions dependant upon having received media or a datachannel.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var defMedia = Q.defer();",
            "ctx": {
                "type": "declaration",
                "name": "defMedia",
                "value": "Q.defer()",
                "string": "defMedia",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "name",
                    "string": "defModify"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "Promise"
                    ]
                }
            ],
            "description": {
                "full": "<p>Promise used to trigger notification of a request for renegotiating media. For the caller of the\nrenegotiation (which doesn&#39;t have to be the same as the caller of the call), this is resolved\nor rejected as soon as the &#39;accept&#39; or &#39;reject&#39; signal is received. For the callee, it is\nresolved or rejected only after the developer or user approves or rejects the modify.</p>\n",
                "summary": "<p>Promise used to trigger notification of a request for renegotiating media. For the caller of the\nrenegotiation (which doesn&#39;t have to be the same as the caller of the call), this is resolved\nor rejected as soon as the &#39;accept&#39; or &#39;reject&#39; signal is received. For the callee, it is\nresolved or rejected only after the developer or user approves or rejects the modify.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var defModify;",
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "previewLocalMedia"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Call</p>\n",
                "summary": "<p>@memberof! respoke.Call</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var previewLocalMedia = params.previewLocalMedia;",
            "ctx": {
                "type": "declaration",
                "name": "previewLocalMedia",
                "value": "params.previewLocalMedia",
                "string": "previewLocalMedia",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "client"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.getClient"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Call</p>\n",
                "summary": "<p>@memberof! respoke.Call</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var client = respoke.getClient(instanceId);",
            "ctx": {
                "type": "declaration",
                "name": "client",
                "value": "respoke.getClient(instanceId)",
                "string": "client",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "signalingChannel"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.signalingChannel"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Call</p>\n",
                "summary": "<p>@memberof! respoke.Call</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var signalingChannel = params.signalingChannel;",
            "ctx": {
                "type": "declaration",
                "name": "signalingChannel",
                "value": "params.signalingChannel",
                "string": "signalingChannel",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "callDebugReportEnabled"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>Informational property. Whether call debugs were enabled on the client during creation.\nChanging this value will do nothing.</p>\n",
                "summary": "<p>Informational property. Whether call debugs were enabled on the client during creation.\nChanging this value will do nothing.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.callDebugReportEnabled = !!params.signalingChannel.callDebugReportEnabled;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "callDebugReportEnabled",
                "value": "!!params.signalingChannel.callDebugReportEnabled",
                "string": "that.callDebugReportEnabled",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "hasAudio"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>A flag indicating whether this call has audio.</p>\n<p>This becomes available after the call is accepted, for the client being called only.</p>\n",
                "summary": "<p>A flag indicating whether this call has audio.</p>\n",
                "body": "<p>This becomes available after the call is accepted, for the client being called only.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.hasAudio = undefined;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "hasAudio",
                "value": "undefined",
                "string": "that.hasAudio",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "hasVideo"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>A flag indicating whether this call has video.</p>\n<p>This becomes available after the call is accepted, for the client being called only.</p>\n",
                "summary": "<p>A flag indicating whether this call has video.</p>\n",
                "body": "<p>This becomes available after the call is accepted, for the client being called only.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.hasVideo = undefined;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "hasVideo",
                "value": "undefined",
                "string": "that.hasVideo",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "outgoingMedia"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.LocalMedia"
                    ]
                }
            ],
            "description": {
                "full": "<p>Local media that we are sending to the remote party.</p>\n",
                "summary": "<p>Local media that we are sending to the remote party.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.outgoingMedia = respoke.LocalMedia({\n        instanceId: instanceId,\n        callId: that.id,\n        constraints: params.constraints || {\n            video: true,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        }\n    });",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "outgoingMedia",
                "value": "respoke.LocalMedia({",
                "string": "that.outgoingMedia",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "incomingMedia"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.RemoteMedia"
                    ]
                }
            ],
            "description": {
                "full": "<p>Remote media that we are receiving from the remote party.</p>\n",
                "summary": "<p>Remote media that we are receiving from the remote party.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.incomingMedia = respoke.RemoteMedia({\n        instanceId: instanceId,\n        callId: that.id,\n        constraints: params.constraints\n    });",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "incomingMedia",
                "value": "respoke.RemoteMedia({",
                "string": "that.incomingMedia",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#mute"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "type",
                    "description": "- Either \"audio\" or \"video\" to specify the type of stream whose muted state\nhas been changed."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "muted",
                    "description": "- Whether the stream is now muted. Will be set to false if mute was turned off."
                }
            ],
            "description": {
                "full": "<p>This event indicates that local video has been unmuted.</p>\n",
                "summary": "<p>This event indicates that local video has been unmuted.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.outgoingMedia.listen('mute', function (evt) {\n        that.fire('mute', {\n            type: evt.type,\n            muted: evt.muted\n        });\n    });\n\n    delete params.signalingChannel;\n    delete that.signalingChannel;",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#mute",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "videoIsMuted"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Call</p>\n",
                "summary": "<p>@memberof! respoke.Call</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var videoIsMuted = false;",
            "ctx": {
                "type": "declaration",
                "name": "videoIsMuted",
                "value": "false",
                "string": "videoIsMuted",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "audioIsMuted"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Call</p>\n",
                "summary": "<p>@memberof! respoke.Call</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var audioIsMuted = false;",
            "ctx": {
                "type": "declaration",
                "name": "audioIsMuted",
                "value": "false",
                "string": "audioIsMuted",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "directConnection"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.DirectConnection"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Call</p>\n",
                "summary": "<p>@memberof! respoke.Call</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var directConnection = null;",
            "ctx": {
                "type": "declaration",
                "name": "directConnection",
                "value": "null",
                "string": "directConnection",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "toSendHangup"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Call</p>\n",
                "summary": "<p>@memberof! respoke.Call</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var toSendHangup = null;",
            "ctx": {
                "type": "declaration",
                "name": "toSendHangup",
                "value": "null",
                "string": "toSendHangup",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "pc"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.PeerConnection"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Call</p>\n",
                "summary": "<p>@memberof! respoke.Call</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var pc = respoke.PeerConnection({\n        instanceId: instanceId,\n        state: respoke.CallState({\n            caller: that.caller,\n            needDirectConnection: params.needDirectConnection,\n            sendOnly: params.sendOnly,\n            receiveOnly: params.receiveOnly,\n            // hasMedia is not defined yet.\n            hasMedia: function () {\n                return that.hasMedia();\n            }\n        }),\n        forceTurn: !!params.forceTurn,\n        call: that,\n        pcOptions: {\n            optional: [\n                { DtlsSrtpKeyAgreement: true },\n                { RtpDataChannels: false }\n            ]\n        },\n        offerOptions: params.offerOptions || null,\n        signalOffer: function (args) {\n            if (!pc) {\n                return;\n            }\n\n            params.signalOffer(args);\n            pc.state.dispatch('sentOffer');\n        },\n        signalConnected: params.signalConnected,\n        signalAnswer: params.signalAnswer,\n        signalModify: params.signalModify,\n        signalHangup: params.signalHangup,\n        signalReport: params.signalReport,\n        signalCandidate: params.signalCandidate\n    });",
            "ctx": {
                "type": "declaration",
                "name": "pc",
                "value": "respoke.PeerConnection({",
                "string": "pc",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "method",
                    "string": "respoke.Call.init"
                },
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "fires",
                    "string": "respoke.Client#call"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Set up promises. If we&#39;re not the caller, we need to listen for approval AND the remote SDP to come in\nbefore we can act on the call. Save parameters sent in with the constructor, then delete them off the call.\nIf this call was initiated with a DirectConnection, set it up so answer() will be the approval mechanism.</p>\n",
                "summary": "<p>Set up promises. If we&#39;re not the caller, we need to listen for approval AND the remote SDP to come in\nbefore we can act on the call. Save parameters sent in with the constructor, then delete them off the call.\nIf this call was initiated with a DirectConnection, set it up so answer() will be the approval mechanism.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.Client#call"
            ],
            "ignore": false,
            "code": "function init() {\n        log.debug('Call.init');\n\n        if (defModify !== undefined) {\n            defMedia = Q.defer();\n        }\n\n        pc.init(); // instantiates RTCPeerConnection, can't call on modify\n        if (defModify === undefined && pc.state.needDirectConnection === true) {\n            actuallyAddDirectConnection(params);\n        }\n    }",
            "ctx": {
                "type": "function",
                "name": "init",
                "string": "init()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.saveParameters"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for the remote video element."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for when the call is ended, whether or not\nit was ended in a graceful manner. TODO: add the hangup reason to the Event."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will fire even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- Callback for when the browser gives us access to the\nuser's media. This event gets fired even if the allow process is automatic, i. e., permission and media is\ngranted by the browser without asking the user to approve it."
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params.constraints]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "params.videoLocalElement",
                    "description": "- Pass in an optional html video element to have local video attached to it."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "params.videoRemoteElement",
                    "description": "- Pass in an optional html video element to have remote video attached to it."
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#stats"
                }
            ],
            "description": {
                "full": "<p>Register any event listeners passed in as callbacks, save other params to answer() and accept().</p>\n",
                "summary": "<p>Register any event listeners passed in as callbacks, save other params to answer() and accept().</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.Call#stats"
            ],
            "ignore": false,
            "code": "function saveParameters(params) {",
            "ctx": {
                "type": "function",
                "name": "saveParameters",
                "string": "saveParameters()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>This happens when the call is hung up automatically, for instance due to the lack of an onCall\nhandler. In this case, pc has been set to null in hangup. The call has already failed, and the\ninvocation of this function is an artifact of async code not being finished yet, so we can just\nskip all of this setup.</p>\n",
                "summary": "<p>This happens when the call is hung up automatically, for instance due to the lack of an onCall\nhandler. In this case, pc has been set to null in hangup. The call has already failed, and the\ninvocation of this function is an artifact of async code not being finished yet, so we can just\nskip all of this setup.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "if (!pc) {\n            return;\n        }\n\n        that.listen('local-stream-received', params.onLocalMedia);\n        that.listen('connect', params.onConnect);\n        that.listen('hangup', params.onHangup);\n        that.listen('allow', params.onAllow);\n        that.listen('answer', params.onAnswer);\n        that.listen('approve', params.onApprove);\n        that.listen('mute', params.onMute);\n        that.listen('requesting-media', params.onRequestingMedia);\n\n        previewLocalMedia = typeof params.previewLocalMedia === 'function' ?\n            params.previewLocalMedia : previewLocalMedia;\n\n        pc.state.receiveOnly = typeof params.receiveOnly === 'boolean' ? params.receiveOnly : pc.state.receiveOnly;\n        pc.state.sendOnly = typeof params.sendOnly === 'boolean' ? params.sendOnly : pc.state.sendOnly;\n        pc.state.needDirectConnection = typeof params.needDirectConnection === 'boolean' ?\n            params.needDirectConnection : pc.state.needDirectConnection;\n        pc.disableTurn = params.disableTurn || pc.disableTurn;\n        pc.forceTurn = typeof params.forceTurn === 'boolean' ? params.forceTurn : pc.forceTurn;\n\n        that.outgoingMedia.constraints = params.constraints || that.outgoingMedia.constraints;\n        that.outgoingMedia.element = params.videoLocalElement || that.outgoingMedia.element;\n        if (pc.state.caller === true) {\n            // Only the person who initiated this round of media negotiation needs to estimate remote\n            // media based on what constraints local media is using.\n            that.incomingMedia.setConstraints(that.outgoingMedia.constraints);\n        }\n        that.incomingMedia.element = params.videoRemoteElement || that.incomingMedia.element;\n\n        pc.listen('stats', function fireStats(evt) {",
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#stats"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.MediaStats"
                    ],
                    "name": "stats",
                    "description": "- an object with stats in it."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                }
            ],
            "description": {
                "full": "<p>This event is fired every time statistical information about audio and/or video on a call\nbecomes available.</p>\n",
                "summary": "<p>This event is fired every time statistical information about audio and/or video on a call\nbecomes available.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('stats', {stats: evt.stats});\n        }, true);\n\n        delete that.signalOffer;\n        delete that.signalConnected;\n        delete that.signalAnswer;\n        delete that.signalHangup;\n        delete that.signalReport;\n        delete that.signalCandidate;\n    }",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#stats",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.answer"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#answer"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for the remote video element."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for when the call is ended, whether or not\nit was ended in a graceful manner. TODO: add the hangup reason to the Event."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- Callback for when the browser gives us access to the\nuser's media. This event gets called even if the allow process is automatic, i. e., permission and media is\ngranted by the browser without asking the user to approve it."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- Whether or not we accept media."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- Whether or not we send media."
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params.constraints]",
                    "description": "- Information about the media for this call."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "params.videoLocalElement",
                    "description": "- Pass in an optional html video element to have local video attached to it."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "params.videoRemoteElement",
                    "description": "- Pass in an optional html video element to have remote video attached to it."
                }
            ],
            "description": {
                "full": "<p>Answer the call and start the process of obtaining media. This method is called automatically on the caller&#39;s\nside. This method must be called on the callee&#39;s side to indicate that the endpoint does wish to accept the\ncall. The app will have a later opportunity, by passing a callback named previewLocalMedia, to approve or\nreject the call based on whether audio and/or video is working and is working at an acceptable level.</p>\n<pre><code>client.listen(&#39;call&#39;, function (evt) {\n    if (!evt.call.caller) {\n        evt.call.answer();\n    }\n});\n</code></pre>",
                "summary": "<p>Answer the call and start the process of obtaining media. This method is called automatically on the caller&#39;s\nside. This method must be called on the callee&#39;s side to indicate that the endpoint does wish to accept the\ncall. The app will have a later opportunity, by passing a callback named previewLocalMedia, to approve or\nreject the call based on whether audio and/or video is working and is working at an acceptable level.</p>\n",
                "body": "<pre><code>client.listen(&#39;call&#39;, function (evt) {\n    if (!evt.call.caller) {\n        evt.call.answer();\n    }\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [
                "respoke.Call#answer"
            ],
            "ignore": false,
            "code": "that.answer = function (params) {\n        params = params || {};\n        log.debug('Call.answer');\n\n        saveParameters(params);\n\n        pc.listen('connect', onRemoteStreamAdded, true);\n        pc.listen('remote-stream-removed', onRemoteStreamRemoved, true);\n\n        pc.state.once('approving-device-access:entry', function (evt) {\n            doAddVideo(params);\n        });\n        pc.state.dispatch('answer', {\n            previewLocalMedia: previewLocalMedia,\n            approve: that.approve\n        });",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "answer",
                "string": "that.answer()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#answer"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>The call was answered.</p>\n",
                "summary": "<p>The call was answered.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('answer');\n    };",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#answer",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.accept"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#accept"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for the developer to receive the\nremote video element."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for the developer to be notified about hangup."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- Whether or not we accept media."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- Whether or not we send media."
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params.constraints]",
                    "description": "- Information about the media for this call."
                }
            ],
            "description": {
                "full": "<p>Accept a request to modify the media on the call. This method should be called within the Call#modify\nevent listener, which gives the developer or website user a chance to see what changes are proposed and\nto accept or reject them.</p>\n<pre><code>call.listen(&#39;modify&#39;, function (evt) {\n    evt.call.accept();\n});\n</code></pre>",
                "summary": "<p>Accept a request to modify the media on the call. This method should be called within the Call#modify\nevent listener, which gives the developer or website user a chance to see what changes are proposed and\nto accept or reject them.</p>\n",
                "body": "<pre><code>call.listen(&#39;modify&#39;, function (evt) {\n    evt.call.accept();\n});\n</code></pre>"
            },
            "isPrivate": true,
            "fires": [
                "respoke.Call#accept"
            ],
            "ignore": false,
            "code": "that.accept = that.answer;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "accept",
                "value": "that.answer",
                "string": "that.accept",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.approve"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#approve"
                }
            ],
            "description": {
                "full": "<p>Start the process of network and media negotiation. If the app passes in a callback named previewLocalMedia\nin order to allow the logged-in person a chance to base their decision to continue the call on whether\naudio and/or video is working correctly,\nthis method must be called on both sides in order to begin the call. If call.approve() is called, the call\nwill progress as expected. If call.reject() is called, the call will be aborted.</p>\n<pre><code>call.listen(&#39;local-stream-received&#39;, function (evt) {\n    if (userLikesVideo()) {\n        evt.call.approve();\n    }\n});\n</code></pre>",
                "summary": "<p>Start the process of network and media negotiation. If the app passes in a callback named previewLocalMedia\nin order to allow the logged-in person a chance to base their decision to continue the call on whether\naudio and/or video is working correctly,\nthis method must be called on both sides in order to begin the call. If call.approve() is called, the call\nwill progress as expected. If call.reject() is called, the call will be aborted.</p>\n",
                "body": "<pre><code>call.listen(&#39;local-stream-received&#39;, function (evt) {\n    if (userLikesVideo()) {\n        evt.call.approve();\n    }\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [
                "respoke.Call#approve"
            ],
            "ignore": false,
            "code": "that.approve = function () {\n        log.debug('Call.approve');",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "approve",
                "string": "that.approve()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#approve"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Fired when the local media access is approved.</p>\n",
                "summary": "<p>Fired when the local media access is approved.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('approve');\n        pc.state.dispatch('approve', {\n            previewLocalMedia: previewLocalMedia\n        });\n\n        if (defModify && defModify.promise.isPending()) {\n            defModify.resolve(true);\n            defModify = undefined;\n        }\n    };",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#approve",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.onRemoteStreamRemoved"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Listen for the remote side to remove media in the middle of the call.</p>\n",
                "summary": "<p>Listen for the remote side to remove media in the middle of the call.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function onRemoteStreamRemoved(evt) {\n        log.debug('pc event: remote stream removed');\n    }",
            "ctx": {
                "type": "function",
                "name": "onRemoteStreamRemoved",
                "string": "onRemoteStreamRemoved()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.onRemoteStreamAdded"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "",
                    "description": ""
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#connect"
                }
            ],
            "description": {
                "full": "<p>Listen for the remote side to add additional media in the middle of the call.</p>\n",
                "summary": "<p>Listen for the remote side to add additional media in the middle of the call.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.Call#connect"
            ],
            "ignore": false,
            "code": "function onRemoteStreamAdded(evt) {\n        if (!pc) {\n            return;\n        }\n        log.debug('received remote media', evt);\n\n        that.incomingMedia.setStream(evt.stream);",
            "ctx": {
                "type": "function",
                "name": "onRemoteStreamAdded",
                "string": "onRemoteStreamAdded()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#connect"
                },
                {
                    "type": "event",
                    "string": "respoke.LocalMedia#connect"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "Element"
                    ],
                    "name": "element",
                    "description": "- The HTML5 Video element with the remote stream attached."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.RemoteMedia"
                    ],
                    "name": "stream",
                    "description": "- The incomingMedia property on the call."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- The event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Indicates that a remote media stream has been added to the call.</p>\n",
                "summary": "<p>Indicates that a remote media stream has been added to the call.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "pc.state.dispatch('receiveRemoteMedia');\n        that.fire('connect', {\n            stream: evt.stream,\n            element: that.incomingMedia.element\n        });\n    }",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#connect",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.getStats"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "number"
                    ],
                    "name": "[params.interval=5000]",
                    "description": "- How often in milliseconds to fetch statistics."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- An optional callback to receive\nthe stats. If no callback is provided, the call's report will contain stats but the developer will not\nreceive them on the client-side."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.statsSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of\nthis method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this method only."
                },
                {
                    "type": "returns",
                    "string": "{Promise<object>|null}"
                }
            ],
            "description": {
                "full": "<h2 id=\"the-plugin-respoke-mediastats-must-be-loaded-before-using-this-method-\">The plugin <code>respoke.MediaStats</code> must be loaded before using this method.</h2>\n<p>Start the process of listening for a continuous stream of statistics about the flow of audio and/or video.\nSince we have to wait for both the answer and offer to be available before starting\nstatistics, the library returns a promise for the stats object. The statistics object does not contain the\nstatistics; rather it contains methods of interacting with the actions of obtaining statistics. To obtain\nthe actual statistics one time, use stats.getStats(); use the onStats callback to obtain a continuous\nstream of statistics every <code>interval</code> seconds.  Returns null if stats module is not loaded.</p>\n<pre><code>call.getStats({\n    onStats: function (evt) {\n        console.log(&#39;Stats&#39;, evt.stats);\n    }\n}).done(function () {\n    console.log(&#39;Stats started&#39;);\n}, function (err) {\n    console.log(&#39;Call is already hung up.&#39;);\n});\n</code></pre>",
                "summary": "<h2 id=\"the-plugin-respoke-mediastats-must-be-loaded-before-using-this-method-\">The plugin <code>respoke.MediaStats</code> must be loaded before using this method.</h2>\n",
                "body": "<p>Start the process of listening for a continuous stream of statistics about the flow of audio and/or video.\nSince we have to wait for both the answer and offer to be available before starting\nstatistics, the library returns a promise for the stats object. The statistics object does not contain the\nstatistics; rather it contains methods of interacting with the actions of obtaining statistics. To obtain\nthe actual statistics one time, use stats.getStats(); use the onStats callback to obtain a continuous\nstream of statistics every <code>interval</code> seconds.  Returns null if stats module is not loaded.</p>\n<pre><code>call.getStats({\n    onStats: function (evt) {\n        console.log(&#39;Stats&#39;, evt.stats);\n    }\n}).done(function () {\n    console.log(&#39;Stats started&#39;);\n}, function (err) {\n    console.log(&#39;Call is already hung up.&#39;);\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "function getStats(params) {\n        if (pc && pc.getStats) {\n            that.listen('stats', params.onStats);\n            return pc.getStats(params);\n        }\n        return null;\n    }\n    if (respoke.MediaStats) {\n        that.getStats = getStats;\n    }",
            "ctx": {
                "type": "function",
                "name": "getStats",
                "string": "getStats()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.getLocalElement"
                },
                {
                    "type": "returns",
                    "string": "{Video} An HTML5 video element."
                }
            ],
            "description": {
                "full": "<p>Return local video element with the logged-in endpoint&#39;s audio and/or video streams attached to it.</p>\n<pre><code>var el = call.getLocalElement();\ncontainer.append(el);\n</code></pre>",
                "summary": "<p>Return local video element with the logged-in endpoint&#39;s audio and/or video streams attached to it.</p>\n",
                "body": "<pre><code>var el = call.getLocalElement();\ncontainer.append(el);\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getLocalElement = function () {\n        return that.outgoingMedia.element;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getLocalElement",
                "string": "that.getLocalElement()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.getRemoteElement"
                },
                {
                    "type": "returns",
                    "string": "{Video} An HTML5 video element."
                }
            ],
            "description": {
                "full": "<p>Return remote video element with the remote endpoint&#39;s audio and/or video streams attached to it.</p>\n<pre><code>var el = call.getRemoteElement();\ncontainer.append(el);\n</code></pre>",
                "summary": "<p>Return remote video element with the remote endpoint&#39;s audio and/or video streams attached to it.</p>\n",
                "body": "<pre><code>var el = call.getRemoteElement();\ncontainer.append(el);\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getRemoteElement = function () {\n        return that.incomingMedia.element;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getRemoteElement",
                "string": "that.getRemoteElement()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.doAddVideo"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params.constraints]",
                    "description": "- getUserMedia constraints"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": ""
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#requesting-media"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#allow"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#local-stream-received"
                }
            ],
            "description": {
                "full": "<p>Create the RTCPeerConnection and add handlers. Process any offer we have already received. This method is called\nafter answer() so we cannot use this method to set up the DirectConnection.</p>\n",
                "summary": "<p>Create the RTCPeerConnection and add handlers. Process any offer we have already received. This method is called\nafter answer() so we cannot use this method to set up the DirectConnection.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.Call#requesting-media",
                "respoke.Call#allow",
                "respoke.Call#local-stream-received"
            ],
            "ignore": false,
            "code": "function doAddVideo(params) {\n        log.debug('Call.doAddVideo');\n        saveParameters(params);\n        that.outgoingMedia.listen('requesting-media', function waitAllowHandler(evt) {\n            if (!pc) {\n                return;\n            }",
            "ctx": {
                "type": "function",
                "name": "doAddVideo",
                "string": "doAddVideo()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#requesting-media"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>The browser is asking for permission to access the User&#39;s media. This would be an ideal time\nto modify the UI of the application so that the user notices the request for permissions\nand approves it.</p>\n",
                "summary": "<p>The browser is asking for permission to access the User&#39;s media. This would be an ideal time\nto modify the UI of the application so that the user notices the request for permissions\nand approves it.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('requesting-media');\n        }, true);\n        that.outgoingMedia.listen('allow', function allowHandler(evt) {\n            if (!pc) {\n                return;\n            }",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#requesting-media",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#allow"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>The user has approved the request for media. Any UI changes made to remind the user to click Allow\nshould be canceled now. This event is the same as the <code>onAllow</code> callback.  This event gets fired\neven if the allow process is automatic, i. e., permission and media is granted by the browser\nwithout asking the user to approve it.</p>\n",
                "summary": "<p>The user has approved the request for media. Any UI changes made to remind the user to click Allow\nshould be canceled now. This event is the same as the <code>onAllow</code> callback.  This event gets fired\neven if the allow process is automatic, i. e., permission and media is granted by the browser\nwithout asking the user to approve it.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('allow');\n            pc.state.dispatch('approve', {\n                previewLocalMedia: previewLocalMedia\n            });\n        }, true);\n        that.outgoingMedia.listen('stream-received', function streamReceivedHandler(evt) {\n            if (!pc) {\n                return;\n            }\n\n            defMedia.resolve(that.outgoingMedia);\n            pc.addStream(evt.stream);\n            pc.state.dispatch('receiveLocalMedia');\n            if (typeof previewLocalMedia === 'function') {\n                previewLocalMedia(evt.element, that);\n            }",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#allow",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "Element"
                    ],
                    "name": "element",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "stream",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.Call#local-stream-received</p>\n",
                "summary": "<p>@event respoke.Call#local-stream-received</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('local-stream-received', {\n                element: evt.element,\n                stream: that.outgoingMedia\n            });\n        }, true);\n        that.outgoingMedia.listen('error', function errorHandler(evt) {\n            pc.state.dispatch('reject', {reason: 'media stream error'});\n            pc.report.callStoppedReason = evt.reason;",
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#error"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "reason",
                    "description": "- A human readable description about the error."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                }
            ],
            "description": {
                "full": "<p>This event is fired on errors that occur during call setup or media negotiation.</p>\n",
                "summary": "<p>This event is fired on errors that occur during call setup or media negotiation.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('error', {\n                reason: evt.reason\n            });\n        });\n\n        that.outgoingMedia.start();\n        return that.outgoingMedia;\n    }",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#error",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.addVideo"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.audio=true]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.video=true]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params.constraints]",
                    "description": "- getUserMedia constraints, indicating the media being requested is\nan audio and/or video stream."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.mediaSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{Promise<respoke.LocalMedia>}"
                }
            ],
            "description": {
                "full": "<p>Add a video and audio stream to the existing call. By default, this method adds both video AND audio.\nIf audio is not desired, pass {audio: false}.</p>\n",
                "summary": "<p>Add a video and audio stream to the existing call. By default, this method adds both video AND audio.\nIf audio is not desired, pass {audio: false}.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.addVideo = function (params) {\n        log.debug('Call.addVideo');\n        params = params || {};\n        params.constraints = params.constraints || {video: true, audio: true};\n        params.constraints.audio = typeof params.audio === 'boolean' ? params.audio : params.constraints.audio;\n        params.constraints.video = typeof params.video === 'boolean' ? params.video : params.constraints.video;\n        params.instanceId = instanceId;\n\n        if (!defMedia.promise.isFulfilled()) { // we're the callee & have just accepted to modify\n            doAddVideo(params);\n        } else { // we're the caller and need to see if we can modify\n            pc.startModify({\n                constraints: params.constraints\n            });\n            defModify = Q.defer();\n            defModify.promise.then(function modifyAccepted() {\n                doAddVideo(params);\n            });\n        }\n        return defModify.promise;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "addVideo",
                "string": "that.addVideo()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.addAudio"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.audio=true]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.video=false]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params.constraints]",
                    "description": "- getUserMedia constraints, indicating the media being requested is\nan audio and/or video stream."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.mediaSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{Promise<respoke.LocalMedia>}"
                }
            ],
            "description": {
                "full": "<p>Add an audio stream to the existing call.</p>\n",
                "summary": "<p>Add an audio stream to the existing call.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.addAudio = function (params) {\n        params = params || {};\n        params.constraints = params.constraints || {video: false, audio: true};\n        params.constraints.video = typeof params.constraints.video === 'boolean' ?\n            params.constraints.video : false;\n        params.constraints.audio = typeof params.audio === 'boolean' ? params.audio : params.constraints.audio;\n        params.constraints.video = typeof params.video === 'boolean' ? params.video : params.constraints.video;\n        return that.addVideo(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "addAudio",
                "string": "that.addAudio()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.getDirectConnection"
                },
                {
                    "type": "returns",
                    "string": "{respoke.DirectConnection}"
                }
            ],
            "description": {
                "full": "<p>Get the direct connection on this call, if it exists.</p>\n<pre><code>var dc = call.getDirectConnection();\nif (!dc) {\n    console.log(&quot;No direct connection has been started.&quot;);\n} else {\n    dc.sendMessage({message: &#39;hi&#39;});\n}\n</code></pre>",
                "summary": "<p>Get the direct connection on this call, if it exists.</p>\n",
                "body": "<pre><code>var dc = call.getDirectConnection();\nif (!dc) {\n    console.log(&quot;No direct connection has been started.&quot;);\n} else {\n    dc.sendMessage({message: &#39;hi&#39;});\n}\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getDirectConnection = function () {\n        return directConnection || null;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getDirectConnection",
                "string": "that.getDirectConnection()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.removeDirectConnection"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "arg",
                    "string": "{boolean} [params.skipModify] Do not restart media negotiation."
                }
            ],
            "description": {
                "full": "<p>Remove a direct connection from the existing call. If there is no other media, this will hang up the call.</p>\n",
                "summary": "<p>Remove a direct connection from the existing call. If there is no other media, this will hang up the call.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.removeDirectConnection = function (params) {\n        params = params || {};\n        log.debug('Call.removeDirectConnection');\n\n        if (directConnection && directConnection.isActive()) {\n            directConnection.close({skipRemove: true});\n        }\n\n        if (!that.hasMedia()) {\n            log.debug('Hanging up because there are no local streams.');\n            that.hangup();\n            return;\n        }\n\n        if (params.skipModify === true) {\n            return;\n        }\n\n        pc.startModify({\n            directConnection: false\n        });\n        defModify = Q.defer();\n        defModify.promise.done(function onModifySuccess() {\n            defMedia.resolve();\n            defModify = undefined;\n        });\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "removeDirectConnection",
                "string": "that.removeDirectConnection()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.addDirectConnection"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onClose"
                    ],
                    "name": "[params.onClose]",
                    "description": "- Callback for the developer to be notified about\nclosing the connection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onOpen"
                    ],
                    "name": "[params.onOpen]",
                    "description": "- Callback for the developer to be notified about\nopening the connection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Callback for the developer to be notified\nabout incoming messages. Not usually necessary to listen to this event if you are already listening to\nrespoke.Endpoint#message."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.directConnectionSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{Promise<respoke.DirectConnection>}"
                }
            ],
            "description": {
                "full": "<p>Add a direct connection to the existing call.</p>\n<pre><code>call.addDirectConnection({\n    onOpen: function (evt) {\n        console.log(&quot;Direct connection open!&quot;);\n    }\n});\n</code></pre>",
                "summary": "<p>Add a direct connection to the existing call.</p>\n",
                "body": "<pre><code>call.addDirectConnection({\n    onOpen: function (evt) {\n        console.log(&quot;Direct connection open!&quot;);\n    }\n});\n</code></pre>"
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.addDirectConnection = function (params) {\n        log.debug('Call.addDirectConnection');\n        pc.startModify({\n            directConnection: true\n        });\n        defModify = Q.defer();\n        return defModify.promise.then(function onModifySuccess() {\n            return actuallyAddDirectConnection(params);\n        }, function onModifyError(err) {\n            throw err;\n        });\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "addDirectConnection",
                "string": "that.addDirectConnection()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.actuallyAddDirectConnection"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onClose"
                    ],
                    "name": "[params.onClose]",
                    "description": "- Callback for the developer to be notified about\nclosing the connection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onOpen"
                    ],
                    "name": "[params.onOpen]",
                    "description": "- Callback for the developer to be notified about\nopening the connection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Callback for the developer to be notified\nabout incoming messages. Not usually necessary to listen to this event if you are already listening to\nrespoke.Endpoint#message."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.directConnectionSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{Promise<respoke.DirectConnection>}"
                },
                {
                    "type": "fires",
                    "string": "respoke.Client#direct-connection"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#direct-connection"
                }
            ],
            "description": {
                "full": "<p>Add a direct connection to the existing call.</p>\n",
                "summary": "<p>Add a direct connection to the existing call.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.Client#direct-connection",
                "respoke.Call#direct-connection"
            ],
            "ignore": false,
            "code": "function actuallyAddDirectConnection(params) {\n        log.debug('Call.actuallyAddDirectConnection', params);\n        params = params || {};\n        defMedia.promise.then(params.onSuccess, params.onError);\n\n        if (directConnection && directConnection.isActive()) {\n            if (defMedia.promise.isPending()) {\n                defMedia.resolve(directConnection);\n            } else {\n                log.warn(\"Not creating a new direct connection.\");\n            }\n            return defMedia.promise;\n        }\n\n        params.instanceId = instanceId;\n        params.pc = pc;\n        params.call = that;\n\n        directConnection = respoke.DirectConnection(params);\n\n        directConnection.listen('close', function closeHandler() {\n            if (!that.hasMedia()) {\n                log.debug('Hanging up because there are no local streams.');\n                that.hangup();\n            } else {\n                if (directConnection && directConnection.isActive()) {\n                    that.removeDirectConnection({skipModify: true});\n                }\n            }\n        }, true);\n\n        directConnection.listen('accept', function acceptHandler() {\n            if (pc.state.caller === false) {\n                log.debug('Answering as a result of approval.');\n            } else {\n                defMedia.resolve(directConnection);\n            }\n        }, true);\n\n        directConnection.listen('open', function openHandler() {\n            pc.state.dispatch('receiveRemoteMedia');\n        }, true);\n\n        directConnection.listen('error', function errorHandler(err) {\n            defMedia.reject(new Error(err));\n        }, true);\n\n        that.remoteEndpoint.directConnection = directConnection;",
            "ctx": {
                "type": "function",
                "name": "actuallyAddDirectConnection",
                "string": "actuallyAddDirectConnection()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#direct-connection"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "directConnection",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "endpoint",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event is fired when the local end of the directConnection is available. It still will not be\nready to send and receive messages until the &#39;open&#39; event fires.</p>\n",
                "summary": "<p>This event is fired when the local end of the directConnection is available. It still will not be\nready to send and receive messages until the &#39;open&#39; event fires.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('direct-connection', {\n            directConnection: directConnection,\n            endpoint: that.remoteEndpoint\n        });",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#direct-connection",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#direct-connection"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "directConnection",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "endpoint",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>This event is fired when the logged-in endpoint is receiving a request to open a direct connection\nto another endpoint.  If the user wishes to allow the direct connection, calling\nevt.directConnection.accept() will allow the connection to be set up.</p>\n",
                "summary": "<p>This event is fired when the logged-in endpoint is receiving a request to open a direct connection\nto another endpoint.  If the user wishes to allow the direct connection, calling\nevt.directConnection.accept() will allow the connection to be set up.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "client.fire('direct-connection', {\n            directConnection: directConnection,\n            endpoint: that.remoteEndpoint\n        });\n\n        if (pc.state.caller === true) {\n            directConnection.accept();\n        }\n\n        return defMedia.promise;\n    }",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#direct-connection",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.closeDirectConnection"
                }
            ],
            "description": {
                "full": "<p>Close the direct connection.</p>\n",
                "summary": "<p>Close the direct connection.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.closeDirectConnection = function () {\n        if (directConnection) {\n            directConnection.close();\n            directConnection = null;\n        }\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "closeDirectConnection",
                "string": "that.closeDirectConnection()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.hangup"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#hangup"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "arg",
                    "string": "{boolean} params.signal Optional flag to indicate whether to send or suppress sending\na hangup signal to the remote side."
                }
            ],
            "description": {
                "full": "<p>Tear down the call, release user media.  Send a hangup signal to the remote party if\nsignal is not false and we have not received a hangup signal from the remote party.</p>\n",
                "summary": "<p>Tear down the call, release user media.  Send a hangup signal to the remote party if\nsignal is not false and we have not received a hangup signal from the remote party.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.Call#hangup"
            ],
            "ignore": false,
            "code": "that.hangup = function (params) {\n        if (!pc) {\n            return;\n        }\n        params = params || {};\n        params.reason = params.reason || \"hangup method called.\";\n        pc.state.dispatch('hangup', params);\n    };\n    that.hangup = respoke.once(that.hangup);",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "hangup",
                "string": "that.hangup()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.hangup"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#hangup"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Tear down the call, release user media.  Send a hangup signal to the remote party if\nsignal is not false and we have not received a hangup signal from the remote party. This is an event\nhandler added to the state machine via <code>once</code>.</p>\n",
                "summary": "<p>Tear down the call, release user media.  Send a hangup signal to the remote party if\nsignal is not false and we have not received a hangup signal from the remote party. This is an event\nhandler added to the state machine via <code>once</code>.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.Call#hangup"
            ],
            "ignore": false,
            "code": "var doHangup = function () {\n        log.debug('hangup', that.caller);\n\n        that.outgoingMedia.stop();\n\n        if (directConnection && directConnection.isActive()) {\n            directConnection.close();\n            that.remoteEndpoint.directConnection = null;\n            directConnection.ignore();\n            directConnection = null;\n        }\n\n        if (pc) {\n            pc.close({signal: (pc.state.receivedBye ? false : pc.state.signalBye)});\n        }",
            "ctx": {
                "type": "function",
                "name": "doHangup",
                "string": "doHangup()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#hangup"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "sentSignal",
                    "description": "- Whether or not we sent a 'hangup' signal to the other party."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event is fired when the call has hung up.</p>\n",
                "summary": "<p>This event is fired when the call has hung up.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('hangup', {\n            reason: pc.state.hangupReason || \"No reason specified.\"\n        });\n\n        pc.state.ignore();\n        pc.ignore();\n        that.ignore();\n        pc = null;\n    };\n    doHangup = respoke.once(doHangup);",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#hangup",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.reject"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Expose hangup as reject for approve/reject workflow.</p>\n",
                "summary": "<p>Expose hangup as reject for approve/reject workflow.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.reject = function () {\n        if (!pc) {\n            return;\n        }\n        pc.state.dispatch('reject', {reason: 'call.reject() called'});\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "reject",
                "string": "that.reject()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.isActive"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Indicate whether a call is being setup or is in progress.</p>\n",
                "summary": "<p>Indicate whether a call is being setup or is in progress.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.isActive = function () {\n        // TODO: make this look for remote streams, too. Want to make this handle one-way media calls.\n        return !!(pc && pc.isActive() && (\n            (that.outgoingMedia.hasMedia()) ||\n            (directConnection && directConnection.isActive())\n        ));\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "isActive",
                "string": "that.isActive()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.listenOffer"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "evt.signal",
                    "description": "- The offer signal including the sdp"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#modify"
                }
            ],
            "description": {
                "full": "<p>Save the offer so we can tell the browser about it after the PeerConnection is ready.</p>\n",
                "summary": "<p>Save the offer so we can tell the browser about it after the PeerConnection is ready.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.Call#modify"
            ],
            "ignore": false,
            "code": "function listenOffer(evt) {\n        log.debug('listenOffer', evt.signal);\n        var info = {};\n\n        that.sessionId = evt.signal.sessionId;\n        pc.state.listen('connecting:entry', function () {\n            if (!pc.state.caller) {\n                pc.processOffer(evt.signal.sessionDescription);\n            }\n        });",
            "ctx": {
                "type": "function",
                "name": "listenOffer",
                "string": "listenOffer()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Always overwrite constraints for callee on every offer, since answer() and accept() will\nalways be called after parsing the SDP.</p>\n",
                "summary": "<p>Always overwrite constraints for callee on every offer, since answer() and accept() will\nalways be called after parsing the SDP.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.outgoingMedia.constraints.video = respoke.sdpHasVideo(evt.signal.sessionDescription.sdp);\n        that.outgoingMedia.constraints.audio = respoke.sdpHasAudio(evt.signal.sessionDescription.sdp);\n\n        log.info(\"Setting outgoingMedia constraints to\", that.outgoingMedia.constraints);\n\n        if (pc.state.isModifying()) {\n            if (pc.state.needDirectConnection === true) {\n                info.directConnection = directConnection;\n            } else if (pc.state.needDirectConnection === false) {\n                // Nothing\n            } else {\n                info.call = that;\n            }",
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Call#modify"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "object"
                    ],
                    "name": "[constraints]",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "[directConnection]",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Indicates a request to add something to an existing call. If &#39;constraints&#39; is set, evt.constraints\ndescribes the media the other side has added. In this case, call.approve() must be called in order\nto approve the new media and send the same type of media.  If directConnection exists, the other side\nwishes to to open a direct connection. In order to approve, call directConnection.accept(). In either\ncase, call.reject() and directConnection.reject() can be called to decline the request to add to the\ncall.</p>\n",
                "summary": "<p>Indicates a request to add something to an existing call. If &#39;constraints&#39; is set, evt.constraints\ndescribes the media the other side has added. In this case, call.approve() must be called in order\nto approve the new media and send the same type of media.  If directConnection exists, the other side\nwishes to to open a direct connection. In order to approve, call directConnection.accept(). In either\ncase, call.reject() and directConnection.reject() can be called to decline the request to add to the\ncall.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('modify', info);\n        }\n\n        pc.state.dispatch('receiveOffer', {\n            previewLocalMedia: previewLocalMedia,\n            approve: that.approve\n        });\n    }",
            "ctx": {
                "type": "event",
                "name": "respoke.Call#modify",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.listenModify"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Save the answer and tell the browser about it.</p>\n",
                "summary": "<p>Save the answer and tell the browser about it.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function listenModify(evt) {\n        log.debug('Call.listenModify', evt);\n        if (evt.signal.action === 'initiate') {\n            defModify = Q.defer();\n            pc.state.dispatch('modify', {receive: true});\n        }\n    }",
            "ctx": {
                "type": "function",
                "name": "listenModify",
                "string": "listenModify()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.onModifyAccept"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Set up state and media for the modify.</p>\n",
                "summary": "<p>Set up state and media for the modify.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function onModifyAccept(evt) {\n        pc.state.dispatch('accept');\n\n        if (evt.signal.action !== 'initiate') {\n            defModify.resolve(); // resolved later for callee\n            defModify = undefined;\n            return;\n        }\n\n        // callee only from here down\n\n        // init the directConnection if necessary. We don't need to do anything with\n        // audio or video right now.\n        if (evt.signal.directConnection === true) {\n            actuallyAddDirectConnection().done(function successHandler(dc) {\n                directConnection = dc;\n                directConnection.accept();\n            });\n        } else if (evt.signal.directConnection === false) {\n            if (directConnection) {\n                that.removeDirectConnection({skipModify: true});\n                defMedia.resolve(false);\n            }\n        }\n        pc.state.needDirectConnection = typeof evt.signal.directConnection === 'boolean' ? evt.signal.directConnection : null;\n        that.outgoingMedia.constraints = evt.signal.constraints || that.outgoingMedia.constraints;\n    }",
            "ctx": {
                "type": "function",
                "name": "onModifyAccept",
                "string": "onModifyAccept()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.onModifyReject"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "Error"
                    ],
                    "name": "evt.err",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Ignore the modify.</p>\n",
                "summary": "<p>Ignore the modify.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function onModifyReject(evt) {\n        if (evt.signal.action !== 'initiate') {\n            defMedia.reject(evt.err);\n            defModify.reject(evt.err);\n            defModify = undefined;\n        }\n    }",
            "ctx": {
                "type": "function",
                "name": "onModifyReject",
                "string": "onModifyReject()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "deprecated",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.toggleVideo"
                }
            ],
            "description": {
                "full": "<p>If video is muted, unmute. If not muted, mute.</p>\n",
                "summary": "<p>If video is muted, unmute. If not muted, mute.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.toggleVideo = function () {\n        if (that.isActive()) {\n            if (!videoIsMuted) {\n                that.muteVideo();\n            } else {\n                that.unmuteVideo();\n            }\n        }\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "toggleVideo",
                "string": "that.toggleVideo()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "deprecated",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.toggleAudio"
                }
            ],
            "description": {
                "full": "<p>If audio is muted, unmute. If not muted, mute.</p>\n",
                "summary": "<p>If audio is muted, unmute. If not muted, mute.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.toggleAudio = function () {\n        if (that.isActive()) {\n            if (!audioIsMuted) {\n                that.muteAudio();\n            } else {\n                that.unmuteAudio();\n            }\n        }\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "toggleAudio",
                "string": "that.toggleAudio()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.hasMedia"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Indicate whether the call has media flowing.</p>\n",
                "summary": "<p>Indicate whether the call has media flowing.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.hasMedia = function () {\n        var local;\n        var remote;\n\n        if (!pc || !pc.getLocalStreams) {\n            // PeerConnection.init() has not been called yet\n            return false;\n        }\n\n        local = pc.getLocalStreams();\n        remote = pc.getRemoteStreams();\n\n        if (directConnection && directConnection.isActive()) {\n            return true;\n        }\n\n        return (local.length > 0 || remote.length > 0);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "hasMedia",
                "string": "that.hasMedia()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.muteVideo"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#mute"
                }
            ],
            "description": {
                "full": "<p>Mute all local video streams.</p>\n",
                "summary": "<p>Mute all local video streams.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.Call#mute"
            ],
            "ignore": false,
            "code": "that.muteVideo = function () {\n        if (videoIsMuted) {\n            return;\n        }\n        that.outgoingMedia.muteVideo();\n        videoIsMuted = true;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "muteVideo",
                "string": "that.muteVideo()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.unmuteVideo"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#mute"
                }
            ],
            "description": {
                "full": "<p>Unmute all local video streams.</p>\n",
                "summary": "<p>Unmute all local video streams.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.Call#mute"
            ],
            "ignore": false,
            "code": "that.unmuteVideo = function () {\n        if (!videoIsMuted) {\n            return;\n        }\n        that.outgoingMedia.unmuteVideo();\n        videoIsMuted = false;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "unmuteVideo",
                "string": "that.unmuteVideo()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.muteAudio"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#mute"
                }
            ],
            "description": {
                "full": "<p>Mute all local audio streams.</p>\n",
                "summary": "<p>Mute all local audio streams.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.Call#mute"
            ],
            "ignore": false,
            "code": "that.muteAudio = function () {\n        if (audioIsMuted) {\n            return;\n        }\n        that.outgoingMedia.muteAudio();\n        audioIsMuted = true;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "muteAudio",
                "string": "that.muteAudio()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.unmuteAudio"
                },
                {
                    "type": "fires",
                    "string": "respoke.Call#mute"
                }
            ],
            "description": {
                "full": "<p>Unmute all local audio streams.</p>\n",
                "summary": "<p>Unmute all local audio streams.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.Call#mute"
            ],
            "ignore": false,
            "code": "that.unmuteAudio = function () {\n        if (!audioIsMuted) {\n            return;\n        }\n\n        that.outgoingMedia.unmuteAudio();\n        audioIsMuted = false;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "unmuteAudio",
                "string": "that.unmuteAudio()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Call"
                },
                {
                    "type": "method",
                    "string": "respoke.Call.listenHangup"
                },
                {
                    "type": "params",
                    "string": "{object} evt"
                },
                {
                    "type": "params",
                    "string": "{object} evt.signal - The hangup signal, including an optional hangup reason."
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Save the hangup reason and hang up.</p>\n",
                "summary": "<p>Save the hangup reason and hang up.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function listenHangup(evt) {\n        if (!pc) {\n            return;\n        }\n        pc.report.callStoppedReason = evt.signal.reason || \"Remote side hung up\";\n        pc.state.receivedBye = true;\n        pc.state.dispatch('hangup', {signal: false, reason: pc.report.callStoppedReason});\n    }\n\n    pc.state.once('terminated:entry', function (evt) {\n        doHangup();\n    }, true);\n\n    that.listen('signal-offer', listenOffer, true);\n    that.listen('signal-hangup', listenHangup, true);\n    that.listen('signal-modify', listenModify, true);\n    pc.listen('modify-reject', onModifyReject, true);\n    pc.listen('modify-accept', onModifyAccept, true);\n    that.listen('signal-icecandidates', function onCandidateSignal(evt) {\n        if (!pc || !evt.signal.iceCandidates || !evt.signal.iceCandidates.length) {\n            return;\n        }\n        evt.signal.iceCandidates.forEach(function processCandidate(candidate) {\n            if (!pc) {\n                return;\n            }\n            pc.addRemoteCandidate({candidate: candidate});\n        });\n    }, true);\n\n    if (pc.state.needDirectConnection !== true) {\n        pc.state.once('preparing:entry', function () {",
            "ctx": {
                "type": "function",
                "name": "listenHangup",
                "string": "listenHangup()",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#call"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "call",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "endpoint",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event provides notification for when an incoming call is being received.  If the user wishes\nto allow the call, the app should call evt.call.answer() to answer the call.</p>\n",
                "summary": "<p>This event provides notification for when an incoming call is being received.  If the user wishes\nto allow the call, the app should call evt.call.answer() to answer the call.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "client.fire('call', {\n                endpoint: that.remoteEndpoint,\n                call: that\n            });\n        }, true);\n    }\n\n    pc.state.listen('idle:exit', function (evt) {\n        saveParameters(params);\n    });\n\n    pc.state.listen('preparing:entry', function (evt) {\n        init();\n\n        if (pc.state.caller === true) {\n            that.answer();\n        }\n    }, true);\n\n    signalingChannel.getTurnCredentials().then(function (result) {\n        if (!result) {\n            log.warn(\"Relay service not available.\");\n            pc.servers = {\n                iceServers: []\n            };\n        } else {\n            pc.servers = client.servers;\n            pc.servers.iceServers = result;\n        }\n    }).fin(function () {\n        pc.state.dispatch('initiate', {\n            client: client,\n            caller: that.caller\n        });\n    }).done(null, function (err) {\n        log.debug('Unexpected exception', err);\n    });\n\n    return that;\n}; // End respoke.Call",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#call",
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.errorHandler"
                },
                {
                    "type": "param",
                    "types": [
                        "Error"
                    ],
                    "name": "err",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Handle an error that resulted from a method call.</p>\n",
                "summary": "<p>Handle an error that resulted from a method call.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.statsSuccessHandler"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser"
                    ],
                    "name": "statsParser",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Handle the successful kick-off of stats on a call.</p>\n",
                "summary": "<p>Handle the successful kick-off of stats on a call.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.mediaSuccessHandler"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "localMedia",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Handle obtaining media successfully.</p>\n",
                "summary": "<p>Handle obtaining media successfully.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.onLocalMedia Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "Element"
                    ],
                    "name": "evt.element",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "-",
                    "description": "The outgoingMedia property on the call."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- The event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>When on a call, receive local media when it becomes available. This is what you will need to provide if you want\nto show the user their own video during a call. This callback is called every time\nrespoke.Call#local-stream-received is fired.</p>\n",
                "summary": "<p>When on a call, receive local media when it becomes available. This is what you will need to provide if you want\nto show the user their own video during a call. This callback is called every time\nrespoke.Call#local-stream-received is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.onConnect"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "Element"
                    ],
                    "name": "evt.element",
                    "description": "- the HTML5 Video element with the new stream attached."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>When on a call, receive remote media when it becomes available. This is what you will need to provide if you want\nto show the user the other party&#39;s video during a call. This callback is called every time\nrespoke.Call#connect is fired.</p>\n",
                "summary": "<p>When on a call, receive remote media when it becomes available. This is what you will need to provide if you want\nto show the user the other party&#39;s video during a call. This callback is called every time\nrespoke.Call#connect is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.onError"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "evt.reason",
                    "description": "- A human-readable description of the error."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>When a call is in setup or media renegotiation happens. This callback will be called every time\nrespoke.Call#error.</p>\n",
                "summary": "<p>When a call is in setup or media renegotiation happens. This callback will be called every time\nrespoke.Call#error.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.onHangup"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "evt.sentSignal",
                    "description": "- Whether or not we sent a 'hangup' signal to the other party."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>When on a call, receive notification the call has been hung up. This callback is called every time\nrespoke.Call#hangup is fired.</p>\n",
                "summary": "<p>When on a call, receive notification the call has been hung up. This callback is called every time\nrespoke.Call#hangup is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.onMute"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Called when changing the mute state on any type of media. This callback will be called when media is muted or\nunmuted. This callback is called every time respoke.Call#mute is fired.</p>\n",
                "summary": "<p>Called when changing the mute state on any type of media. This callback will be called when media is muted or\nunmuted. This callback is called every time respoke.Call#mute is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.onAnswer"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Called when the callee answers the call. This callback is called every time respoke.Call#answer is fired.</p>\n",
                "summary": "<p>Called when the callee answers the call. This callback is called every time respoke.Call#answer is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.onApprove"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Called when the user approves local media. This callback will be called whether or not the approval was based\non user feedback. I. e., it will be called even if the approval was automatic. This callback is called every time\nrespoke.Call#approve is fired.</p>\n",
                "summary": "<p>Called when the user approves local media. This callback will be called whether or not the approval was based\non user feedback. I. e., it will be called even if the approval was automatic. This callback is called every time\nrespoke.Call#approve is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.onAllow"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>When setting up a call, receive notification that the browser has granted access to media.  This callback is\ncalled every time respoke.Call#allow is fired.</p>\n",
                "summary": "<p>When setting up a call, receive notification that the browser has granted access to media.  This callback is\ncalled every time respoke.Call#allow is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.onRequestingMedia"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>When setting up a call, receive notification that the app has asked the browser for permission to get audio or\nvideo and is waiting on the browser to grant or reject permission. This callback will be called every time\nrespoke.Call#requesting-media is fired.</p>\n",
                "summary": "<p>When setting up a call, receive notification that the app has asked the browser for permission to get audio or\nvideo and is waiting on the browser to grant or reject permission. This callback will be called every time\nrespoke.Call#requesting-media is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.MediaStatsParser.statsHandler"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStats"
                    ],
                    "name": "evt.stats",
                    "description": "- an object with stats in it."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                }
            ],
            "description": {
                "full": "<p>The use of stats requires an additional module to Respoke. When on a call, receive periodic statistical\ninformation about the call, including the codec, lost packets, and bandwidth being consumed. This callback is\ncalled every time respoke.Call#stats is fired.</p>\n",
                "summary": "<p>The use of stats requires an additional module to Respoke. When on a call, receive periodic statistical\ninformation about the call, including the codec, lost packets, and bandwidth being consumed. This callback is\ncalled every time respoke.Call#stats is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.previewLocalMedia"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "element",
                    "description": "- the HTML5 Video element with the new stream attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "call",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>When on a call, receive local media when it becomes available. This is what you will need to provide if you want\nto allow the user to preview and approve or reject their own video before a call. If this callback is provided,\nRespoke will wait for call.answer() to be called before proceeding. If this callback is not provided,\nRespoke will proceed without waiting for user input. This callback is called every time\nrespoke.Call#local-stream-received is fired.</p>\n",
                "summary": "<p>When on a call, receive local media when it becomes available. This is what you will need to provide if you want\nto allow the user to preview and approve or reject their own video before a call. If this callback is provided,\nRespoke will wait for call.answer() to be called before proceeding. If this callback is not provided,\nRespoke will proceed without waiting for user input. This callback is called every time\nrespoke.Call#local-stream-received is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Call.directConnectionSuccessHandler"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "directConnection",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Receive the DirectConnection.</p>\n",
                "summary": "<p>Receive the DirectConnection.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/call.js",
                    "output": ".docs/site/respoke/call.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var log = require('loglevel');\nvar Q = require('q');\nvar respoke = require('./respoke');",
            "ctx": {
                "type": "declaration",
                "name": "log",
                "value": "require('loglevel')",
                "string": "log",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        }
    ],
    "respoke.Client": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.Client"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "augments",
                    "otherClass": "respoke.Presentable"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.appId]",
                    "description": "- The ID of your Respoke app. This must be passed either to\nrespoke.connect, respoke.createClient, or to client.connect."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.token]",
                    "description": "- The endpoint's authentication token."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.endpointId]",
                    "description": "- An identifier to use when creating an authentication token for this\nendpoint. This is only used when `developmentMode` is set to `true`."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.developmentMode=false]",
                    "description": "- Indication to obtain an authentication token from the service.\nNote: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\noperation and will limit the services you will be able to use."
                },
                {
                    "type": "param",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "Array"
                    ],
                    "name": "[params.presence=unavailable]",
                    "description": "The initial presence to set once connected."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.reconnect=true]",
                    "description": "- Whether or not to automatically reconnect to the Respoke service\nwhen a disconnect occurs."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onJoin"
                    ],
                    "name": "[params.onJoin]",
                    "description": "- Callback for when this client's endpoint joins a group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onLeave"
                    ],
                    "name": "[params.onLeave]",
                    "description": "- Callback for when this client's endpoint leaves a group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onClientMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Callback for when any message is received\nfrom anywhere on the system."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for Client connect."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onDisconnect"
                    ],
                    "name": "[params.onDisconnect]",
                    "description": "- Callback for Client disconnect."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onReconnect"
                    ],
                    "name": "[params.onReconnect]",
                    "description": "- Callback for Client reconnect."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onCall"
                    ],
                    "name": "[params.onCall]",
                    "description": "- Callback for when this client's user receives a call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onDirectConnection"
                    ],
                    "name": "[params.onDirectConnection]",
                    "description": "- Callback for when this client's user\nreceives a request for a direct connection."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Client}"
                }
            ],
            "description": {
                "full": "<p><code>respoke.Client</code> is the top-level interface to the API. Interacting with Respoke should be done using\na <code>respoke.Client</code> instance.</p>\n<p>There are two ways to get a client:</p>\n<pre><code> var client = respoke.createClient(clientParams);\n // . . . set stuff up, then . . .\n client.connect(connectParams);\n</code></pre><p>or</p>\n<pre><code> // creates client and connects to Respoke all at once\n var client = respoke.connect(allParams);\n</code></pre><p>A client does the following things:</p>\n<ol>\n<li>authentication with the Respoke API</li>\n<li>receives server-side app-specific information</li>\n<li>tracks connections and presence</li>\n<li>provides methods to get and interact with tracked entities (like groups and endpoints)</li>\n<li>stores default settings for calls and direct connections</li>\n<li>automatically reconnects to the API when network activity is lost*</li>\n</ol>\n<p>*If <code>developmentMode</code> is set to true. If not using <code>developmentMode</code>, disable automatic\nreconnect by sending <code>reconnect: false</code> and listening to the Client&#39;s disconnect event\nto fetch a new brokered auth token, then call <code>client.connect()</code> with the new token.</p>\n",
                "summary": "<p><code>respoke.Client</code> is the top-level interface to the API. Interacting with Respoke should be done using\na <code>respoke.Client</code> instance.</p>\n",
                "body": "<p>There are two ways to get a client:</p>\n<pre><code> var client = respoke.createClient(clientParams);\n // . . . set stuff up, then . . .\n client.connect(connectParams);\n</code></pre><p>or</p>\n<pre><code> // creates client and connects to Respoke all at once\n var client = respoke.connect(allParams);\n</code></pre><p>A client does the following things:</p>\n<ol>\n<li>authentication with the Respoke API</li>\n<li>receives server-side app-specific information</li>\n<li>tracks connections and presence</li>\n<li>provides methods to get and interact with tracked entities (like groups and endpoints)</li>\n<li>stores default settings for calls and direct connections</li>\n<li>automatically reconnects to the API when network activity is lost*</li>\n</ol>\n<p>*If <code>developmentMode</code> is set to true. If not using <code>developmentMode</code>, disable automatic\nreconnect by sending <code>reconnect: false</code> and listening to the Client&#39;s disconnect event\nto fetch a new brokered auth token, then call <code>client.connect()</code> with the new token.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "module.exports = function (params) {\n    \"use strict\";\n    params = params || {};",
            "ctx": {
                "type": "method",
                "receiver": "module",
                "name": "respoke.Client",
                "string": "module.exports()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "instanceId"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Client</p>\n",
                "summary": "<p>@memberof! respoke.Client</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var instanceId = params.instanceId || respoke.makeGUID();\n    params.instanceId = instanceId;\n    var that = respoke.Presentable(params);\n    respoke.instances[instanceId] = that;\n    delete that.instanceId;\n    that.connectTries = 0;",
            "ctx": {
                "type": "declaration",
                "name": "instanceId",
                "value": "params.instanceId || respoke.makeGUID()",
                "string": "instanceId",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>A name to identify this class</p>\n",
                "summary": "<p>A name to identify this class</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.Client';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.Client'",
                "string": "that.className",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "host"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Client</p>\n",
                "summary": "<p>@memberof! respoke.Client</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var host = window.location.hostname;",
            "ctx": {
                "type": "declaration",
                "name": "host",
                "value": "window.location.hostname",
                "string": "host",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "port"
                },
                {
                    "type": "type",
                    "types": [
                        "number"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Client</p>\n",
                "summary": "<p>@memberof! respoke.Client</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var port = window.location.port;",
            "ctx": {
                "type": "declaration",
                "name": "port",
                "value": "window.location.port",
                "string": "port",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "name",
                    "string": "superClass"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                }
            ],
            "description": {
                "full": "<p>A simple POJO to store some methods we will want to override but reference later.</p>\n",
                "summary": "<p>A simple POJO to store some methods we will want to override but reference later.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var superClass = {\n        setPresence: that.setPresence\n    };",
            "ctx": {
                "type": "declaration",
                "name": "superClass",
                "value": "{",
                "string": "superClass",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "name",
                    "string": "clientSettings"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "[baseURL]",
                    "description": "- the URL of the cloud infrastructure's REST API."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "[token]",
                    "description": "- The endpoint's authentication token."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "[appId]",
                    "description": "- The id of your Respoke app."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "[endpointId]",
                    "description": "- An identifier to use when creating an authentication token for this\nendpoint. This is only used when `developmentMode` is set to `true`."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "[developmentMode=false]",
                    "description": "- Indication to obtain an authentication token from the service.\nNote: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\noperation and will limit the services you will be able to use."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "[reconnect=false]",
                    "description": "- Whether or not to automatically reconnect to the Respoke service\nwhen a disconnect occurs."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onJoin"
                    ],
                    "name": "[params.onJoin]",
                    "description": "- Callback for when this client's endpoint joins a group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onLeave"
                    ],
                    "name": "[params.onLeave]",
                    "description": "- Callback for when this client's endpoint leaves a group."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client.onClientMessage"
                    ],
                    "name": "[onMessage]",
                    "description": "- Callback for when any message is received\nfrom anywhere on the system."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client.onConnect"
                    ],
                    "name": "[onConnect]",
                    "description": "- Callback for Client connect."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client.onDisconnect"
                    ],
                    "name": "[onDisconnect]",
                    "description": "- Callback for Client disconnect."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client.onReconnect"
                    ],
                    "name": "[onReconnect]",
                    "description": "- Callback for Client reconnect. Not Implemented."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client.onCall"
                    ],
                    "name": "[onCall]",
                    "description": "- Callback for when this client receives a call."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client.onDirectConnection"
                    ],
                    "name": "[onDirectConnection]",
                    "description": "- Callback for when this client\nreceives a request for a direct connection."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "enableCallDebugReport=true",
                    "description": "- Upon finishing a call, should the client send debugging\ninformation to the API? Defaults to `true`."
                }
            ],
            "description": {
                "full": "<p>A container for baseURL, token, and appId so they won&#39;t be accidentally viewable in any JavaScript debugger.</p>\n",
                "summary": "<p>A container for baseURL, token, and appId so they won&#39;t be accidentally viewable in any JavaScript debugger.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var clientSettings = {};\n\n    delete that.appId;\n    delete that.baseURL;\n    delete that.developmentMode;\n    delete that.token;\n    delete that.resolveEndpointPresence;",
            "ctx": {
                "type": "declaration",
                "name": "clientSettings",
                "value": "{}",
                "string": "clientSettings",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "name",
                    "string": "groups"
                },
                {
                    "type": "type",
                    "types": [
                        "Array<respoke.Group>"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Internal list of known groups.</p>\n",
                "summary": "<p>Internal list of known groups.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var groups = [];",
            "ctx": {
                "type": "declaration",
                "name": "groups",
                "value": "[]",
                "string": "groups",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "name",
                    "string": "endpoints"
                },
                {
                    "type": "type",
                    "types": [
                        "Array<respoke.Endpoint>"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Internal list of known endpoints.</p>\n",
                "summary": "<p>Internal list of known endpoints.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var endpoints = [];",
            "ctx": {
                "type": "declaration",
                "name": "endpoints",
                "value": "[]",
                "string": "endpoints",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "name",
                    "string": "calls"
                },
                {
                    "type": "type",
                    "types": [
                        "array"
                    ]
                }
            ],
            "description": {
                "full": "<p>Array of calls in progress, made accessible for informational purposes only.\n<strong>Never modify this array directly.</strong></p>\n",
                "summary": "<p>Array of calls in progress, made accessible for informational purposes only.\n<strong>Never modify this array directly.</strong></p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.calls = [];\n    log.debug(\"Client ID is \", instanceId);",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "calls",
                "value": "[]",
                "string": "that.calls",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "signalingChannel"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.SignalingChannel"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Client</p>\n",
                "summary": "<p>@memberof! respoke.Client</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var signalingChannel = respoke.SignalingChannel({\n        instanceId: instanceId,\n        clientSettings: clientSettings\n    });",
            "ctx": {
                "type": "declaration",
                "name": "signalingChannel",
                "value": "respoke.SignalingChannel({",
                "string": "signalingChannel",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.saveParameters"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.connectSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation\nof this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.appId]",
                    "description": "- The ID of your Respoke app. This must be passed either to\nrespoke.connect, respoke.createClient, or to client.connect."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.token]",
                    "description": "- The endpoint's authentication token."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.endpointId]",
                    "description": "- An identifier to use when creating an authentication token for this\nendpoint. This is only used when `developmentMode` is set to `true`."
                },
                {
                    "type": "param",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "Array"
                    ],
                    "name": "[params.presence]",
                    "description": "The initial presence to set once connected."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.client.resolveEndpointPresence"
                    ],
                    "name": "[params.resolveEndpointPresence]",
                    "description": "An optional function for\nresolving presence for an endpoint. An endpoint can have multiple Connections this function will be used\nto decide which Connection's presence gets precedence for the Endpoint."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.developmentMode=false]",
                    "description": "- Indication to obtain an authentication token from the service.\nNote: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\noperation and will limit the services you will be able to use."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.reconnect=true]",
                    "description": "- Whether or not to automatically reconnect to the Respoke service\nwhen a disconnect occurs."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onJoin"
                    ],
                    "name": "[params.onJoin]",
                    "description": "- Callback for when this client's endpoint joins a group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onLeave"
                    ],
                    "name": "[params.onLeave]",
                    "description": "- Callback for when this client's endpoint leaves\na group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onClientMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Callback for when any message is\nreceived from anywhere on the system."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for Client connect."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onDisconnect"
                    ],
                    "name": "[params.onDisconnect]",
                    "description": "- Callback for Client disconnect."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onReconnect"
                    ],
                    "name": "[params.onReconnect]",
                    "description": "- Callback for Client reconnect. Not Implemented."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onCall"
                    ],
                    "name": "[params.onCall]",
                    "description": "- Callback for when this client receives a call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onDirectConnection"
                    ],
                    "name": "[params.onDirectConnection]",
                    "description": "- Callback for when this\nclient receives a request for a direct connection."
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Save parameters of the constructor or client.connect() onto the clientSettings object</p>\n",
                "summary": "<p>Save parameters of the constructor or client.connect() onto the clientSettings object</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function saveParameters(params) {\n        Object.keys(params).forEach(function eachParam(key) {\n            if (['onSuccess', 'onError', 'reconnect'].indexOf(key) === -1 && params[key] !== undefined) {\n                clientSettings[key] = params[key];\n            }\n        });\n\n        clientSettings.developmentMode = !!clientSettings.developmentMode;\n        clientSettings.enableCallDebugReport = typeof clientSettings.enableCallDebugReport === 'boolean' ?\n            clientSettings.enableCallDebugReport : true;\n\n        if (typeof params.reconnect !== 'boolean') {\n            clientSettings.reconnect = typeof params.developmentMode === 'boolean' ? params.developmentMode : false;\n        } else {\n            clientSettings.reconnect = !!params.reconnect;\n        }\n    }\n    saveParameters(params);",
            "ctx": {
                "type": "function",
                "name": "saveParameters",
                "string": "saveParameters()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.connect"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.connectSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation\nof this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.appId]",
                    "description": "- The ID of your Respoke app. This must be passed either to\nrespoke.connect, respoke.createClient, or to client.connect."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.token]",
                    "description": "- The endpoint's authentication token."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.endpointId]",
                    "description": "- An identifier to use when creating an authentication token for this\nendpoint. This is only used when `developmentMode` is set to `true`."
                },
                {
                    "type": "param",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "Array"
                    ],
                    "name": "[params.presence]",
                    "description": "The initial presence to set once connected."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.client.resolveEndpointPresence"
                    ],
                    "name": "[params.resolveEndpointPresence]",
                    "description": "An optional function for\nresolving presence for an endpoint. An endpoint can have multiple Connections this function will be used\nto decide which Connection's presence gets precedence for the Endpoint."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.developmentMode=false]",
                    "description": "- Indication to obtain an authentication token from the service.\nNote: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\noperation and will limit the services you will be able to use."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.reconnect=true]",
                    "description": "- Whether or not to automatically reconnect to the Respoke service\nwhen a disconnect occurs."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onJoin"
                    ],
                    "name": "[params.onJoin]",
                    "description": "- Callback for when this client's endpoint joins a group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onLeave"
                    ],
                    "name": "[params.onLeave]",
                    "description": "- Callback for when this client's endpoint leaves\na group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onClientMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Callback for when any message is\nreceived from anywhere on the system."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for Client connect."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onDisconnect"
                    ],
                    "name": "[params.onDisconnect]",
                    "description": "- Callback for Client disconnect."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onReconnect"
                    ],
                    "name": "[params.onReconnect]",
                    "description": "- Callback for Client reconnect. Not Implemented."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onCall"
                    ],
                    "name": "[params.onCall]",
                    "description": "- Callback for when this client receives a call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.onDirectConnection"
                    ],
                    "name": "[params.onDirectConnection]",
                    "description": "- Callback for when this\nclient receives a request for a direct connection."
                },
                {
                    "type": "returns",
                    "string": "{Promise|undefined}"
                },
                {
                    "type": "fires",
                    "string": "respoke.Client#connect"
                }
            ],
            "description": {
                "full": "<p>Connect to the Respoke infrastructure and authenticate using <code>params.token</code>.</p>\n<p>After <code>connect</code>, the app auth session token is stored so it can be used in API requests.</p>\n<p>This method attaches quite a few event listeners for things like group joining and connection status changes.</p>\n<h4 id=\"usage\">Usage</h4>\n<pre><code> client.connect({\n     appId: &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX&quot;,\n     token: &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX&quot;, // if not developmentMode\n     developmentMode: false || true,\n     // if developmentMode, otherwise your server will set endpointId\n     endpointId: &quot;billy&quot;\n });\n client.listen(&quot;connect&quot;, function () { } );\n</code></pre><p>If no <code>params.token</code> is given and <code>developmentMode</code> is set to true, it will attempt to obtain a token\nautomatically. You must set an <code>endpointId</code>.</p>\n<h4 id=\"app-auth-session-token-expiration\">App auth session token expiration</h4>\n<p>If <code>params.reconnect</code> is set to true (which it is by default for <code>developmentMode</code>), the <code>client</code>\nwill attempt to keep reconnecting each time the app auth session expires.</p>\n<p>If not using <code>developmentMode</code>, automatic reconnect will be disabled. You will need to\nlisten to the Client&#39;s <code>disconnect</code> event to fetch a new brokered auth token and call\n<code>client.connect()</code> with the new token.</p>\n<pre><code> client.listen(&#39;disconnect&#39;, function () {\n\n     // example method you implemented to get a new token from your server\n     myServer.getNewRespokeAccessToken(function (newToken) {\n         // reconnect with respoke.Client\n         client.connect({ token: newToken });\n     });\n\n });\n</code></pre>",
                "summary": "<p>Connect to the Respoke infrastructure and authenticate using <code>params.token</code>.</p>\n",
                "body": "<p>After <code>connect</code>, the app auth session token is stored so it can be used in API requests.</p>\n<p>This method attaches quite a few event listeners for things like group joining and connection status changes.</p>\n<h4 id=\"usage\">Usage</h4>\n<pre><code> client.connect({\n     appId: &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX&quot;,\n     token: &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX&quot;, // if not developmentMode\n     developmentMode: false || true,\n     // if developmentMode, otherwise your server will set endpointId\n     endpointId: &quot;billy&quot;\n });\n client.listen(&quot;connect&quot;, function () { } );\n</code></pre><p>If no <code>params.token</code> is given and <code>developmentMode</code> is set to true, it will attempt to obtain a token\nautomatically. You must set an <code>endpointId</code>.</p>\n<h4 id=\"app-auth-session-token-expiration\">App auth session token expiration</h4>\n<p>If <code>params.reconnect</code> is set to true (which it is by default for <code>developmentMode</code>), the <code>client</code>\nwill attempt to keep reconnecting each time the app auth session expires.</p>\n<p>If not using <code>developmentMode</code>, automatic reconnect will be disabled. You will need to\nlisten to the Client&#39;s <code>disconnect</code> event to fetch a new brokered auth token and call\n<code>client.connect()</code> with the new token.</p>\n<pre><code> client.listen(&#39;disconnect&#39;, function () {\n\n     // example method you implemented to get a new token from your server\n     myServer.getNewRespokeAccessToken(function (newToken) {\n         // reconnect with respoke.Client\n         client.connect({ token: newToken });\n     });\n\n });\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [
                "respoke.Client#connect"
            ],
            "ignore": false,
            "code": "that.connect = function (params) {\n        var promise;\n        var retVal;\n        params = params || {};\n        log.debug('Client.connect');\n        that.connectTries += 1;\n\n        saveParameters(params);\n\n        that.endpointId = clientSettings.endpointId;\n        promise = actuallyConnect(params);\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        promise.then(function successHandler() {",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "connect",
                "string": "that.connect()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#connect"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event is fired the first time the library connects to the cloud infrastructure.</p>\n",
                "summary": "<p>This event is fired the first time the library connects to the cloud infrastructure.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('connect');",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#connect",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "ignore",
                    "string": "**This comment is for documentation purposes**, since #error bubbles\nup from other classes, but it should show on `respoke.Client` docs.\n"
                },
                {
                    "type": "event",
                    "string": "respoke.Client#error"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event fires only when the initial <code>connect</code> fails.</p>\n",
                "summary": "<p>This event fires only when the initial <code>connect</code> fails.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "});\n        return retVal;\n    };",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#error",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.actuallyConnect"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "connectSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "returns",
                    "string": "{Promise|undefined}"
                }
            ],
            "description": {
                "full": "<p>This function contains the meat of the connection, the portions which can be repeated again on reconnect.</p>\n<p>When <code>reconnect</code> is true, this function will be added in an event listener to the Client#disconnect event.</p>\n<p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n",
                "summary": "<p>This function contains the meat of the connection, the portions which can be repeated again on reconnect.</p>\n",
                "body": "<p>When <code>reconnect</code> is true, this function will be added in an event listener to the Client#disconnect event.</p>\n<p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n"
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function actuallyConnect(params) {\n        params = params || {};\n        var deferred = Q.defer();\n\n        if (!clientSettings.token &&\n                (!clientSettings.appId || !clientSettings.endpointId || clientSettings.developmentMode !== true)) {\n            deferred.reject(new Error(\"Must pass either endpointID & appId & developmentMode=true, or a token, \" +\n                \"to client.connect().\"));\n            return deferred.promise;\n        }\n\n        signalingChannel.open({\n            actuallyConnect: actuallyConnect,\n            endpointId: that.endpointId,\n            token: clientSettings.token\n        }).then(function successHandler() {\n            return signalingChannel.authenticate();\n        }).done(function successHandler() {\n            // set initial presence for the connection\n            if (clientSettings.presence) {\n                that.setPresence({presence: clientSettings.presence});\n            }",
            "ctx": {
                "type": "function",
                "name": "actuallyConnect",
                "string": "actuallyConnect()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>These rely on the EventEmitter checking for duplicate event listeners in order for these\nnot to be duplicated on reconnect.</p>\n",
                "summary": "<p>These rely on the EventEmitter checking for duplicate event listeners in order for these\nnot to be duplicated on reconnect.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#call"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "call",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "endpoint",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- The event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event provides notification for when an incoming call is being received.  If the user wishes\nto allow the call, <code>evt.call.answer()</code>.</p>\n",
                "summary": "<p>This event provides notification for when an incoming call is being received.  If the user wishes\nto allow the call, <code>evt.call.answer()</code>.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('call', clientSettings.onCall);",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#call",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#direct-connection"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "directConnection",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "endpoint",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event is fired when the local end of the directConnection is available. It still will not be\nready to send and receive messages until the &#39;open&#39; event fires.</p>\n",
                "summary": "<p>This event is fired when the local end of the directConnection is available. It still will not be\nready to send and receive messages until the &#39;open&#39; event fires.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('direct-connection', clientSettings.onDirectConnection);\n            that.listen('join', clientSettings.onJoin);",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#direct-connection",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#leave"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "group",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                }
            ],
            "description": {
                "full": "<p>This event is fired every time the client leaves a group.</p>\n",
                "summary": "<p>This event is fired every time the client leaves a group.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('leave', clientSettings.onLeave);",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#leave",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#message"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- The event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "endpoint",
                    "description": "- If the message was private, this is the Endpoint who sent it."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "group",
                    "description": "- If the message was to a group, this is the group."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.TextMessage"
                    ],
                    "name": "message",
                    "description": "- The generic message object."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "message.connectionId",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "message.endpointId",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "message.message",
                    "description": "- Message body text."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>A generic message handler when a message was received by the client.</p>\n",
                "summary": "<p>A generic message handler when a message was received by the client.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('message', clientSettings.onMessage);\n            that.listen('connect', clientSettings.onConnect);",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#message",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#disconnect"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- The event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Client has disconnected from Respoke.</p>\n",
                "summary": "<p>Client has disconnected from Respoke.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('disconnect', clientSettings.onDisconnect);",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#disconnect",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#reconnect"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- The event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Client has reconnected to Respoke.</p>\n",
                "summary": "<p>Client has reconnected to Respoke.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('reconnect', clientSettings.onReconnect);\n\n            log.info('logged in as ' + that.endpointId, that);\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject(\"Couldn't create an endpoint.\");\n            log.error(err.message, err.stack);\n        });\n\n        return deferred.promise;\n    }",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#reconnect",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.disconnect"
                },
                {
                    "type": "returns",
                    "string": "{Promise|undefined}"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "disconnectSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "fires",
                    "string": "respoke.Client#disconnect"
                }
            ],
            "description": {
                "full": "<p>Disconnect from the Respoke infrastructure, leave all groups, invalidate the token, and disconnect the websocket.\n<strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n",
                "summary": "<p>Disconnect from the Respoke infrastructure, leave all groups, invalidate the token, and disconnect the websocket.\n<strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.Client#disconnect"
            ],
            "ignore": false,
            "code": "that.disconnect = function (params) {\n        // TODO: also call this on socket disconnect\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            deferred.reject(e);\n            return retVal;\n        }\n\n        var leaveGroups = groups.map(function eachGroup(group) {\n            group.leave();\n        });\n\n        Q.all(leaveGroups).fin(function successHandler() {\n            return signalingChannel.close();\n        }).fin(function finallyHandler() {\n            that.presence = 'unavailable';\n            endpoints = [];\n            groups = [];",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "disconnect",
                "string": "that.disconnect()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#disconnect"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event is fired when the library has disconnected from the cloud infrastructure.</p>\n",
                "summary": "<p>This event is fired when the library has disconnected from the cloud infrastructure.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('disconnect');\n            deferred.resolve();\n        }).done();\n\n        return retVal;\n    };",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#disconnect",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.setPresence"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "array"
                    ],
                    "name": "params.presence",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.successHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of\nthis method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "overrides",
                    "string": "Presentable.setPresence"
                },
                {
                    "type": "return",
                    "string": "{Promise|undefined}"
                }
            ],
            "description": {
                "full": "<p>Set the presence for this client.</p>\n<p>The value of presence can be a string, number, object, or array - in any format -\ndepending on the needs of your application. The only requirement is that\n<code>JSON.stringify()</code> must work (no circular references).</p>\n<pre><code> var myPresence = &#39;At lunch&#39;\n                 || 4\n                 || { status: &#39;Away&#39;, message: &#39;At lunch&#39; }\n                 || [&#39;Away&#39;, &#39;At lunch&#39;];\n\n client.setPresence({\n     presence: myPresence,\n     onSuccess: function (evt) {\n         // successfully updated my presence\n     }\n });\n</code></pre><p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n",
                "summary": "<p>Set the presence for this client.</p>\n",
                "body": "<p>The value of presence can be a string, number, object, or array - in any format -\ndepending on the needs of your application. The only requirement is that\n<code>JSON.stringify()</code> must work (no circular references).</p>\n<pre><code> var myPresence = &#39;At lunch&#39;\n                 || 4\n                 || { status: &#39;Away&#39;, message: &#39;At lunch&#39; }\n                 || [&#39;Away&#39;, &#39;At lunch&#39;];\n\n client.setPresence({\n     presence: myPresence,\n     onSuccess: function (evt) {\n         // successfully updated my presence\n     }\n });\n</code></pre><p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.setPresence = function (params) {\n        var promise;\n        var retVal;\n        params = params || {};\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n        }\n\n        log.info('sending my presence update ' + params.presence);\n\n        promise = signalingChannel.sendPresence({\n            presence: params.presence\n        });\n\n        promise.then(function successHandler(p) {\n            superClass.setPresence(params);\n            clientSettings.presence = params.presence;\n        });\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        return retVal;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "setPresence",
                "string": "that.setPresence()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.getCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.id]",
                    "description": "- Call ID."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.endpointId]",
                    "description": "- Endpoint ID. Warning: If you pass only the endpointId, this method\nwill just return the first call that matches. If you are placing multiple calls to the same endpoint,\npass in the call ID, too."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "params.create",
                    "description": "- whether or not to create a new call if the specified endpointId isn't found"
                },
                {
                    "type": "returns",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Get the Call with the endpoint specified.</p>\n<pre><code>// hang up on chad\nvar call = client.getCall({\n    endpointId: &#39;chad&#39;\n});\n\nif (call) {\n    call.hangup()\n}\n</code></pre>",
                "summary": "<p>Get the Call with the endpoint specified.</p>\n",
                "body": "<pre><code>// hang up on chad\nvar call = client.getCall({\n    endpointId: &#39;chad&#39;\n});\n\nif (call) {\n    call.hangup()\n}\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getCall = function (params) {\n        var call = null;\n        var endpoint = null;\n\n        that.calls.every(function findCall(one) {\n            if (params.id && one.id === params.id) {\n                call = one;\n                return false;\n            }\n\n            if (!params.id && params.endpointId && one.remoteEndpoint.id === params.endpointId) {\n                call = one;\n                return false;\n            }\n            return true;\n        });\n\n        if (call === null && params.create === true) {\n            if (params.fromType === 'did') {\n                try {\n                    call = that.startPhoneCall({\n                        id: params.id,\n                        number: params.endpointId, //phone number\n                        caller: false,\n                        fromType: 'web',\n                        toType: 'did'\n                    });\n                } catch (e) {\n                    log.error(\"Couldn't create Call.\", e.message, e.stack);\n                }\n            } else {\n                endpoint = that.getEndpoint({id: params.endpointId});\n                try {\n                    call = endpoint.startCall({\n                        id: params.id,\n                        caller: false\n                    });\n                } catch (e) {\n                    log.error(\"Couldn't create Call.\", e.message, e.stack);\n                }\n            }\n        }\n        return call;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getCall",
                "string": "that.getCall()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.addCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.call",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "evt.endpoint",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Add the call to internal record-keeping.</p>\n",
                "summary": "<p>Add the call to internal record-keeping.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function addCall(evt) {\n        log.debug('addCall');\n        if (!evt.call) {\n            throw new Error(\"Can't add call without a call parameter.\");\n        }\n        if (that.calls.indexOf(evt.call) === -1) {\n            that.calls.push(evt.call);\n        }\n\n        evt.call.listen('hangup', function () {\n            removeCall({call: evt.call});\n        });\n    }",
            "ctx": {
                "type": "function",
                "name": "addCall",
                "string": "addCall()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.removeCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Remove the call or direct connection from internal record-keeping.</p>\n",
                "summary": "<p>Remove the call or direct connection from internal record-keeping.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function removeCall(evt) {\n        var match = 0;\n        if (!evt.call) {\n            throw new Error(\"Can't remove call without a call parameter.\");\n        }\n\n        // Loop backward since we're modifying the array in place.\n        for (var i = that.calls.length - 1; i >= 0; i -= 1) {\n            if (that.calls[i].id === evt.call.id) {\n                that.calls.splice(i, 1);\n                match += 1;\n            }\n        }\n\n        if (match !== 1) {\n            log.warn(\"Something went wrong.\", match, \"calls were removed!\");\n        }\n    }",
            "ctx": {
                "type": "function",
                "name": "removeCall",
                "string": "removeCall()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.setOnline"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "Array"
                    ],
                    "name": "[params.presence=available]",
                    "description": "- The presence to set."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.successHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of\nthis method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "returns",
                    "string": "{Promise|undefined}"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Convenience method for setting presence to <code>&quot;available&quot;</code>.</p>\n<p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n",
                "summary": "<p>Convenience method for setting presence to <code>&quot;available&quot;</code>.</p>\n",
                "body": "<p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n"
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.setOnline = function (params) {\n        var promise;\n\n        params = params || {};\n        params.presence = params.presence || 'available';\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n        }\n\n        return that.setPresence(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "setOnline",
                "string": "that.setOnline()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.setOffline"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "Array"
                    ],
                    "name": "[params.presence=unavailable]",
                    "description": "- The presence to set."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.successHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of\nthis method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "returns",
                    "string": "{Promise|undefined}"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Convenience method for setting presence to <code>&quot;unavailable&quot;</code>.</p>\n<p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n",
                "summary": "<p>Convenience method for setting presence to <code>&quot;unavailable&quot;</code>.</p>\n",
                "body": "<p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n"
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.setOffline = function (params) {\n        var promise;\n\n        params = params || {};\n        params.presence = params.presence || 'unavailable';\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            return respoke.handlePromise(promise, params.onSuccess, params.onError);\n        }\n\n        return that.setPresence(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "setOffline",
                "string": "that.setOffline()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.sendMessage"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.endpointId",
                    "description": "- The endpoint id of the recipient."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": "- The optional connection id of the receipient. If not set, message will be\nbroadcast to all connections for this endpoint."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.message",
                    "description": "- a string message."
                },
                {
                    "type": "param",
                    "types": [
                        "sendHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "returns",
                    "string": "{Promise|undefined}"
                }
            ],
            "description": {
                "full": "<p>Send a message to an endpoint.</p>\n<pre><code>client.sendMessage({\n    endpointId: &#39;dan&#39;,\n    message: &quot;Jolly good.&quot;\n});\n</code></pre><p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n",
                "summary": "<p>Send a message to an endpoint.</p>\n",
                "body": "<pre><code>client.sendMessage({\n    endpointId: &#39;dan&#39;,\n    message: &quot;Jolly good.&quot;\n});\n</code></pre><p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.sendMessage = function (params) {\n        var promise;\n        var retVal;\n        var endpoint;\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n        endpoint = that.getEndpoint({id: params.endpointId});\n        delete params.endpointId;\n        return endpoint.sendMessage(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "sendMessage",
                "string": "that.sendMessage()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.startCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.endpointId",
                    "description": "- The id of the endpoint that should be called."
                },
                {
                    "type": "param",
                    "types": [
                        "RTCConstraints"
                    ],
                    "name": "[params.constraints]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video element\nwith the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for receiving an HTML5 Video element\nwith the remote audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for being notified when the call has been hung\nup."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback for receiving statistical\ninformation."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": "- The connection ID of the remoteEndpoint, if it is not desired to call\nall connections belonging to this endpoint."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "[params.videoLocalElement]",
                    "description": "- Pass in an optional html video element to have local video attached to it."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "[params.videoRemoteElement]",
                    "description": "- Pass in an optional html video element to have remote video attached to it."
                },
                {
                    "type": "return",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Place an audio and/or video call to an endpoint.</p>\n<pre><code>// defaults to video when no constraints are supplied\nclient.startCall({\n    endpointId: &#39;erin&#39;,\n    onConnect: function (evt) { },\n    onLocalMedia: function (evt) { }\n});\n</code></pre>",
                "summary": "<p>Place an audio and/or video call to an endpoint.</p>\n",
                "body": "<pre><code>// defaults to video when no constraints are supplied\nclient.startCall({\n    endpointId: &#39;erin&#39;,\n    onConnect: function (evt) { },\n    onLocalMedia: function (evt) { }\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startCall = function (params) {\n        var promise;\n        var retVal;\n        var endpoint;\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n\n        endpoint = that.getEndpoint({id: params.endpointId});\n        delete params.endpointId;\n        return endpoint.startCall(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startCall",
                "string": "that.startCall()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.startAudioCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.endpointId",
                    "description": "- The id of the endpoint that should be called."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 element\nwith the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for receiving an HTML5 element\nwith the remote audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for being notified when the call has been hung\nup."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback for receiving statistical\ninformation."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": "- The connection ID of the remoteEndpoint, if it is not desired to call\nall connections belonging to this endpoint."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "[params.videoLocalElement]",
                    "description": "- Pass in an optional html video element to have local\nvideo attached to it."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "[params.videoRemoteElement]",
                    "description": "- Pass in an optional html video element to have remote\nvideo attached to it."
                },
                {
                    "type": "return",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Place an audio only call to an endpoint.</p>\n<pre><code>client.startAudioCall({\n    endpointId: &#39;erin&#39;,\n    onConnect: function (evt) { },\n    onLocalMedia: function (evt) { }\n});\n</code></pre>",
                "summary": "<p>Place an audio only call to an endpoint.</p>\n",
                "body": "<pre><code>client.startAudioCall({\n    endpointId: &#39;erin&#39;,\n    onConnect: function (evt) { },\n    onLocalMedia: function (evt) { }\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startAudioCall = function (params) {\n        params = params || {};\n        params.constraints = {\n            video : false,\n            audio : true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startAudioCall",
                "string": "that.startAudioCall()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.startVideoCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.endpointId",
                    "description": "- The id of the endpoint that should be called."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video element\nwith the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for receiving an HTML5 Video element\nwith the remote audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for being notified when the call has been hung\nup."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback for receiving statistical\ninformation."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": "- The connection ID of the remoteEndpoint, if it is not desired to call\nall connections belonging to this endpoint."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "[params.videoLocalElement]",
                    "description": "- Pass in an optional html video element to have local\nvideo attached to it."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "[params.videoRemoteElement]",
                    "description": "- Pass in an optional html video element to have remote\nvideo attached to it."
                },
                {
                    "type": "return",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Place a video call to an endpoint.</p>\n<pre><code>client.startVideoCall({\n    endpointId: &#39;erin&#39;,\n    onConnect: function (evt) { },\n    onLocalMedia: function (evt) { }\n});\n</code></pre>",
                "summary": "<p>Place a video call to an endpoint.</p>\n",
                "body": "<pre><code>client.startVideoCall({\n    endpointId: &#39;erin&#39;,\n    onConnect: function (evt) { },\n    onLocalMedia: function (evt) { }\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startVideoCall = function (params) {\n        params = params || {};\n        params.constraints = {\n            video : true,\n            audio : true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startVideoCall",
                "string": "that.startVideoCall()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.startPhoneCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.number",
                    "description": "- The phone number that should be called."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video element\nwith the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for receiving an HTML5 Video element\nwith the remote audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for being notified when the call has been hung\nup."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback for receiving statistical\ninformation."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "return",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Place an audio call with a phone number.</p>\n",
                "summary": "<p>Place an audio call with a phone number.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startPhoneCall = function (params) {\n        var promise;\n        var retVal;\n        var call = null;\n        var recipient = {};\n        params = params || {};\n        params.constraints = {\n            video: false,\n            audio: true,\n            mandatory: {},\n            optional: []\n        };\n\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            promise = Q.reject(e);\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n\n        if (params.caller === undefined) {\n            params.caller = true;\n        }\n\n        if (!params.number) {\n            log.error(\"Can't start a phone call without a number.\");\n            promise = Q.reject(new Error(\"Can't start a phone call without a number.\"));\n            retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n            return retVal;\n        }\n\n        recipient.id = params.number;\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = recipient;\n\n        params.toType = params.toType || 'did';\n        params.fromType = params.fromType || 'web';\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalAnswer = function (signalParams) {\n            signalParams.signalType = 'answer';\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.connectionId = signalParams.connectionId;\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalModify = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send modify.\", err.message, err.stack);\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send candidate.\", err.message, err.stack);\n            });\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = recipient;\n            signalParams.toType = params.toType;\n            signalParams.fromType = params.fromType;\n            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            log.debug(\"Sending debug report\", signalParams.report);\n            signalingChannel.sendReport(signalParams);\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        return call;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startPhoneCall",
                "string": "that.startPhoneCall()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.verifyConnected"
                },
                {
                    "type": "throws",
                    "types": [
                        "Error"
                    ],
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Assert that we are connected to the backend infrastructure.</p>\n",
                "summary": "<p>Assert that we are connected to the backend infrastructure.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.verifyConnected = function () {\n        if (!signalingChannel.isConnected()) {\n            throw new Error(\"Can't complete request when not connected. Please reconnect!\");\n        }\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "verifyConnected",
                "string": "that.verifyConnected()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.isConnected"
                },
                {
                    "type": "returns",
                    "string": "boolean"
                }
            ],
            "description": {
                "full": "<p>Check whether this client is connected to the Respoke API.</p>\n",
                "summary": "<p>Check whether this client is connected to the Respoke API.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.isConnected = function () {\n        return signalingChannel.isConnected();\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "isConnected",
                "string": "that.isConnected()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.join"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.id",
                    "description": "- The name of the group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.joinHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of\nthis method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Message handler for messages from this group only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group.onJoin"
                    ],
                    "name": "[params.onJoin]",
                    "description": "- Join event listener for endpoints who join this group only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group.onLeave"
                    ],
                    "name": "[params.onLeave]",
                    "description": "- Leave event listener for endpoints who leave\nthis group only."
                },
                {
                    "type": "returns",
                    "string": "{Promise<respoke.Group>|undefined} The instance of the respoke.Group which the client joined."
                },
                {
                    "type": "fires",
                    "string": "respoke.Client#join"
                }
            ],
            "description": {
                "full": "<p>Join a group and begin keeping track of it.</p>\n<p>You can leave the group by calling <code>group.leave()</code>;</p>\n<h5 id=\"joining-and-leaving-a-group\">Joining and leaving a group</h5>\n<pre><code> var group;\n\n client.join({\n     id: &quot;book-club&quot;,\n     onSuccess: function (evt) {\n         console.log(&#39;I joined&#39;, evt.group.id);\n         // &quot;I joined book-club&quot;\n         group = evt.group;\n         group.sendMessage({\n             message: &#39;sup&#39;\n         });\n     }\n });\n\n // . . .\n // Some time later, leave the group.\n // . . .\n group.leave({\n     onSuccess: function (evt) {\n         console.log(&#39;I left&#39;, evt.group.id);\n         // &quot;I left book-club&quot;\n     }\n });\n</code></pre>",
                "summary": "<p>Join a group and begin keeping track of it.</p>\n",
                "body": "<p>You can leave the group by calling <code>group.leave()</code>;</p>\n<h5 id=\"joining-and-leaving-a-group\">Joining and leaving a group</h5>\n<pre><code> var group;\n\n client.join({\n     id: &quot;book-club&quot;,\n     onSuccess: function (evt) {\n         console.log(&#39;I joined&#39;, evt.group.id);\n         // &quot;I joined book-club&quot;\n         group = evt.group;\n         group.sendMessage({\n             message: &#39;sup&#39;\n         });\n     }\n });\n\n // . . .\n // Some time later, leave the group.\n // . . .\n group.leave({\n     onSuccess: function (evt) {\n         console.log(&#39;I left&#39;, evt.group.id);\n         // &quot;I left book-club&quot;\n     }\n });\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [
                "respoke.Client#join"
            ],
            "ignore": false,
            "code": "that.join = function (params) {\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        try {\n            that.verifyConnected();\n        } catch (e) {\n            deferred.reject(e);\n            return retVal;\n        }\n\n        if (!params.id) {\n            deferred.reject(new Error(\"Can't join a group with no group id.\"));\n            return retVal;\n        }\n\n        signalingChannel.joinGroup({\n            id: params.id\n        }).done(function successHandler() {\n            var group;\n            params.signalingChannel = signalingChannel;\n            params.instanceId = instanceId;\n\n            group = that.getGroup({id: params.id});\n\n            if (!group) {\n                group = respoke.Group(params);\n                that.addGroup(group);\n            }\n\n            group.listen('join', params.onJoin);\n            group.listen('leave', params.onLeave);\n            group.listen('message', params.onMessage);\n\n            group.addMember({\n                connection: that.getConnection({\n                    endpointId: that.endpointId,\n                    connectionId: that.connectionId\n                })\n            });",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "join",
                "string": "that.join()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#join"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "group",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                }
            ],
            "description": {
                "full": "<p>This event is fired every time the client joins a group. If the client leaves\na group, this event will be fired again on the next time the client joins the group.</p>\n",
                "summary": "<p>This event is fired every time the client joins a group. If the client leaves\na group, this event will be fired again on the next time the client joins the group.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('join', {\n                group: group\n            });\n            deferred.resolve(group);\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return retVal;\n    };",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#join",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.addGroup"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Add a Group. This is called when we join a group and need to begin keeping track of it.</p>\n",
                "summary": "<p>Add a Group. This is called when we join a group and need to begin keeping track of it.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.addGroup = function (newGroup) {\n        if (!newGroup || newGroup.className !== 'respoke.Group') {\n            throw new Error(\"Can't add group to internal tracking without a group.\");\n        }\n\n        newGroup.listen('leave', function leaveHandler(evt) {\n            newGroup.removeMember({connectionId: evt.connection.id});\n            var endpt = evt.connection.getEndpoint();\n            if (!endpt.hasListeners('presence')) {\n                checkEndpointForRemoval(endpt);\n            }\n        }, true);\n\n        groups.push(newGroup);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "addGroup",
                "string": "that.addGroup()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.getGroups"
                },
                {
                    "type": "returns",
                    "string": "{Array<respoke.Group>} All of the groups the library is aware of."
                }
            ],
            "description": {
                "full": "<p>Get a list of all the groups the client is currently a member of.</p>\n",
                "summary": "<p>Get a list of all the groups the client is currently a member of.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getGroups = function () {\n        return groups;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getGroups",
                "string": "that.getGroups()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.getGroup"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.id",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group.onJoin"
                    ],
                    "name": "[params.onJoin]",
                    "description": "- Receive notification that an endpoint has joined this group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group.onLeave"
                    ],
                    "name": "[params.onLeave]",
                    "description": "- Receive notification that an endpoint has left this group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Receive notification that a message has been\nreceived to a group."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Group|undefined} The group whose ID was specified."
                }
            ],
            "description": {
                "full": "<p>Find a group by id and return it.</p>\n<pre><code>var group = client.getGroup({\n    id: &quot;resistance&quot;\n});\n</code></pre>",
                "summary": "<p>Find a group by id and return it.</p>\n",
                "body": "<pre><code>var group = client.getGroup({\n    id: &quot;resistance&quot;\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getGroup = function (params) {\n        var group;\n        if (!params || !params.id) {\n            throw new Error(\"Can't get a group without group id.\");\n        }\n\n        groups.every(function eachGroup(grp) {\n            if (grp.id === params.id) {\n                group = grp;\n                return false;\n            }\n            return true;\n        });\n\n        if (group) {\n            group.listen('join', params.onJoin);\n            group.listen('leave', params.onLeave);\n            group.listen('message', params.onMessage);\n        }\n\n        return group;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getGroup",
                "string": "that.getGroup()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "todo",
                    "string": "TODO Need to account for Endpoints not created as part of a group. These do not need to be\ndeleted based on group membership."
                },
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.checkEndpointForRemoval"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.id",
                    "description": "- The ID of the Endpoint to check for removal."
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Remove an Endpoint. Since an endpoint can be a member of multiple groups, we can&#39;t just remove it from\nour list on respoke.Endpoint#leave. We must see if it&#39;s a member of any more groups. If it&#39;s not\na member of any other groups, we can stop keeping track of it.</p>\n",
                "summary": "<p>Remove an Endpoint. Since an endpoint can be a member of multiple groups, we can&#39;t just remove it from\nour list on respoke.Endpoint#leave. We must see if it&#39;s a member of any more groups. If it&#39;s not\na member of any other groups, we can stop keeping track of it.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function checkEndpointForRemoval(params) {\n        params = params || {};\n        if (!params.id) {\n            throw new Error(\"Can't remove endpoint from internal tracking without group id.\");\n        }\n\n        Q.all(groups.map(function eachGroup(group) {\n            return group.getMembers();\n        })).done(function successHandler(connectionsByGroup) {\n            // connectionsByGroup is a two-dimensional array where the first dimension is a group\n            // and the second dimension is a connection.\n            var absent = connectionsByGroup.every(function eachConnectionList(connectionList) {\n                return connectionList.every(function eachConnection(conn) {\n                    return (conn.endpointId !== params.id);\n                });\n            });\n            if (absent) {\n                endpoints.every(function eachEndpoint(ept, index) {\n                    if (ept.id === params.id) {\n                        endpoints.splice(index, 1);\n                        return false;\n                    }\n                    return true;\n                });\n            }\n        });\n    }",
            "ctx": {
                "type": "function",
                "name": "checkEndpointForRemoval",
                "string": "checkEndpointForRemoval()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "ignore",
                    "string": "If the endpoint is not found in the local cache of endpoint objects (see `client.getEndpoints()`),\nit will be created. This is useful, for example, in the case of dynamic endpoints where groups are\nnot in use. Override dynamic endpoint creation by setting `params.skipCreate = true`.\n"
                },
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.getEndpoint"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.id",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Handle messages sent to the logged-in user\nfrom this one Endpoint."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint.onPresence"
                    ],
                    "name": "[params.onPresence]",
                    "description": "- Handle presence notifications from this one\nEndpoint."
                },
                {
                    "type": "arg",
                    "string": "{boolean} [params.skipCreate] - Skip the creation step and return undefined if we don't yet"
                },
                {
                    "type": "returns",
                    "string": "{respoke.Endpoint} The endpoint whose ID was specified."
                }
            ],
            "description": {
                "full": "<p>Find an endpoint by id and return the <code>respoke.Endpoint</code> object.</p>\n<p>If it is not already cached locally, will be added to the local cache of tracked endpoints,\nits presence will be determined, and will be available in <code>client.getEndpoints()</code>.</p>\n<pre><code>var endpoint = client.getEndpoint({\n    id: &quot;dlee&quot;\n});\n</code></pre>",
                "summary": "<p>Find an endpoint by id and return the <code>respoke.Endpoint</code> object.</p>\n",
                "body": "<p>If it is not already cached locally, will be added to the local cache of tracked endpoints,\nits presence will be determined, and will be available in <code>client.getEndpoints()</code>.</p>\n<pre><code>var endpoint = client.getEndpoint({\n    id: &quot;dlee&quot;\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getEndpoint = function (params) {\n        var endpoint;\n        if (!params || !params.id) {\n            throw new Error(\"Can't get an endpoint without endpoint id.\");\n        }\n\n        endpoints.every(function eachEndpoint(ept) {\n            if (ept.id === params.id) {\n                endpoint = ept;\n                return false;\n            }\n            return true;\n        });\n\n        if (!endpoint && params && !params.skipCreate) {\n            params.instanceId = instanceId;\n            params.signalingChannel = signalingChannel;\n            params.resolveEndpointPresence = clientSettings.resolveEndpointPresence;\n            params.addCall = addCall;\n\n            endpoint = respoke.Endpoint(params);\n            signalingChannel.registerPresence({\n                endpointList: [endpoint.id]\n            }).done(null, function (err) {\n                log.error(\"Couldn't register for presence on\", endpoint.id, err.message);\n            });\n            endpoints.push(endpoint);\n        }\n\n        if (endpoint) {\n            endpoint.listen('presence', params.onPresence);\n            endpoint.listen('message', params.onMessage);\n        }\n\n        return endpoint;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getEndpoint",
                "string": "that.getEndpoint()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "ignore",
                    "string": "In most cases, if we don't find it we will create it. This is useful\nin the case of dynamic endpoints where groups are not in use. Set skipCreate=true\nto return undefined if the Connection is not already known.\n"
                },
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.getConnection"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.connectionId",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.endpointId]",
                    "description": "- An endpointId to use in the creation of this connection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Handle messages sent to the logged-in user\nfrom this one Connection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint.onPresence"
                    ],
                    "name": "[params.onPresence]",
                    "description": "- Handle presence notifications from this one\nConnection."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Connection} The connection whose ID was specified."
                }
            ],
            "description": {
                "full": "<p>Find a Connection by id and return it.</p>\n<pre><code>var connection = client.getConnection({\n    id: &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX&quot;\n});\n</code></pre>",
                "summary": "<p>Find a Connection by id and return it.</p>\n",
                "body": "<pre><code>var connection = client.getConnection({\n    id: &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX&quot;\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getConnection = function (params) {\n        var connection;\n        var endpoint;\n        var endpointsToSearch = endpoints;\n\n        params = params || {};\n        if (!params.connectionId) {\n            throw new Error(\"Can't get a connection without connection id.\");\n        }\n        if (!params.endpointId && !params.skipCreate) {\n            throw new Error(\"Can't create a connection without endpoint id.\");\n        }\n\n        if (params.endpointId) {\n            endpoint = that.getEndpoint({\n                id: params.endpointId,\n                skipCreate: params.skipCreate\n            });\n\n            endpointsToSearch = [];\n            if (endpoint) {\n                endpointsToSearch = [endpoint];\n            }\n        }\n\n        endpointsToSearch.every(function eachEndpoint(ept) {\n            connection = ept.getConnection(params);\n            return !connection;\n        });\n\n        if (!connection && !params.skipCreate) {\n            params.instanceId = instanceId;\n            connection = respoke.Connection(params);\n            endpoint.connections.push(connection);\n        }\n\n        return connection;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getConnection",
                "string": "that.getConnection()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Client"
                },
                {
                    "type": "method",
                    "string": "respoke.Client.getEndpoints"
                },
                {
                    "type": "returns",
                    "string": "{Array<respoke.Endpoint>}"
                }
            ],
            "description": {
                "full": "<p>Get the list of <strong>all endpoints</strong> that the library has knowledge of.\nThese are <code>respoke.Endpoint</code> objects, not just the endpointIds.</p>\n<p>The library gains knowledge of an endpoint in two ways:</p>\n<ol>\n<li>when an endpoint joins a group that the user (currently logged-in endpoint) is a member of (if group presence is enabled)</li>\n<li>when an endpoint that the user (currently logged-in endpoint) is watching*</li>\n</ol>\n<p>*If an endpoint that the library does not know about sends a message to the client, you\ncan immediately call the <code>client.getEndpoint()</code> method on the sender of the message to enable\nwatching of the sender&#39;s endpoint.</p>\n<pre><code> client.on(&#39;message&#39;, function (data) {\n     if (data.endpoint) {\n         // start tracking this endpoint.\n         client.getEndpoint({ id: data.endpoint.id });\n     }\n });\n</code></pre>",
                "summary": "<p>Get the list of <strong>all endpoints</strong> that the library has knowledge of.\nThese are <code>respoke.Endpoint</code> objects, not just the endpointIds.</p>\n",
                "body": "<p>The library gains knowledge of an endpoint in two ways:</p>\n<ol>\n<li>when an endpoint joins a group that the user (currently logged-in endpoint) is a member of (if group presence is enabled)</li>\n<li>when an endpoint that the user (currently logged-in endpoint) is watching*</li>\n</ol>\n<p>*If an endpoint that the library does not know about sends a message to the client, you\ncan immediately call the <code>client.getEndpoint()</code> method on the sender of the message to enable\nwatching of the sender&#39;s endpoint.</p>\n<pre><code> client.on(&#39;message&#39;, function (data) {\n     if (data.endpoint) {\n         // start tracking this endpoint.\n         client.getEndpoint({ id: data.endpoint.id });\n     }\n });\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getEndpoints = function () {\n        return endpoints;\n    };\n\n    return that;\n}; // End respoke.Client",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getEndpoints",
                "string": "that.getEndpoints()",
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.successHandler"
                }
            ],
            "description": {
                "full": "<p>Handle sending successfully.</p>\n",
                "summary": "<p>Handle sending successfully.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.joinHandler"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "group",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Handle joining a group successfully. This callback is called only once when Client.join() is called.</p>\n",
                "summary": "<p>Handle joining a group successfully. This callback is called only once when Client.join() is called.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.onJoin"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "evt.group",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                }
            ],
            "description": {
                "full": "<p>Receive notification that the client has joined a group. This callback is called everytime\nrespoke.Client#join is fired.</p>\n",
                "summary": "<p>Receive notification that the client has joined a group. This callback is called everytime\nrespoke.Client#join is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.onLeave"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "evt.group",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                }
            ],
            "description": {
                "full": "<p>Receive notification that the client has left a group. This callback is called everytime\nrespoke.Client#leave is fired.</p>\n",
                "summary": "<p>Receive notification that the client has left a group. This callback is called everytime\nrespoke.Client#leave is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.onClientMessage"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.TextMessage"
                    ],
                    "name": "evt.message",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "[evt.group]",
                    "description": "- If the message is to a group we already know about,\nthis will be set. If null, the developer can use client.join({id: evt.message.header.channel}) to join\nthe group. From that point forward, Group#message will fire when a message is received as well. If\ngroup is undefined instead of null, the message is not a group message at all."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Receive notification that a message has been received. This callback is called every time\nrespoke.Client#message is fired.</p>\n",
                "summary": "<p>Receive notification that a message has been received. This callback is called every time\nrespoke.Client#message is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.onCall"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.call",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "evt.endpoint",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                }
            ],
            "description": {
                "full": "<p>Receive notification that the client is receiving a call from a remote party. This callback is called every\ntime respoke.Client#call is fired.</p>\n",
                "summary": "<p>Receive notification that the client is receiving a call from a remote party. This callback is called every\ntime respoke.Client#call is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.onDirectConnection"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "evt.directConnection",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "evt.endpoint",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Receive notification that the client is receiving a request for a direct connection from a remote party.\nThis callback is called every time respoke.Client#direct-connection is fired.</p>\n",
                "summary": "<p>Receive notification that the client is receiving a request for a direct connection from a remote party.\nThis callback is called every time respoke.Client#direct-connection is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.onConnect"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Receive notification Respoke has successfully connected to the cloud. This callback is called every time\nrespoke.Client#connect is fired.</p>\n",
                "summary": "<p>Receive notification Respoke has successfully connected to the cloud. This callback is called every time\nrespoke.Client#connect is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.onDisconnect"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Receive notification Respoke has successfully disconnected from the cloud. This callback is called every time\nrespoke.Client#disconnect is fired.</p>\n",
                "summary": "<p>Receive notification Respoke has successfully disconnected from the cloud. This callback is called every time\nrespoke.Client#disconnect is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.onReconnect"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Receive notification Respoke has successfully reconnected to the cloud. This callback is called every time\nrespoke.Client#reconnect is fired.</p>\n",
                "summary": "<p>Receive notification Respoke has successfully reconnected to the cloud. This callback is called every time\nrespoke.Client#reconnect is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.disconnectSuccessHandler"
                }
            ],
            "description": {
                "full": "<p>Handle disconnection to the cloud successfully.</p>\n",
                "summary": "<p>Handle disconnection to the cloud successfully.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.errorHandler"
                },
                {
                    "type": "params",
                    "string": "{Error} err"
                }
            ],
            "description": {
                "full": "<p>Handle an error that resulted from a method call.</p>\n",
                "summary": "<p>Handle an error that resulted from a method call.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.connectSuccessHandler"
                }
            ],
            "description": {
                "full": "<p>Handle connection to the cloud successfully.</p>\n",
                "summary": "<p>Handle connection to the cloud successfully.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/client.js",
                    "output": ".docs/site/respoke/client.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var respoke = require('./respoke');",
            "ctx": {
                "type": "declaration",
                "name": "respoke",
                "value": "require('./respoke')",
                "string": "respoke",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        }
    ],
    "respoke.Connection": [
        {
            "tags": [
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "class",
                    "string": "respoke.Connection"
                },
                {
                    "type": "augments",
                    "otherClass": "respoke.Presentable"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.id",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{respoke.Connection}"
                }
            ],
            "description": {
                "full": "<p>A <code>respoke.Connection</code> always belongs to an Endpoint.</p>\n<p>There is a distinction between Endpoint and Connection because an Endpoint can be authenticated\nfrom multiple devices, browsers, or browser tabs. Each of these separate authentications is a Connection.\nA Client can choose to interact with connections of the same endpoint in different ways.</p>\n",
                "summary": "<p>A <code>respoke.Connection</code> always belongs to an Endpoint.</p>\n",
                "body": "<p>There is a distinction between Endpoint and Connection because an Endpoint can be authenticated\nfrom multiple devices, browsers, or browser tabs. Each of these separate authentications is a Connection.\nA Client can choose to interact with connections of the same endpoint in different ways.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "module.exports = function (params) {\n    \"use strict\";\n    params = params || {};",
            "ctx": {
                "type": "method",
                "receiver": "module",
                "name": "respoke.Connection",
                "string": "module.exports()",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "instanceId"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Connection</p>\n",
                "summary": "<p>@memberof! respoke.Connection</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var instanceId = params.instanceId;\n    var that = respoke.Presentable(params);",
            "ctx": {
                "type": "declaration",
                "name": "instanceId",
                "value": "params.instanceId",
                "string": "instanceId",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "client"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Client"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.DirectConnection</p>\n",
                "summary": "<p>@memberof! respoke.DirectConnection</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var client = respoke.getClient(instanceId);",
            "ctx": {
                "type": "declaration",
                "name": "client",
                "value": "respoke.getClient(instanceId)",
                "string": "client",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Connection"
                },
                {
                    "type": "name",
                    "string": "id"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>The connection id.</p>\n",
                "summary": "<p>The connection id.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.id = that.id || that.connectionId;\n    if (!that.id) {\n        throw new Error(\"Can't make a connection without an id.\");\n    }\n    delete that.instanceId;\n    delete that.connectionId;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "id",
                "value": "that.id || that.connectionId",
                "string": "that.id",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Connection"
                },
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>A name to identify the type of this object.</p>\n",
                "summary": "<p>A name to identify the type of this object.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.Connection';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.Connection'",
                "string": "that.className",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Connection"
                },
                {
                    "type": "method",
                    "string": "respoke.Connection.sendMessage"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.message",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.successHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation\nof this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "returns",
                    "string": "{Promise|undefined}"
                }
            ],
            "description": {
                "full": "<p>Send a message to this connection of an endpoint. If the endpoint has multiple connections,\nit will only receive the message at this connection.</p>\n<pre><code>connection.sendMessage({\n    message: &quot;PJ, put that PBR down!&quot;\n});\n</code></pre><p><strong>Using callbacks</strong> will disable promises.</p>\n",
                "summary": "<p>Send a message to this connection of an endpoint. If the endpoint has multiple connections,\nit will only receive the message at this connection.</p>\n",
                "body": "<pre><code>connection.sendMessage({\n    message: &quot;PJ, put that PBR down!&quot;\n});\n</code></pre><p><strong>Using callbacks</strong> will disable promises.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.sendMessage = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        return that.getEndpoint().sendMessage(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "sendMessage",
                "string": "that.sendMessage()",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Connection"
                },
                {
                    "type": "method",
                    "string": "respoke.Connection.startCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the remote\naudio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for being notified when the call has been\nhung up."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback for receiving statistical\ninformation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "RTCConstraints"
                    ],
                    "name": "[params.constraints]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "[params.videoLocalElement]",
                    "description": "- Pass in an optional html video element to have local video attached to it."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "[params.videoRemoteElement]",
                    "description": "- Pass in an optional html video element to have remote video attached to it."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Create a new Call for a voice and/or video call this particular connection, only. The Call cannot be answered\nby another connection of this Endpoint.</p>\n<pre><code>connection.startCall({\n    onConnect: function (evt) {}\n});\n</code></pre>",
                "summary": "<p>Create a new Call for a voice and/or video call this particular connection, only. The Call cannot be answered\nby another connection of this Endpoint.</p>\n",
                "body": "<pre><code>connection.startCall({\n    onConnect: function (evt) {}\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startCall = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        return that.getEndpoint().startCall(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startCall",
                "string": "that.startCall()",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Connection"
                },
                {
                    "type": "method",
                    "string": "respoke.Connection.startAudioCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the remote\naudio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for being notified when the call has been\nhung up."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback for receiving statistical\ninformation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Create a new audio-only call.</p>\n<pre><code>connection.startAudioCall({\n    onConnect: function (evt) {}\n});\n</code></pre>",
                "summary": "<p>Create a new audio-only call.</p>\n",
                "body": "<pre><code>connection.startAudioCall({\n    onConnect: function (evt) {}\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startAudioCall = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        params.constraints = {\n            video : false,\n            audio : true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startAudioCall",
                "string": "that.startAudioCall()",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Connection"
                },
                {
                    "type": "method",
                    "string": "respoke.Connection.startVideoCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the remote\naudio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for being notified when the call has\nbeen hung up."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback for receiving statistical\ninformation."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Create a new call with audio and video.</p>\n<pre><code>connection.startVideoCall({\n    onConnect: function (evt) {}\n});\n</code></pre>",
                "summary": "<p>Create a new call with audio and video.</p>\n",
                "body": "<pre><code>connection.startVideoCall({\n    onConnect: function (evt) {}\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startVideoCall = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        return that.getEndpoint().startCall(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startVideoCall",
                "string": "that.startVideoCall()",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Connection"
                },
                {
                    "type": "method",
                    "string": "respoke.Connection.startDirectConnection"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.directConnectionSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this\ninvocation of this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onStart"
                    ],
                    "name": "[params.onStart]",
                    "description": "- A callback for when setup of the direct\nconnection begins. The direct connection will not be open yet."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onOpen"
                    ],
                    "name": "[params.onOpen]",
                    "description": "- A callback for receiving notification of when\nthe DirectConnection is open and ready to be used."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors setting up the direct\nconnection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onClose"
                    ],
                    "name": "[params.onClose]",
                    "description": "- A callback for receiving notification of\nwhen the DirectConnection is closed and the two Endpoints are disconnected."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- A callback for receiving messages sent\nthrough the DirectConnection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onAccept"
                    ],
                    "name": "[params.onAccept]",
                    "description": "- Callback for when the user accepts the\nrequest for a direct connection and setup begins."
                },
                {
                    "type": "returns",
                    "string": "{respoke.DirectConnection} The DirectConnection which can be used to send data and messages\ndirectly to the other endpoint."
                }
            ],
            "description": {
                "full": "<p>Create a new DirectConnection with this particular connection, only. The DirectConnection cannot be answered\nby another connection of this Endpoint.  This method creates a new Call as well, attaching this\nDirectConnection to it for the purposes of creating a peer-to-peer link for sending data such as messages to\nthe other endpoint. Information sent through a DirectConnection is not handled by the cloud infrastructure.</p>\n<pre><code>connection.startDirectConnection({\n    onOpen: function (evt) {}\n});\n</code></pre>",
                "summary": "<p>Create a new DirectConnection with this particular connection, only. The DirectConnection cannot be answered\nby another connection of this Endpoint.  This method creates a new Call as well, attaching this\nDirectConnection to it for the purposes of creating a peer-to-peer link for sending data such as messages to\nthe other endpoint. Information sent through a DirectConnection is not handled by the cloud infrastructure.</p>\n",
                "body": "<pre><code>connection.startDirectConnection({\n    onOpen: function (evt) {}\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startDirectConnection = function (params) {\n        params = params || {};\n        params.connectionId = that.id;\n        return that.getEndpoint().startDirectConnection(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startDirectConnection",
                "string": "that.startDirectConnection()",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Connection"
                },
                {
                    "type": "method",
                    "string": "respoke.Connection.getEndpoint"
                },
                {
                    "type": "returns",
                    "string": "{respoke.Endpoint}"
                }
            ],
            "description": {
                "full": "<p>Get the Endpoint that this Connection belongs to.</p>\n",
                "summary": "<p>Get the Endpoint that this Connection belongs to.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getEndpoint = function () {\n        return client.getEndpoint({id: that.endpointId});\n    };\n\n    return that;\n}; // End respoke.Connection",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getEndpoint",
                "string": "that.getEndpoint()",
                "file": {
                    "input": "respoke/connection.js",
                    "output": ".docs/site/respoke/connection.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var log = require('loglevel');\nvar Q = require('q');\nvar respoke = require('./respoke');",
            "ctx": {
                "type": "declaration",
                "name": "log",
                "value": "require('loglevel')",
                "string": "log",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        }
    ],
    "respoke.DirectConnection": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "augments",
                    "otherClass": "respoke.EventEmitter"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.instanceId",
                    "description": "- client id"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "params.call",
                    "description": "- The call that is handling state for this direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, force the data to flow through relay servers instead of allowing\nit to flow peer-to-peer. The relay acts like a blind proxy."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.connectionId",
                    "description": "- The connection ID of the remoteEndpoint."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalOffer",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalConnected",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalAnswer",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalHangup",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalReport",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.signalCandidate",
                    "description": "- Signaling action from SignalingChannel."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onStart"
                    ],
                    "name": "[params.onStart]",
                    "description": "- Callback for when setup of the direct connection\nbegins. The direct connection will not be open yet."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during\ndirect connection setup or media renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onClose"
                    ],
                    "name": "[params.onClose]",
                    "description": "- Callback for closing the direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onOpen"
                    ],
                    "name": "[params.onOpen]",
                    "description": "- Callback for opening the direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onAccept"
                    ],
                    "name": "[params.onAccept]",
                    "description": "- Callback for when the user accepts the request\nfor a direct connection and setup is about to begin."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Callback for incoming messages. Not usually\nnecessary to listen to this event if you are already listening to respoke.Endpoint#message."
                },
                {
                    "type": "returns",
                    "string": "{respoke.DirectConnection}"
                }
            ],
            "description": {
                "full": "<p>A direct connection via RTCDataChannel, including state and path negotation.</p>\n",
                "summary": "<p>A direct connection via RTCDataChannel, including state and path negotation.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "module.exports = function (params) {\n    \"use strict\";\n    params = params || {};",
            "ctx": {
                "type": "method",
                "receiver": "module",
                "name": "respoke.DirectConnection",
                "string": "module.exports()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "instanceId"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Client</p>\n",
                "summary": "<p>@memberof! respoke.Client</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;",
            "ctx": {
                "type": "declaration",
                "name": "instanceId",
                "value": "params.instanceId",
                "string": "instanceId",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>A name to identify this class</p>\n",
                "summary": "<p>A name to identify this class</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.DirectConnection';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.DirectConnection'",
                "string": "that.className",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "name",
                    "string": "id"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>The unique identifier of the direct connection.</p>\n",
                "summary": "<p>The unique identifier of the direct connection.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.id = respoke.makeGUID();",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "id",
                "value": "respoke.makeGUID()",
                "string": "that.id",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "call"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Call"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.DirectConnection</p>\n",
                "summary": "<p>@memberof! respoke.DirectConnection</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "if (!that.call.caller) {\n        that.call.caller = false;\n    }",
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "dataChannel"
                },
                {
                    "type": "type",
                    "types": [
                        "RTCDataChannel"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.DirectConnection</p>\n",
                "summary": "<p>@memberof! respoke.DirectConnection</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var dataChannel = null;",
            "ctx": {
                "type": "declaration",
                "name": "dataChannel",
                "value": "null",
                "string": "dataChannel",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "client"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Client"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.DirectConnection</p>\n",
                "summary": "<p>@memberof! respoke.DirectConnection</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var client = respoke.getClient(instanceId);",
            "ctx": {
                "type": "declaration",
                "name": "client",
                "value": "respoke.getClient(instanceId)",
                "string": "client",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "pc"
                },
                {
                    "type": "type",
                    "types": [
                        "RTCPeerConnection"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.DirectConnection</p>\n",
                "summary": "<p>@memberof! respoke.DirectConnection</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var pc = params.pc;\n    delete params.pc;",
            "ctx": {
                "type": "declaration",
                "name": "pc",
                "value": "params.pc",
                "string": "pc",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.listenDataChannel"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>When the datachannel is availble, we need to attach the callbacks. The event this function is attached to\nonly fires for the callee.</p>\n",
                "summary": "<p>When the datachannel is availble, we need to attach the callbacks. The event this function is attached to\nonly fires for the callee.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function listenDataChannel(evt) {\n        dataChannel = evt.channel;\n        dataChannel.onerror = onDataChannelError;\n        dataChannel.onmessage = onDataChannelMessage;\n        if (dataChannel.readyState === 'open') {\n            dataChannel.onopen = null;\n            onDataChannelOpen();\n        } else {\n            dataChannel.onopen = onDataChannelOpen;\n        }\n    }",
            "ctx": {
                "type": "function",
                "name": "listenDataChannel",
                "string": "listenDataChannel()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.saveParameters"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onClose"
                    ],
                    "name": "[params.onClose]",
                    "description": "- Callback for when the direct connection\nis closed."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onOpen"
                    ],
                    "name": "[params.onOpen]",
                    "description": "- Callback for when the direct connection\nis open."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Callback for incoming messages."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors setting up the direct\nconnection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onStart"
                    ],
                    "name": "[params.onStart]",
                    "description": "- Callback for when the direct connection\nis being set up. The direct connection will not be open yet."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, force the data to flow through relay servers instead of allowing\nit to flow peer-to-peer. The relay acts like a blind proxy."
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Register any event listeners passed in as callbacks</p>\n",
                "summary": "<p>Register any event listeners passed in as callbacks</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function saveParameters(params) {",
            "ctx": {
                "type": "function",
                "name": "saveParameters",
                "string": "saveParameters()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.DirectConnection#open"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>The direct connection is open.</p>\n",
                "summary": "<p>The direct connection is open.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('open', params.onOpen);",
            "ctx": {
                "type": "event",
                "name": "respoke.DirectConnection#open",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.DirectConnection#close"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>The direct connection is closed.</p>\n",
                "summary": "<p>The direct connection is closed.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('close', params.onClose);",
            "ctx": {
                "type": "event",
                "name": "respoke.DirectConnection#close",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.DirectConnection#message"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.TextMessage"
                    ],
                    "name": "message",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "endpoint",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Incoming message on this direct connection.</p>\n",
                "summary": "<p>Incoming message on this direct connection.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('message', params.onMessage);\n        // documented elsewhere\n        that.listen('start', params.onStart);",
            "ctx": {
                "type": "event",
                "name": "respoke.DirectConnection#message",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.DirectConnection#error"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "reason",
                    "description": "- A human-readable description of the error."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>An error occurred while setting up the direct connection.</p>\n",
                "summary": "<p>An error occurred while setting up the direct connection.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('error', params.onError);\n        pc.listen('direct-connection', listenDataChannel, true);\n        pc.listen('stats', function fireStats(evt) {",
            "ctx": {
                "type": "event",
                "name": "respoke.DirectConnection#error",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.DirectConnection#stats"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "object"
                    ],
                    "name": "stats",
                    "description": "- an object with stats in it."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                }
            ],
            "description": {
                "full": "<p>This event is fired every time statistical information about the direct connection\nbecomes available.</p>\n",
                "summary": "<p>This event is fired every time statistical information about the direct connection\nbecomes available.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('stats', {stats: evt.stats});\n        }, true);\n\n    }\n    saveParameters(params);\n\n    delete that.onOpen;\n    delete that.onClose;\n    delete that.onMessage;",
            "ctx": {
                "type": "event",
                "name": "respoke.DirectConnection#stats",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.getStats"
                },
                {
                    "type": "returns",
                    "string": "{Promise<object>|undefined}"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "number"
                    ],
                    "name": "[params.interval=5000]",
                    "description": "- How often in milliseconds to fetch statistics."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- An optional callback to receive the\nstats if the Respoke stats module is loaded. If no callback is provided, the connection's report will\ncontain stats but the developer will not receive them on the client-side."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.statsSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this\ninvocation of this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of\nthis method only."
                }
            ],
            "description": {
                "full": "<p>Return media stats. Since we have to wait for both the answer and offer to be available before starting\nstatistics, we&#39;ll return a promise for the stats object.</p>\n<pre><code>directConnection.getStats({\n    onStats: function (evt) {\n        console.log(&#39;Stats&#39;, evt.stats);\n    }\n}).done(function () {\n    console.log(&#39;Stats started.&#39;);\n}, function (err) {\n    console.log(&#39;Direct connection is already closed.&#39;);\n});\n</code></pre><p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n",
                "summary": "<p>Return media stats. Since we have to wait for both the answer and offer to be available before starting\nstatistics, we&#39;ll return a promise for the stats object.</p>\n",
                "body": "<pre><code>directConnection.getStats({\n    onStats: function (evt) {\n        console.log(&#39;Stats&#39;, evt.stats);\n    }\n}).done(function () {\n    console.log(&#39;Stats started.&#39;);\n}, function (err) {\n    console.log(&#39;Direct connection is already closed.&#39;);\n});\n</code></pre><p><strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getStats = function (params) {\n        if (pc && pc.getStats) {\n            that.listen('stats', params.onStats);\n            delete params.onStats;\n            return pc.getStats(params);\n        }\n        return null;\n    };\n\n    if (!respoke.MediaStats) {\n        delete that.getStats;\n    }",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getStats",
                "string": "that.getStats()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.onDataChannelError"
                }
            ],
            "description": {
                "full": "<p>Detect datachannel errors for internal state.</p>\n",
                "summary": "<p>Detect datachannel errors for internal state.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function onDataChannelError(error) {",
            "ctx": {
                "type": "function",
                "name": "onDataChannelError",
                "string": "onDataChannelError()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "object"
                    ],
                    "name": "error",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "directConnection",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.DirectConnection#error</p>\n",
                "summary": "<p>@event respoke.DirectConnection#error</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('error', {\n            error: error\n        });\n        that.close();\n    }",
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.onDataChannelMessage"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "MessageEvent"
                    ],
                    "name": "",
                    "description": ""
                },
                {
                    "type": "fires",
                    "string": "respoke.DirectConnection#message"
                }
            ],
            "description": {
                "full": "<p>Receive and route messages to the Endpoint.</p>\n",
                "summary": "<p>Receive and route messages to the Endpoint.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.DirectConnection#message"
            ],
            "ignore": false,
            "code": "function onDataChannelMessage(evt) {\n        var message;\n        try {\n            message = JSON.parse(evt.data);\n        } catch (e) {\n            message = evt.data;\n        }",
            "ctx": {
                "type": "function",
                "name": "onDataChannelMessage",
                "string": "onDataChannelMessage()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "object"
                    ],
                    "name": "message",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "directConnection",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Call"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.Endpoint#message</p>\n",
                "summary": "<p>@event respoke.Endpoint#message</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.call.remoteEndpoint.fire('message', {\n            message: message,\n            directConnection: that\n        });",
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "object"
                    ],
                    "name": "message",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "endpoint",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.DirectConnection#message</p>\n",
                "summary": "<p>@event respoke.DirectConnection#message</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('message', {\n            message: message,\n            endpoint: that.call.remoteEndpoint\n        });\n    }",
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.onDataChannelOpen"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "MessageEvent"
                    ],
                    "name": "",
                    "description": ""
                },
                {
                    "type": "fires",
                    "string": "respoke.DirectConnection#open"
                }
            ],
            "description": {
                "full": "<p>Detect when the channel is open.</p>\n",
                "summary": "<p>Detect when the channel is open.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.DirectConnection#open"
            ],
            "ignore": false,
            "code": "function onDataChannelOpen(evt) {\n        //dataChannel = evt.target || evt.channel;",
            "ctx": {
                "type": "function",
                "name": "onDataChannelOpen",
                "string": "onDataChannelOpen()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.DirectConnection#open</p>\n",
                "summary": "<p>@event respoke.DirectConnection#open</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('open');\n    }",
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.onDataChannelClose"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "MessageEvent"
                    ],
                    "name": "",
                    "description": ""
                },
                {
                    "type": "fires",
                    "string": "respoke.DirectConnection#close"
                }
            ],
            "description": {
                "full": "<p>Detect when the channel is closed.</p>\n",
                "summary": "<p>Detect when the channel is closed.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.DirectConnection#close"
            ],
            "ignore": false,
            "code": "function onDataChannelClose(evt) {\n        //dataChannel = evt.target || evt.channel;",
            "ctx": {
                "type": "function",
                "name": "onDataChannelClose",
                "string": "onDataChannelClose()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.DirectConnection#close</p>\n",
                "summary": "<p>@event respoke.DirectConnection#close</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('close');\n    }",
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.createDataChannel"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Create the datachannel. For the caller, set up all the handlers we&#39;ll need to keep track of the\ndatachannel&#39;s state and to receive messages.</p>\n",
                "summary": "<p>Create the datachannel. For the caller, set up all the handlers we&#39;ll need to keep track of the\ndatachannel&#39;s state and to receive messages.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function createDataChannel() {\n        dataChannel = pc.createDataChannel(\"respokeDataChannel\");\n        dataChannel.binaryType = 'arraybuffer';\n        dataChannel.onerror = onDataChannelError;\n        dataChannel.onmessage = onDataChannelMessage;\n        dataChannel.onopen = onDataChannelOpen;",
            "ctx": {
                "type": "function",
                "name": "createDataChannel",
                "string": "createDataChannel()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.DirectConnection#start"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>The direct connection setup has begun. This does NOT mean it&#39;s ready to send messages yet. Listen to\nDirectConnection#open for that notification.</p>\n",
                "summary": "<p>The direct connection setup has begun. This does NOT mean it&#39;s ready to send messages yet. Listen to\nDirectConnection#open for that notification.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('start');\n    }",
            "ctx": {
                "type": "event",
                "name": "respoke.DirectConnection#start",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.accept"
                },
                {
                    "type": "fires",
                    "string": "respoke.DirectConnection#accept"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onOpen"
                    ],
                    "name": "[params.onOpen]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onClose"
                    ],
                    "name": "[params.onClose]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Start the process of obtaining media. saveParameters will only be meaningful for the callee,\nsince the library calls this method for the caller. Developers will use this method to pass in\ncallbacks for the callee.</p>\n<pre><code>directConnection.accept({\n    onOpen: function (evt) {}\n});\n</code></pre>",
                "summary": "<p>Start the process of obtaining media. saveParameters will only be meaningful for the callee,\nsince the library calls this method for the caller. Developers will use this method to pass in\ncallbacks for the callee.</p>\n",
                "body": "<pre><code>directConnection.accept({\n    onOpen: function (evt) {}\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [
                "respoke.DirectConnection#accept"
            ],
            "ignore": false,
            "code": "that.accept = function (params) {\n        params = params || {};\n        log.debug('DirectConnection.accept');\n        saveParameters(params);\n\n        log.debug(\"I am \" + (pc.state.caller ? '' : 'not ') + \"the caller.\");\n\n        if (pc.state.caller === true) {\n            createDataChannel();\n        }\n        that.call.answer();",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "accept",
                "string": "that.accept()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.DirectConnection#accept</p>\n",
                "summary": "<p>@event respoke.DirectConnection#accept</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('accept');\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.close"
                },
                {
                    "type": "fires",
                    "string": "respoke.DirectConnection#close"
                }
            ],
            "description": {
                "full": "<p>Tear down the connection.</p>\n",
                "summary": "<p>Tear down the connection.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.DirectConnection#close"
            ],
            "ignore": false,
            "code": "that.close = function (params) {\n        params = params || {};\n        log.debug(\"DirectConnection.close\");\n        if (dataChannel) {\n            dataChannel.close();\n        }",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "close",
                "string": "that.close()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.DirectConnection#close</p>\n",
                "summary": "<p>@event respoke.DirectConnection#close</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('close');\n\n        that.ignore();\n\n        if (params.skipRemove !== true) {\n            that.call.removeDirectConnection();\n        }\n\n        dataChannel = null;\n        that.call.remoteEndpoint.directConnection = null;\n        that.call = null;\n        pc = null;\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.sendMessage"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.message]",
                    "description": "- The message to send."
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params.object]",
                    "description": "- An object to send."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.sendHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation\nof this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation\nof this method only."
                },
                {
                    "type": "returns",
                    "string": "{Promise|undefined}"
                }
            ],
            "description": {
                "full": "<p>Send a message over the datachannel in the form of a JSON-encoded plain old JavaScript object. Only one\nattribute may be given: either a string &#39;message&#39; or an object &#39;object&#39;.\n<strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n<pre><code>directConnection.sendMessage({\n    message: &quot;And they say HTTP is stateless!&quot;\n});\n</code></pre>",
                "summary": "<p>Send a message over the datachannel in the form of a JSON-encoded plain old JavaScript object. Only one\nattribute may be given: either a string &#39;message&#39; or an object &#39;object&#39;.\n<strong>Using callbacks</strong> by passing <code>params.onSuccess</code> or <code>params.onError</code> will disable promises.</p>\n",
                "body": "<pre><code>directConnection.sendMessage({\n    message: &quot;And they say HTTP is stateless!&quot;\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.sendMessage = function (params) {\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        if (that.isActive()) {\n            dataChannel.send(JSON.stringify(params.object || {\n                message: params.message\n            }));\n            deferred.resolve();\n        } else {\n            deferred.reject(new Error(\"dataChannel not in an open state.\"));\n        }\n        return retVal;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "sendMessage",
                "string": "that.sendMessage()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.reject"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "signal",
                    "description": "- Optional flag to indicate whether to send or suppress sending\na hangup signal to the remote side."
                }
            ],
            "description": {
                "full": "<p>Expose close as reject for approve/reject workflow.</p>\n<pre><code>client.listen(&#39;direct-connection, function (evt) {\n    if (iDontLikeThisPerson()) {\n        evt.directConnection.reject();\n    }\n});\n</code></pre>",
                "summary": "<p>Expose close as reject for approve/reject workflow.</p>\n",
                "body": "<pre><code>client.listen(&#39;direct-connection, function (evt) {\n    if (iDontLikeThisPerson()) {\n        evt.directConnection.reject();\n    }\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.reject = that.close;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "reject",
                "value": "that.close",
                "string": "that.reject",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.DirectConnection"
                },
                {
                    "type": "method",
                    "string": "respoke.DirectConnection.isActive"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Indicate whether a datachannel is being setup or is in progress.</p>\n",
                "summary": "<p>Indicate whether a datachannel is being setup or is in progress.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.isActive = function () {\n        // Why does pc.iceConnectionState not transition into 'connected' even though media is flowing?\n        //return (pc && pc.isActive() && dataChannel && dataChannel.readyState === 'open');\n        return (dataChannel && dataChannel.readyState === 'open');\n    };\n\n    return that;\n}; // End respoke.DirectConnection",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "isActive",
                "string": "that.isActive()",
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.DirectConnection.onClose"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Called when the direct connection is closed.  This callback is called every time respoke.DirectConnection#close\nfires.</p>\n",
                "summary": "<p>Called when the direct connection is closed.  This callback is called every time respoke.DirectConnection#close\nfires.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.DirectConnection.onStart"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Called when the setup of the direct connection has begun. The direct connection will not be open yet. This\ncallback is called every time respoke.DirectConnection#start fires.</p>\n",
                "summary": "<p>Called when the setup of the direct connection has begun. The direct connection will not be open yet. This\ncallback is called every time respoke.DirectConnection#start fires.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.DirectConnection.onOpen"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Called when the direct connection is opened.  This callback is called every time respoke.DirectConnection#open\nfires.</p>\n",
                "summary": "<p>Called when the direct connection is opened.  This callback is called every time respoke.DirectConnection#open\nfires.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.DirectConnection.onMessage"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "evt.message",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "evt.endpoint",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Called when a message is received over the direct connection.  This callback is called every time\nrespoke.DirectConnection#message fires.</p>\n",
                "summary": "<p>Called when a message is received over the direct connection.  This callback is called every time\nrespoke.DirectConnection#message fires.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.DirectConnection.errorHandler"
                },
                {
                    "type": "param",
                    "types": [
                        "Error"
                    ],
                    "name": "err",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Handle an error that resulted from a specific method call. This handler will not fire more than once.</p>\n",
                "summary": "<p>Handle an error that resulted from a specific method call. This handler will not fire more than once.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.DirectConnection.onError"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "evt.reason",
                    "description": "- A human-readable description of the error."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>When a call is in setup or media renegotiation happens. This callback will be called every time\nrespoke.DirectConnection#error.</p>\n",
                "summary": "<p>When a call is in setup or media renegotiation happens. This callback will be called every time\nrespoke.DirectConnection#error.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.DirectConnection.onAccept"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Called when the callee accepts the direct connection. This callback is called every time\nrespoke.DirectConnection#accept is fired.</p>\n",
                "summary": "<p>Called when the callee accepts the direct connection. This callback is called every time\nrespoke.DirectConnection#accept is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.DirectConnection.statsSuccessHandler"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "evt.stats",
                    "description": "- an object with stats in it."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection"
                    ],
                    "name": "evt.target",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                }
            ],
            "description": {
                "full": "<p>Handle the successful kick-off of stats on a call.</p>\n",
                "summary": "<p>Handle the successful kick-off of stats on a call.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.DirectConnection.sendHandler"
                }
            ],
            "description": {
                "full": "<p>Handle sending successfully.</p>\n",
                "summary": "<p>Handle sending successfully.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/directConnection.js",
                    "output": ".docs/site/respoke/directConnection.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var log = require('loglevel');\nvar Q = require('q');\nvar respoke = require('./respoke');",
            "ctx": {
                "type": "declaration",
                "name": "log",
                "value": "require('loglevel')",
                "string": "log",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        }
    ],
    "respoke.Endpoint": [
        {
            "tags": [
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "class",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "augments",
                    "otherClass": "respoke.Presentable"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.id",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.instanceId",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.client.resolvePresence"
                    ],
                    "name": "[params.resolvePresence]",
                    "description": "An optional function for resolving presence for an endpoint."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Endpoint}"
                }
            ],
            "description": {
                "full": "<p><code>respoke.Endpoint</code>s are users of a Respoke app.</p>\n<p>An Endpoint can be a person in a browser or device, or an app using Respoke APIs from a server.</p>\n<p>A Client can interact with endpoints through messages, audio or video calls, or direct connections.</p>\n<p>An Endpoint may be authenticated from multiple devices to the same app (each of\nwhich is represented by a Connection).</p>\n",
                "summary": "<p><code>respoke.Endpoint</code>s are users of a Respoke app.</p>\n",
                "body": "<p>An Endpoint can be a person in a browser or device, or an app using Respoke APIs from a server.</p>\n<p>A Client can interact with endpoints through messages, audio or video calls, or direct connections.</p>\n<p>An Endpoint may be authenticated from multiple devices to the same app (each of\nwhich is represented by a Connection).</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "module.exports = function (params) {\n    \"use strict\";\n    params = params || {};",
            "ctx": {
                "type": "method",
                "receiver": "module",
                "name": "respoke.Endpoint",
                "string": "module.exports()",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "instanceId"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Endpoint</p>\n",
                "summary": "<p>@memberof! respoke.Endpoint</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var instanceId = params.instanceId;\n    var that = respoke.Presentable(params);",
            "ctx": {
                "type": "declaration",
                "name": "instanceId",
                "value": "params.instanceId",
                "string": "instanceId",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "client"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Client"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.DirectConnection</p>\n",
                "summary": "<p>@memberof! respoke.DirectConnection</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var client = respoke.getClient(instanceId);",
            "ctx": {
                "type": "declaration",
                "name": "client",
                "value": "respoke.getClient(instanceId)",
                "string": "client",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "signalingChannel"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.SignalingChannel"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.DirectConnection</p>\n",
                "summary": "<p>@memberof! respoke.DirectConnection</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var signalingChannel = params.signalingChannel;\n\n    var addCall = params.addCall;\n\n    delete that.signalingChannel;\n    delete that.instanceId;\n    delete that.connectionId;\n    delete that.addCall;",
            "ctx": {
                "type": "declaration",
                "name": "signalingChannel",
                "value": "params.signalingChannel",
                "string": "signalingChannel",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>A name to identify the type of this object.</p>\n",
                "summary": "<p>A name to identify the type of this object.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.Endpoint';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.Endpoint'",
                "string": "that.className",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "name",
                    "string": "directConnection"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.DirectConnection"
                    ]
                }
            ],
            "description": {
                "full": "<p>A direct connection to this endpoint. This can be used to send direct messages.</p>\n",
                "summary": "<p>A direct connection to this endpoint. This can be used to send direct messages.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.directConnection = null;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "directConnection",
                "value": "null",
                "string": "that.directConnection",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "name",
                    "string": "connections"
                },
                {
                    "type": "type",
                    "types": [
                        "Array<respoke.Connection>"
                    ]
                }
            ],
            "description": {
                "full": "<p>Array of connections for this endpoint.</p>\n",
                "summary": "<p>Array of connections for this endpoint.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.connections = [];\n    client.listen('disconnect', function disconnectHandler() {\n        that.connections = [];\n    });\n\n\n    var resolveEndpointPresence = params.resolveEndpointPresence;\n    delete that.resolveEndpointPresence;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "connections",
                "value": "[]",
                "string": "that.connections",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "method",
                    "string": "respoke.Endpoint.sendMessage"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.message",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.successHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of this\nmethod only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this method\nonly."
                },
                {
                    "type": "returns",
                    "string": "{Promise|undefined}"
                }
            ],
            "description": {
                "full": "<p>Send a message to the endpoint through the infrastructure.</p>\n<p>   endpoint.sendMessage({\n       message: &quot;wassuuuuup&quot;\n   });</p>\n<p><strong>Using callbacks</strong> will disable promises.</p>\n",
                "summary": "<p>Send a message to the endpoint through the infrastructure.</p>\n",
                "body": "<p>   endpoint.sendMessage({\n       message: &quot;wassuuuuup&quot;\n   });</p>\n<p><strong>Using callbacks</strong> will disable promises.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.sendMessage = function (params) {\n        var promise;\n        var retVal;\n        params = params || {};\n\n        promise = signalingChannel.sendMessage({\n            connectionId: params.connectionId,\n            message: params.message,\n            recipient: that\n        });\n\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        return retVal;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "sendMessage",
                "string": "that.sendMessage()",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "method",
                    "string": "respoke.Endpoint.startAudioCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the remote\naudio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for being notified when the call has been\nhung up."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback for receiving statistical\ninformation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": "- The connection ID of the remoteEndpoint, if it is not desired to call\nall connections belonging to this endpoint."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Create a new audio-only call.</p>\n<pre><code>endpoint.startAudioCall({\n    onConnect: function (evt) {}\n});\n</code></pre>",
                "summary": "<p>Create a new audio-only call.</p>\n",
                "body": "<pre><code>endpoint.startAudioCall({\n    onConnect: function (evt) {}\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startAudioCall = function (params) {\n        params = params || {};\n        params.constraints = {\n            video : false,\n            audio : true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startAudioCall",
                "string": "that.startAudioCall()",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "method",
                    "string": "respoke.Endpoint.startVideoCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the remote\naudio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for being notified when the call has been\nhung up."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback for receiving statistical\ninformation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": "- The connection ID of the remoteEndpoint, if it is not desired to call\nall connections belonging to this endpoint."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Create a new call with audio and video.</p>\n<pre><code>endpoint.startVideoCall({\n    onConnect: function (evt) {}\n});\n</code></pre>",
                "summary": "<p>Create a new call with audio and video.</p>\n",
                "body": "<pre><code>endpoint.startVideoCall({\n    onConnect: function (evt) {}\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startVideoCall = function (params) {\n        params = params || {};\n        params.constraints = {\n            video : true,\n            audio : true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startVideoCall",
                "string": "that.startVideoCall()",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "method",
                    "string": "respoke.Endpoint.startCall"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onLocalMedia"
                    ],
                    "name": "[params.onLocalMedia]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onConnect"
                    ],
                    "name": "[params.onConnect]",
                    "description": "- Callback for receiving an HTML5 Video\nelement with the remote\naudio and/or video attached."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onHangup"
                    ],
                    "name": "[params.onHangup]",
                    "description": "- Callback for being notified when the call has been\nhung up."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAllow"
                    ],
                    "name": "[params.onAllow]",
                    "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onMute"
                    ],
                    "name": "[params.onMute]",
                    "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onAnswer"
                    ],
                    "name": "[params.onAnswer]",
                    "description": "- Callback for when the callee answers the call."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onApprove"
                    ],
                    "name": "[params.onApprove]",
                    "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.onRequestingMedia"
                    ],
                    "name": "[params.onRequestingMedia]",
                    "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback for receiving statistical\ninformation."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.previewLocalMedia"
                    ],
                    "name": "[params.previewLocalMedia]",
                    "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
                },
                {
                    "type": "param",
                    "types": [
                        "RTCConstraints"
                    ],
                    "name": "[params.constraints]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.receiveOnly]",
                    "description": "- whether or not we accept media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.sendOnly]",
                    "description": "- whether or not we send media"
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.needDirectConnection]",
                    "description": "- flag to enable skipping media & opening direct connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.forceTurn]",
                    "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.disableTurn]",
                    "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": "- The connection ID of the remoteEndpoint, if it is not desired to call\nall connections belonging to this endpoint."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "[params.videoLocalElement]",
                    "description": "- Pass in an optional html video element to have local video attached to it."
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "[params.videoRemoteElement]",
                    "description": "- Pass in an optional html video element to have remote video attached to it."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Call}"
                }
            ],
            "description": {
                "full": "<p>Create a new call.</p>\n<pre><code>endpoint.startCall({\n    onConnect: function (evt) {}\n});\n</code></pre>",
                "summary": "<p>Create a new call.</p>\n",
                "body": "<pre><code>endpoint.startCall({\n    onConnect: function (evt) {}\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startCall = function (params) {\n        var call = null;\n        params = params || {};\n\n        log.debug('Endpoint.call');\n        client.verifyConnected();\n        if (params.caller === undefined) {\n            params.caller = true;\n        }\n\n        if (!that.id) {\n            log.error(\"Can't start a call without endpoint ID!\");\n            return;\n        }\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = that;\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalAnswer = function (signalParams) {\n            signalParams.signalType = 'answer';\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.connectionId = signalParams.call.connectionId;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalParams.recipient = that;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalModify = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send modify.\", err.message, err.stack);\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n                log.warn(\"Couldn't send candidate.\", err.message, err.stack);\n            });\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            log.debug(\"Sending debug report\", signalParams.report);\n            signalingChannel.sendReport(signalParams).done(null, function errorHandler(err) {\n                log.warn(\"Couldn't debug report.\", err.message, err.stack);\n            });\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        return call;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startCall",
                "string": "that.startCall()",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "method",
                    "string": "respoke.Endpoint.startDirectConnection"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Call.directConnectionSuccessHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this\ninvocation of this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onStart"
                    ],
                    "name": "[params.onStart]",
                    "description": "- A callback for when setup of the direct\nconnection begins. The direct connection will not be open yet."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onOpen"
                    ],
                    "name": "[params.onOpen]",
                    "description": "- A callback for receiving notification of when\nthe DirectConnection is open and ready to be used."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onError"
                    ],
                    "name": "[params.onError]",
                    "description": "- Callback for errors setting up the direct\nconnection."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onClose"
                    ],
                    "name": "[params.onClose]",
                    "description": "- A callback for receiving notification of\nwhen the DirectConnection is closed and the two Endpoints are disconnected."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onAccept"
                    ],
                    "name": "[params.onAccept]",
                    "description": "- Callback for when the user accepts the\nrequest for a direct connection and setup begins."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.DirectConnection.onMessage"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- A callback for receiving messages sent\nthrough the DirectConnection."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": "- An optional connection ID to use for this connection. This allows\nthe connection to be made to a specific instance of an endpoint in the case that the same endpoint is logged\nin from multiple locations."
                },
                {
                    "type": "returns",
                    "string": "{respoke.DirectConnection} The DirectConnection which can be used to send data and messages\ndirectly to the other endpoint."
                }
            ],
            "description": {
                "full": "<p>Create a new DirectConnection.  This method creates a new Call as well, attaching this DirectConnection to\nit for the purposes of creating a peer-to-peer link for sending data such as messages to the other endpoint.\nInformation sent through a DirectConnection is not handled by the cloud infrastructure.  If there is already\na direct connection open, this method will resolve the promise with that direct connection instead of\nattempting to create a new one.</p>\n<pre><code>endpoint.startDirectConnection({\n    onOpen: function (evt) {}\n});\n</code></pre>",
                "summary": "<p>Create a new DirectConnection.  This method creates a new Call as well, attaching this DirectConnection to\nit for the purposes of creating a peer-to-peer link for sending data such as messages to the other endpoint.\nInformation sent through a DirectConnection is not handled by the cloud infrastructure.  If there is already\na direct connection open, this method will resolve the promise with that direct connection instead of\nattempting to create a new one.</p>\n",
                "body": "<pre><code>endpoint.startDirectConnection({\n    onOpen: function (evt) {}\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.startDirectConnection = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        var call;\n\n        try {\n            client.verifyConnected();\n        } catch (err) {\n            deferred.reject(err);\n            return retVal;\n        }\n\n        if (that.directConnection || params.create === false) {\n            deferred.resolve(that.directConnection);\n            return retVal;\n        }\n\n        log.debug('Endpoint.startDirectConnection', params);\n        if (params.caller === undefined) {\n            params.caller = true;\n        }\n\n        if (!that.id) {\n            deferred.reject(new Error(\"Can't start a direct connection without endpoint ID!\"));\n            return retVal;\n        }\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = that;\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalAnswer = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalParams.signalType = 'answer';\n            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send candidate.\", err.message, err.stack);\n            });\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            signalParams.report.target = 'directConnection';\n            log.debug(\"Not sending report\");\n            log.debug(signalParams.report);\n        };\n        params.needDirectConnection = true;\n        // Don't include audio in the offer SDP\n        params.offerOptions = {\n            mandatory: {\n                OfferToReceiveAudio: false\n            }\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        call.listen('direct-connection', function directConnectionHandler(evt) {\n            that.directConnection = evt.directConnection;\n            if (params.caller !== true) {\n                if (!client.hasListeners('direct-connection') &&\n                        !client.hasListeners('direct-connection') &&\n                        !call.hasListeners('direct-connection')) {\n                    that.directConnection.reject();\n                    deferred.reject(new Error(\"Got an incoming direct connection with no handlers to accept it!\"));\n                    return;\n                }\n\n                deferred.resolve(that.directConnection);\n                that.directConnection.listen('close', function closeHandler(evt) {\n                    that.directConnection = undefined;\n                }, true);\n            }\n        }, true);\n\n        return retVal;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "startDirectConnection",
                "string": "that.startDirectConnection()",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "method",
                    "string": "respoke.Endpoint.resolvePresence"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Find the presence out of all known connections with the highest priority (most availability)\nand set it as the endpoint&#39;s resolved presence.</p>\n",
                "summary": "<p>Find the presence out of all known connections with the highest priority (most availability)\nand set it as the endpoint&#39;s resolved presence.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.resolvePresence = function () {\n\n        var presenceList = that.connections.map(function (connection) {\n            return connection.presence;\n        });\n\n        if (resolveEndpointPresence !== undefined) {\n            that.presence = resolveEndpointPresence(presenceList);\n        } else {\n            var options = ['chat', 'available', 'away', 'dnd', 'xa', 'unavailable'];\n            var idList;",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "resolvePresence",
                "string": "that.resolvePresence()",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Sort the connections array by the priority of the value of the presence of that\nconnectionId. This will cause the first element in the list to be the id of the\nsession with the highest priority presence so we can access it by the 0 index.\nTODO: If we don&#39;t really care about the sorting and only about the highest priority\nwe could use Array.prototype.every to improve this algorithm.</p>\n",
                "summary": "<p>Sort the connections array by the priority of the value of the presence of that\nconnectionId. This will cause the first element in the list to be the id of the\nsession with the highest priority presence so we can access it by the 0 index.\nTODO: If we don&#39;t really care about the sorting and only about the highest priority\nwe could use Array.prototype.every to improve this algorithm.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "idList = that.connections.sort(function sorter(a, b) {\n                var indexA = options.indexOf(a.presence);\n                var indexB = options.indexOf(b.presence);\n                // Move it to the end of the list if it isn't one of our accepted presence values\n                indexA = indexA === -1 ? 1000 : indexA;\n                indexB = indexB === -1 ? 1000 : indexB;\n                return indexA < indexB ? -1 : (indexB < indexA ? 1 : 0);\n            });\n\n            if (idList[0]) {\n                that.presence = idList[0].presence;\n            } else {\n                that.presence = 'unavailable';\n            }\n        }\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Endpoint"
                },
                {
                    "type": "method",
                    "string": "respoke.Endpoint.getConnection"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": ""
                },
                {
                    "type": "return",
                    "string": "{respoke.Connection}"
                }
            ],
            "description": {
                "full": "<p>Get the Connection with the specified id. The connection ID is optional if only one connection exists.</p>\n<pre><code>var connection = endpoint.getConnection({\n    connectionId: &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX&quot;\n});\n</code></pre>",
                "summary": "<p>Get the Connection with the specified id. The connection ID is optional if only one connection exists.</p>\n",
                "body": "<pre><code>var connection = endpoint.getConnection({\n    connectionId: &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX&quot;\n});\n</code></pre>"
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.getConnection = function (params) {\n        var connection = null;\n        params = params || {};\n        if (that.connections.length === 1 &&\n                (!params.connectionId || that.connections[0] === params.connectionId)) {\n            return that.connections[0];\n        }\n\n        if (!params || !params.connectionId) {\n            throw new Error(\"Can't find a connection without the connectionId.\");\n        }\n\n        that.connections.every(function eachConnection(conn) {\n            if (conn.id === params.connectionId) {\n                connection = conn;\n                return false;\n            }\n            return true;\n        });\n\n        return connection;\n    };\n\n    return that;\n}; // End respoke.Endpoint",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getConnection",
                "string": "that.getConnection()",
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Endpoint.onMessage"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.TextMessage"
                    ],
                    "name": "evt.message",
                    "description": "- the message"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "evt.target",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name"
                }
            ],
            "description": {
                "full": "<p>Handle messages sent to the logged-in user from this one Endpoint.  This callback is called every time\nrespoke.Endpoint#message fires.</p>\n",
                "summary": "<p>Handle messages sent to the logged-in user from this one Endpoint.  This callback is called every time\nrespoke.Endpoint#message fires.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Endpoint.onPresence"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "Array"
                    ],
                    "name": "evt.presence",
                    "description": "- the Endpoint's presence"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Endpoint"
                    ],
                    "name": "evt.target",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name"
                }
            ],
            "description": {
                "full": "<p>Handle presence notifications from this one Endpoint.  This callback is called every time\nrespoke.Endpoint#message fires.</p>\n",
                "summary": "<p>Handle presence notifications from this one Endpoint.  This callback is called every time\nrespoke.Endpoint#message fires.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Client.resolveEndpointPresence"
                },
                {
                    "type": "param",
                    "types": [
                        "Array<object>"
                    ],
                    "name": "connectionPresence",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{object|string|number}"
                }
            ],
            "description": {
                "full": "<p>Handle resolving presence for this endpoint</p>\n",
                "summary": "<p>Handle resolving presence for this endpoint</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/endpoint.js",
                    "output": ".docs/site/respoke/endpoint.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var respoke = require('./respoke');\nvar log = require('loglevel');",
            "ctx": {
                "type": "declaration",
                "name": "respoke",
                "value": "require('./respoke')",
                "string": "respoke",
                "file": {
                    "input": "respoke/event.js",
                    "output": ".docs/site/respoke/event.js.json"
                }
            }
        }
    ],
    "respoke.EventEmitter": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.EventEmitter"
                },
                {
                    "type": "inherits",
                    "string": "respoke.Class"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.instanceId",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{respoke.EventEmitter}"
                }
            ],
            "description": {
                "full": "<p>A generic class for emitting and listening to events.</p>\n",
                "summary": "<p>A generic class for emitting and listening to events.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var EventEmitter = module.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var that = respoke.Class(params);",
            "ctx": {
                "type": "declaration",
                "name": "respoke.EventEmitter",
                "value": "module.exports = function (params) {",
                "string": "EventEmitter",
                "file": {
                    "input": "respoke/event.js",
                    "output": ".docs/site/respoke/event.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.EventEmitter"
                },
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>A name to identify the type of this object.</p>\n",
                "summary": "<p>A name to identify the type of this object.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.EventEmitter';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.EventEmitter'",
                "string": "that.className",
                "file": {
                    "input": "respoke/event.js",
                    "output": ".docs/site/respoke/event.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "eventList"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.EventEmitter</p>\n",
                "summary": "<p>@memberof! respoke.EventEmitter</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var eventList = {};",
            "ctx": {
                "type": "declaration",
                "name": "eventList",
                "value": "{}",
                "string": "eventList",
                "file": {
                    "input": "respoke/event.js",
                    "output": ".docs/site/respoke/event.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.EventEmitter"
                },
                {
                    "type": "method",
                    "string": "respoke.EventEmitter.listen"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "eventType",
                    "description": "- A developer-specified string identifying the event."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.EventEmitter.eventListener"
                    ],
                    "name": "listener",
                    "description": "- A function to call when the event is fire."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[isInternal]",
                    "description": "- A flag to indicate this listener was added by the library. This parameter should\nnot be used by developers who are using the library, only by developers who are working on the library itself."
                }
            ],
            "description": {
                "full": "<p>Add a listener that will only be called once to an object.  This method adds the given listener to the given\nevent in the case that the same\nlistener is not already registered to this event and the listener is a function.  The third argument &#39;isInternal&#39;\nis used only internally by the library to indicate that this listener is a library-used listener and should not\ncount when we are trying to determine if an event has listeners placed by the developer.</p>\n<pre><code>client.once(&#39;connect&#39;, function (evt) {\n    console.log(&quot;This is the first time we connected.&quot;);\n});\n</code></pre>",
                "summary": "<p>Add a listener that will only be called once to an object.  This method adds the given listener to the given\nevent in the case that the same\nlistener is not already registered to this event and the listener is a function.  The third argument &#39;isInternal&#39;\nis used only internally by the library to indicate that this listener is a library-used listener and should not\ncount when we are trying to determine if an event has listeners placed by the developer.</p>\n",
                "body": "<pre><code>client.once(&#39;connect&#39;, function (evt) {\n    console.log(&quot;This is the first time we connected.&quot;);\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.once = function (eventType, listener, isInternal) {\n        listener = respoke.once(listener);\n        listener.once = true;\n        that.listen(eventType, listener, isInternal);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "once",
                "string": "that.once()",
                "file": {
                    "input": "respoke/event.js",
                    "output": ".docs/site/respoke/event.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.EventEmitter"
                },
                {
                    "type": "method",
                    "string": "respoke.EventEmitter.listen"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "eventType",
                    "description": "- The name of the event."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.EventEmitter.eventListener"
                    ],
                    "name": "listener",
                    "description": "- A function to call when the event is\nfired."
                },
                {
                    "type": "arg",
                    "string": "{boolean} isInternal - Internal use only. A flag to indicate this listener was \nadded by the library. This parameter should not be used by developers who are using\nthe library, only by developers who are working on the library itself."
                }
            ],
            "description": {
                "full": "<p>Add a <code>listener</code> function to an object.</p>\n<p>This method adds the <code>listener</code> to the event <code>eventName</code>.</p>\n<p>If an identical listener already registered to this event, it will <strong>not</strong> be added.</p>\n<h5 id=\"example-of-adding-an-event-listener-\">Example of adding an event listener.</h5>\n<pre><code>client.listen(&#39;connect&#39;, function (evt) {\n    console.log(&quot;We&#39;ve connected!&quot;, evt);\n});\n</code></pre>",
                "summary": "<p>Add a <code>listener</code> function to an object.</p>\n",
                "body": "<p>This method adds the <code>listener</code> to the event <code>eventName</code>.</p>\n<p>If an identical listener already registered to this event, it will <strong>not</strong> be added.</p>\n<h5 id=\"example-of-adding-an-event-listener-\">Example of adding an event listener.</h5>\n<pre><code>client.listen(&#39;connect&#39;, function (evt) {\n    console.log(&quot;We&#39;ve connected!&quot;, evt);\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen = function (eventType, listener, isInternal) {\n        if (listener === undefined) {\n            return;\n        }\n        var invalidEventType = typeof eventType !== 'string' || !eventType;\n        var invalidListener = typeof listener !== 'function';\n        if (invalidEventType || invalidListener) {\n            log.error(\"Invalid request to add event listener to\", eventType, listener);\n            return;\n        }\n\n        eventList[eventType] = eventList[eventType] || [];\n        listener.isInternal = !!isInternal; // boolify\n\n        var toString = function (fn) {\n            return fn.toString();\n        };\n        var isNotAlreadyAdded = eventList[eventType].map(toString).indexOf(listener.toString()) === -1;\n\n        if (isNotAlreadyAdded) {\n            eventList[eventType].push(listener);\n        } else {\n            log.warn(\"Not adding duplicate listener to\", eventType, listener);\n        }\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "listen",
                "string": "that.listen()",
                "file": {
                    "input": "respoke/event.js",
                    "output": ".docs/site/respoke/event.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.EventEmitter"
                },
                {
                    "type": "method",
                    "string": "respoke.EventEmitter.ignore"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[eventType]",
                    "description": "- An optional developer-specified string identifying the event."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "[listener]",
                    "description": "- An optional function to remove from the specified event."
                }
            ],
            "description": {
                "full": "<p>Remove a listener from an object. If no eventType is specified, all eventTypes will be\ncleared. If an eventType is specified but no listener is specified, all listeners will be\nremoved from the specified eventType.  If a listener is also specified, only that listener\nwill be removed.</p>\n<pre><code>client.ignore(&#39;connect&#39;, connectHandler);\n</code></pre>",
                "summary": "<p>Remove a listener from an object. If no eventType is specified, all eventTypes will be\ncleared. If an eventType is specified but no listener is specified, all listeners will be\nremoved from the specified eventType.  If a listener is also specified, only that listener\nwill be removed.</p>\n",
                "body": "<pre><code>client.ignore(&#39;connect&#39;, connectHandler);\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.ignore = function (eventType, listener) {\n        // Remove all events from this object\n        if (eventType === undefined) {\n            eventList = {};\n            return;\n        }\n\n        // Remove all listeners from this event.\n        if (listener === undefined || !eventList[eventType]) {\n            eventList[eventType] = [];\n            return;\n        }\n\n        // Remove only one listener from this event.\n        for (var i = eventList[eventType].length - 1; i >= 0; i -= 1) {\n            if (listener === eventList[eventType][i]) {\n                eventList[eventType].splice(i, 1);\n                return;\n            }\n        }\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "ignore",
                "string": "that.ignore()",
                "file": {
                    "input": "respoke/event.js",
                    "output": ".docs/site/respoke/event.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.EventEmitter"
                },
                {
                    "type": "method",
                    "string": "respoke.EventEmitter.fire"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "eventType",
                    "description": "- A developer-specified string identifying the event to fire."
                },
                {
                    "type": "param",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "array"
                    ],
                    "name": "evt",
                    "description": "- Any number of optional parameters to be passed to\nthe listener"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Trigger an event on an object. All listeners for the specified eventType will be called.\nListeners will be bound to the object (&#39;this&#39; will refer to the object), and additional\narguments to fire() will be passed into each listener.</p>\n",
                "summary": "<p>Trigger an event on an object. All listeners for the specified eventType will be called.\nListeners will be bound to the object (&#39;this&#39; will refer to the object), and additional\narguments to fire() will be passed into each listener.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.fire = function (eventType, evt) {\n        var args = null;\n        var count = 0;\n\n        evt = evt || {};\n        evt.name = eventType;\n        evt.target = that;\n\n        if (!eventType) {\n            return;\n        }\n\n        if (!eventList[eventType]) {\n            log.debug(\"fired \" + that.className + \"#\" + eventType + \" 0 listeners called with params\", evt);\n            return;\n        }\n\n        for (var i = eventList[eventType].length; i > -1; i -= 1) {\n            var listener = eventList[eventType][i];\n            if (typeof listener === 'function') {\n                setTimeout(listenerBuilder(listener, evt, eventType));\n\n                count += 1;\n                if (listener.once) {\n                    eventList[eventType].splice(i, 1);\n                }\n            }\n        }\n        log.debug(\"fired \" + that.className + \"#\" + eventType + \" \" + count + \" listeners called with params\", evt);\n    };\n\n    function listenerBuilder(listener, evt, eventType) {\n        return function () {\n            try {\n                listener.call(that, evt);\n            } catch (e) {\n                log.error('Error in ' + that.className + \"#\" + eventType, e.message, e.stack);\n            }\n        };\n    }",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "fire",
                "string": "that.fire()",
                "file": {
                    "input": "respoke/event.js",
                    "output": ".docs/site/respoke/event.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.EventEmitter"
                },
                {
                    "type": "method",
                    "string": "respoke.EventEmitter.hasListeners"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "eventType",
                    "description": "- The name of the event"
                },
                {
                    "type": "returns",
                    "string": "{boolean} Whether this event has any listeners that are external to this library."
                }
            ],
            "description": {
                "full": "<p>Determine if an object has had any listeners registered for a given event outside the library. This method\nchecks for the isInternal flag on each listener and doesn&#39;t count it toward an event being listened to. This\nmethod is used in the library to handle situations where an action is needed if an event won&#39;t be acted on.\nFor instance, if a call comes in for the logged-in user, but the developer isn&#39;t listening to\n{respoke.Client#call}, we&#39;ll need to reject the call immediately.</p>\n<pre><code>if (client.hasListeners(&#39;call&#39;)) {\n    // already handled!\n}\n</code></pre>",
                "summary": "<p>Determine if an object has had any listeners registered for a given event outside the library. This method\nchecks for the isInternal flag on each listener and doesn&#39;t count it toward an event being listened to. This\nmethod is used in the library to handle situations where an action is needed if an event won&#39;t be acted on.\nFor instance, if a call comes in for the logged-in user, but the developer isn&#39;t listening to\n{respoke.Client#call}, we&#39;ll need to reject the call immediately.</p>\n",
                "body": "<pre><code>if (client.hasListeners(&#39;call&#39;)) {\n    // already handled!\n}\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.hasListeners = function (eventType) {\n        if (eventType === undefined) {\n            throw new Error(\"Missing required parameter event type.\");\n        }\n\n        if (!eventList[eventType]) {\n            return false;\n        }\n\n        return !eventList[eventType].every(function eachListener(listener) {\n            return listener.isInternal;\n        });\n    };\n\n    return that;\n}; // End respoke.EventEmitter",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "hasListeners",
                "string": "that.hasListeners()",
                "file": {
                    "input": "respoke/event.js",
                    "output": ".docs/site/respoke/event.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@callback respoke.EventEmitter.eventListener</p>\n",
                "summary": "<p>@callback respoke.EventEmitter.eventListener</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/event.js",
                    "output": ".docs/site/respoke/event.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var Q = require('q');\nvar respoke = require('./respoke');",
            "ctx": {
                "type": "declaration",
                "name": "Q",
                "value": "require('q')",
                "string": "Q",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        }
    ],
    "respoke.Group": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.Group"
                },
                {
                    "type": "augments",
                    "otherClass": "respoke.EventEmitter"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.instanceId",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group.onJoin"
                    ],
                    "name": "params.onJoin",
                    "description": "- A callback to receive notifications every time a new\nendpoint has joined the group. This callback does not get called when the client joins the group."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group.onMessage"
                    ],
                    "name": "params.onMessage",
                    "description": "- A callback to receive messages sent to the group from\nremote endpoints."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group.onLeave"
                    ],
                    "name": "params.onLeave",
                    "description": "- A callback to receive notifications every time a new\nendpoint has left the group. This callback does not get called when the client leaves the group."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Group}"
                }
            ],
            "description": {
                "full": "<p>A <code>respoke.Group</code> represents a collection of endpoints.</p>\n<p>There are methods to communicate with the endpoints at the group level and track\ntheir presence in the group.</p>\n",
                "summary": "<p>A <code>respoke.Group</code> represents a collection of endpoints.</p>\n",
                "body": "<p>There are methods to communicate with the endpoints at the group level and track\ntheir presence in the group.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "module.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n\n    var that = respoke.EventEmitter(params);",
            "ctx": {
                "type": "method",
                "receiver": "module",
                "name": "respoke.Group",
                "string": "module.exports()",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "instanceId"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Group</p>\n",
                "summary": "<p>@memberof! respoke.Group</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var instanceId = params.instanceId;\n    var client = respoke.getClient(instanceId);\n\n    if (!that.id) {\n        throw new Error(\"Can't create a group without an ID.\");\n    }",
            "ctx": {
                "type": "declaration",
                "name": "instanceId",
                "value": "params.instanceId",
                "string": "instanceId",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "name",
                    "string": "signalingChannel"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.SignalingChannel"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Internal reference to the api signaling channel.</p>\n",
                "summary": "<p>Internal reference to the api signaling channel.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var signalingChannel = params.signalingChannel;\n    delete params.signalingChannel;",
            "ctx": {
                "type": "declaration",
                "name": "signalingChannel",
                "value": "params.signalingChannel",
                "string": "signalingChannel",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "name",
                    "string": "endpoints"
                },
                {
                    "type": "type",
                    "types": [
                        "array<respoke.Connection>"
                    ]
                }
            ],
            "description": {
                "full": "<p>The connections to members of this group.</p>\n",
                "summary": "<p>The connections to members of this group.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.connections = [];",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "connections",
                "value": "[]",
                "string": "that.connections",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>A name to identify the type of this object.</p>\n",
                "summary": "<p>A name to identify the type of this object.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.Group';\n    that.listen('join', params.onJoin);",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.Group'",
                "string": "that.className",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Group#message"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.TextMessage"
                    ],
                    "name": "message",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- The event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Indicates that a message has been sent to this group.</p>\n",
                "summary": "<p>Indicates that a message has been sent to this group.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.listen('message', params.onMessage);\n    that.listen('leave', params.onLeave);\n    client.listen('disconnect', function disconnectHandler() {\n        that.connections = [];\n    });\n\n    delete that.instanceId;\n    delete that.onMessage;\n    delete that.onPresence;\n    delete that.onJoin;\n    delete that.onLeave;",
            "ctx": {
                "type": "event",
                "name": "respoke.Group#message",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "method",
                    "string": "respoke.Group.join"
                },
                {
                    "type": "return",
                    "string": "{Promise|undefined}"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.joinHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of\nthis method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "fires",
                    "string": "respoke.Client#join"
                }
            ],
            "description": {
                "full": "<p>Join this group.</p>\n<pre><code>group.join().done(function () {\n    group.sendMessage({\n        message: &quot;Hey, ppl! I&#39;m here!&quot;\n    });\n}, function (err) {\n    // Couldn&#39;t join the group, possibly permissions error\n});\n</code></pre><p><strong>Using callbacks</strong> will disable promises.</p>\n",
                "summary": "<p>Join this group.</p>\n",
                "body": "<pre><code>group.join().done(function () {\n    group.sendMessage({\n        message: &quot;Hey, ppl! I&#39;m here!&quot;\n    });\n}, function (err) {\n    // Couldn&#39;t join the group, possibly permissions error\n});\n</code></pre><p><strong>Using callbacks</strong> will disable promises.</p>\n"
            },
            "isPrivate": false,
            "fires": [
                "respoke.Client#join"
            ],
            "ignore": false,
            "code": "that.join = function () {\n        var params = {\n            id: that.id\n        };\n        var promise;\n        var deferred;\n        var retVal;\n\n        try {\n            validateConnection();\n        } catch (err) {\n            deferred = Q.defer();\n            retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n            deferred.reject(err);\n            return retVal;\n        }\n\n        promise = client.join(params);\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        return retVal;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "join",
                "string": "that.join()",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "method",
                    "string": "respoke.Group.leave"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.joinHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of\nthis method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "return",
                    "string": "{Promise|undefined}"
                },
                {
                    "type": "fires",
                    "string": "respoke.Client#leave"
                }
            ],
            "description": {
                "full": "<p>Leave this group.</p>\n<pre><code>group.leave({\n    onSuccess: function () {\n        // good riddance\n    },\n    onError: function (err) {\n        // Couldn&#39;t leave the group, possibly a permissions error\n    }\n});\n</code></pre>",
                "summary": "<p>Leave this group.</p>\n",
                "body": "<pre><code>group.leave({\n    onSuccess: function () {\n        // good riddance\n    },\n    onError: function (err) {\n        // Couldn&#39;t leave the group, possibly a permissions error\n    }\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [
                "respoke.Client#leave"
            ],
            "ignore": false,
            "code": "that.leave = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            deferred.reject(err);\n            return retVal;\n        }\n\n        signalingChannel.leaveGroup({\n            id: that.id\n        }).done(function successHandler() {",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "leave",
                "string": "that.leave()",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Client#leave"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "group",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Client"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>This event is fired when the client leaves a group.</p>\n",
                "summary": "<p>This event is fired when the client leaves a group.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "client.fire('leave', {\n                group: that\n            });\n            that.connections = [];\n            deferred.resolve();\n        }, function errorHandler(err) {\n            deferred.reject();\n        });\n        return retVal;\n    };",
            "ctx": {
                "type": "event",
                "name": "respoke.Client#leave",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "method",
                    "string": "respoke.Group.removeMember"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.connectionId]",
                    "description": "- Endpoint's connection id"
                },
                {
                    "type": "fires",
                    "string": "respoke.Group#leave"
                }
            ],
            "description": {
                "full": "<p>Remove a Connection from a Group. This does not change the status of the remote Endpoint, it only changes the\ninternal representation of the Group membership. This method should only be used internally.</p>\n",
                "summary": "<p>Remove a Connection from a Group. This does not change the status of the remote Endpoint, it only changes the\ninternal representation of the Group membership. This method should only be used internally.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.Group#leave"
            ],
            "ignore": false,
            "code": "that.removeMember = function (params) {\n        params = params || {};\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            return;\n        }\n\n        if (!params.connectionId) {\n            throw new Error(\"Can't remove a member to the group without it's Connection id.\");\n        }\n\n        that.connections.every(function eachConnection(conn, index) {\n            if (conn.id === params.connectionId) {\n                that.connections.splice(index, 1);",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "removeMember",
                "string": "that.removeMember()",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Group#leave"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Connection"
                    ],
                    "name": "connection",
                    "description": "- The connection that left the group."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- The event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event is fired when a member leaves a group the client is a member of.</p>\n",
                "summary": "<p>This event is fired when a member leaves a group the client is a member of.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('leave', {\n                    connection: conn\n                });\n                return false;\n            }\n            return true;\n        });\n    };",
            "ctx": {
                "type": "event",
                "name": "respoke.Group#leave",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "method",
                    "string": "respoke.Group.isJoined"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Return true if the logged-in user is a member of this group and false if not.</p>\n<pre><code>if (group.isJoined()) {\n    // I&#39;m a member!\n} else {\n    // Maybe join here\n}\n</code></pre>",
                "summary": "<p>Return true if the logged-in user is a member of this group and false if not.</p>\n",
                "body": "<pre><code>if (group.isJoined()) {\n    // I&#39;m a member!\n} else {\n    // Maybe join here\n}\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.isJoined = function () {\n        // connections array contains some connections and ours is among them.\n        return (that.connections.length > 0 && !that.connections.every(function (conn) {\n            return conn.id !== client.connectionId;\n        }));\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "isJoined",
                "string": "that.isJoined()",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "method",
                    "string": "respoke.Group.addMember"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Connection"
                    ],
                    "name": "params.connection",
                    "description": ""
                },
                {
                    "type": "fires",
                    "string": "respoke.Group#join"
                }
            ],
            "description": {
                "full": "<p>Add a Connection to a group. This does not change the status of the remote Endpoint, it only changes the\ninternal representation of the Group membership. This method should only be used internally.</p>\n",
                "summary": "<p>Add a Connection to a group. This does not change the status of the remote Endpoint, it only changes the\ninternal representation of the Group membership. This method should only be used internally.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.Group#join"
            ],
            "ignore": false,
            "code": "that.addMember = function (params) {\n        params = params || {};\n        var absent;\n\n        validateConnection();\n\n        if (!params.connection) {\n            throw new Error(\"Can't add a member to the group without it's Connection object.\");\n        }\n\n        absent = that.connections.every(function eachConnection(conn) {\n            return (conn.id !== params.connection.id);\n        });\n\n        if (absent) {\n            that.connections.push(params.connection);\n            if (params.skipEvent) {\n                return;\n            }",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "addMember",
                "string": "that.addMember()",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Group#join"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Connection"
                    ],
                    "name": "connection",
                    "description": "- The connection that joined the group."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- The event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event is fired when a member joins a Group that the currently logged-in endpoint is a member\nof.</p>\n",
                "summary": "<p>This event is fired when a member joins a Group that the currently logged-in endpoint is a member\nof.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('join', {\n                connection: params.connection\n            });\n        }\n    };",
            "ctx": {
                "type": "event",
                "name": "respoke.Group#join",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "method",
                    "string": "respoke.Group.validateConnection"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Validate that the client is connected to the Respoke infrastructure.</p>\n",
                "summary": "<p>Validate that the client is connected to the Respoke infrastructure.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function validateConnection() {\n        if (!signalingChannel || !signalingChannel.isConnected()) {\n            throw new Error(\"Can't complete request when not connected. Please reconnect!\");\n        }\n    }",
            "ctx": {
                "type": "function",
                "name": "validateConnection",
                "string": "validateConnection()",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "method",
                    "string": "respoke.Group.validateMembership"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Validate that the client is a member of this group.</p>\n",
                "summary": "<p>Validate that the client is a member of this group.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function validateMembership() {\n        if (!that.isJoined()) {\n            throw new Error(\"Not a member of this group anymore.\");\n        }\n    }",
            "ctx": {
                "type": "function",
                "name": "validateMembership",
                "string": "validateMembership()",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "method",
                    "string": "respoke.Group.sendMessage"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.message",
                    "description": "- The message."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.onSuccess",
                    "description": "- Success handler indicating that the message was delivered."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "params.onError",
                    "description": "- Error handler indicating that the message was not delivered."
                },
                {
                    "type": "returns",
                    "string": "{Promise}"
                }
            ],
            "description": {
                "full": "<p>Send a message to all of the endpoints in the group.</p>\n<pre><code> var group = client.getGroup({ id: &#39;js-enthusiasts&#39;});\n\n group.sendMessage({\n     message: &quot;Cat on keyboard&quot;,\n     onSuccess: function (evt) {\n         console.log(&#39;Message was sent&#39;);\n     }\n });\n</code></pre>",
                "summary": "<p>Send a message to all of the endpoints in the group.</p>\n",
                "body": "<pre><code> var group = client.getGroup({ id: &#39;js-enthusiasts&#39;});\n\n group.sendMessage({\n     message: &quot;Cat on keyboard&quot;,\n     onSuccess: function (evt) {\n         console.log(&#39;Message was sent&#39;);\n     }\n });\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.sendMessage = function (params) {\n        params = params || {};\n        params.id = that.id;\n        var promise;\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            promise = Q.reject(err);\n        }\n\n        return respoke.handlePromise(promise ? promise : signalingChannel.publish(params),\n                params.onSuccess, params.onError);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "sendMessage",
                "string": "that.sendMessage()",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Group"
                },
                {
                    "type": "method",
                    "string": "respoke.Group.getMembers"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.joinHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Success handler for this invocation of this method only."
                },
                {
                    "type": "returns",
                    "string": "{Promise<Array>} A promise to an array of Connections."
                }
            ],
            "description": {
                "full": "<p>Get group members</p>\n<p>Get an array containing the members of the group. Accepts <code>onSuccess</code> or <code>onError</code> parameters,\nor a promise.</p>\n<pre><code>group.getMembers({\n    onSuccess: function (members) {\n        members.forEach(function (member) {\n            // do something\n        });\n    }\n});\n</code></pre>",
                "summary": "<p>Get group members</p>\n",
                "body": "<p>Get an array containing the members of the group. Accepts <code>onSuccess</code> or <code>onError</code> parameters,\nor a promise.</p>\n<pre><code>group.getMembers({\n    onSuccess: function (members) {\n        members.forEach(function (member) {\n            // do something\n        });\n    }\n});\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getMembers = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n\n        try {\n            validateConnection();\n            validateMembership();\n        } catch (err) {\n            deferred.reject(err);\n            return retVal;\n        }\n\n        signalingChannel.getGroupMembers({\n            id: that.id\n        }).done(function successHandler(list) {\n            var endpointList = [];\n            list.forEach(function eachMember(params) {\n                var connection = client.getConnection({\n                    endpointId: params.endpointId,\n                    connectionId: params.connectionId,\n                    skipCreate: true\n                });\n\n                if (!connection) {\n                    // Create the connection\n                    connection = client.getConnection({\n                        endpointId: params.endpointId,\n                        connectionId: params.connectionId\n                    });\n                }\n\n                if (endpointList.indexOf(params.endpointId) === -1) {\n                    endpointList.push(params.endpointId);\n                }\n                that.addMember({\n                    connection: connection,\n                    skipEvent: true\n                });\n            });\n\n            deferred.resolve(that.connections);\n        }, function errorHandler(err) {\n            deferred.reject(err);\n        });\n        return retVal;\n    };\n\n    return that;\n}; // End respoke.Group",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getMembers",
                "string": "that.getMembers()",
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Group.onJoin"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Connection"
                    ],
                    "name": "evt.connection",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Receive notification that an endpoint has joined this group. This callback is called everytime\nrespoke.Group#join is fired.</p>\n",
                "summary": "<p>Receive notification that an endpoint has joined this group. This callback is called everytime\nrespoke.Group#join is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Group.onLeave"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Connection"
                    ],
                    "name": "evt.connection",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Receive notification that an endpoint has left this group. This callback is called everytime\nrespoke.Group#leave is fired.</p>\n",
                "summary": "<p>Receive notification that an endpoint has left this group. This callback is called everytime\nrespoke.Group#leave is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Group.onMessage"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Event"
                    ],
                    "name": "evt",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.TextMessage"
                    ],
                    "name": "evt.message",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "evt.name",
                    "description": "- the event name."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Group"
                    ],
                    "name": "evt.target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Receive notification that a message has been received to a group. This callback is called every time\nrespoke.Group#message is fired.</p>\n",
                "summary": "<p>Receive notification that a message has been received to a group. This callback is called every time\nrespoke.Group#message is fired.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.Group.connectionsHandler"
                },
                {
                    "type": "param",
                    "types": [
                        "Array<respoke.Connection>"
                    ],
                    "name": "connections",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Get a list of the Connections which are members of this Group.</p>\n",
                "summary": "<p>Get a list of the Connections which are members of this Group.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/group.js",
                    "output": ".docs/site/respoke/group.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var log = require('loglevel');\nvar respoke = require('./respoke');",
            "ctx": {
                "type": "declaration",
                "name": "log",
                "value": "require('loglevel')",
                "string": "log",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        }
    ],
    "respoke.LocalMedia": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "augments",
                    "otherClass": "respoke.EventEmitter"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.instanceId",
                    "description": "- client id"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.callId",
                    "description": "- call id"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params.constraints]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "params.element",
                    "description": "- Pass in an optional html video element to have local video attached to it."
                },
                {
                    "type": "returns",
                    "string": "{respoke.LocalMedia}"
                }
            ],
            "description": {
                "full": "<p>A wrapper around the stream from <code>getUserMedia</code>,\nwhich is attached to a call at <code>call.outgoingMedia</code>.</p>\n",
                "summary": "<p>A wrapper around the stream from <code>getUserMedia</code>,\nwhich is attached to a call at <code>call.outgoingMedia</code>.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "module.exports = function (params) {\n    \"use strict\";\n    params = params || {};",
            "ctx": {
                "type": "method",
                "receiver": "module",
                "name": "respoke.LocalMedia",
                "string": "module.exports()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "instanceId"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.LocalMedia</p>\n",
                "summary": "<p>@memberof! respoke.LocalMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;",
            "ctx": {
                "type": "declaration",
                "name": "instanceId",
                "value": "params.instanceId",
                "string": "instanceId",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.LocalMedia</p>\n",
                "summary": "<p>@memberof! respoke.LocalMedia</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.LocalMedia';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.LocalMedia'",
                "string": "that.className",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "name",
                    "string": "id"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>Respoke media ID (different from a <code>MediaStream.id</code>).</p>\n",
                "summary": "<p>Respoke media ID (different from a <code>MediaStream.id</code>).</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.id = respoke.makeGUID();",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "id",
                "value": "respoke.makeGUID()",
                "string": "that.id",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "client"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.getClient"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.LocalMedia</p>\n",
                "summary": "<p>@memberof! respoke.LocalMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var client = respoke.getClient(instanceId);",
            "ctx": {
                "type": "declaration",
                "name": "client",
                "value": "respoke.getClient(instanceId)",
                "string": "client",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "name",
                    "string": "element"
                },
                {
                    "type": "type",
                    "types": [
                        "HTMLVideoElement"
                    ]
                }
            ],
            "description": {
                "full": "<p>The HTML element with video attached.</p>\n",
                "summary": "<p>The HTML element with video attached.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.element = params.element;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "element",
                "value": "params.element",
                "string": "that.element",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "sdpHasAudio"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.LocalMedia</p>\n",
                "summary": "<p>@memberof! respoke.LocalMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var sdpHasAudio = false;",
            "ctx": {
                "type": "declaration",
                "name": "sdpHasAudio",
                "value": "false",
                "string": "sdpHasAudio",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "sdpHasVideo"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.LocalMedia</p>\n",
                "summary": "<p>@memberof! respoke.LocalMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var sdpHasVideo = false;",
            "ctx": {
                "type": "declaration",
                "name": "sdpHasVideo",
                "value": "false",
                "string": "sdpHasVideo",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "sdpHasDataChannel"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.LocalMedia</p>\n",
                "summary": "<p>@memberof! respoke.LocalMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var sdpHasDataChannel = false;",
            "ctx": {
                "type": "declaration",
                "name": "sdpHasDataChannel",
                "value": "false",
                "string": "sdpHasDataChannel",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "name",
                    "string": "allowTimer"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "number"
                    ]
                }
            ],
            "description": {
                "full": "<p>A timer to make sure we only fire {respoke.LocalMedia#requesting-media} if the browser doesn&#39;t\nautomatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.</p>\n",
                "summary": "<p>A timer to make sure we only fire {respoke.LocalMedia#requesting-media} if the browser doesn&#39;t\nautomatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var allowTimer = 0;",
            "ctx": {
                "type": "declaration",
                "name": "allowTimer",
                "value": "0",
                "string": "allowTimer",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "mediaOptions"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.LocalMedia</p>\n",
                "summary": "<p>@memberof! respoke.LocalMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var mediaOptions = {\n        optional: [\n            { DtlsSrtpKeyAgreement: true },\n            { RtpDataChannels: false }\n        ]\n    };",
            "ctx": {
                "type": "declaration",
                "name": "mediaOptions",
                "value": "{",
                "string": "mediaOptions",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "pc"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.PeerConnection"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.LocalMedia</p>\n",
                "summary": "<p>@memberof! respoke.LocalMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var pc = params.pc;\n    delete that.pc;",
            "ctx": {
                "type": "declaration",
                "name": "pc",
                "value": "params.pc",
                "string": "pc",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "name",
                    "string": "stream"
                },
                {
                    "type": "type",
                    "types": [
                        "RTCMediaStream"
                    ]
                }
            ],
            "description": {
                "full": "<p>The local <code>MediaStream</code> from <code>getUserMedia()</code>.</p>\n",
                "summary": "<p>The local <code>MediaStream</code> from <code>getUserMedia()</code>.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.stream = null;\n\n    function getStream(theConstraints) {\n        for (var i = 0; i < respoke.streams.length; i++) {\n            var s = respoke.streams[i];\n            if (respoke.isEqual(s.constraints, theConstraints)) {\n                return s.stream;\n            }\n        }\n        return null;\n    }\n\n    function removeStream(theConstraints) {\n        var toRemoveIndex;\n        for (var i = 0; i < respoke.streams.length; i++) {\n            var s = respoke.streams[i];\n            if (respoke.isEqual(s.constraints, theConstraints)) {\n                toRemoveIndex = i;\n                break;\n            }\n        }\n        if (toRemoveIndex !== undefined) {\n            respoke.streams.splice(toRemoveIndex, 1);\n        }\n    }",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "stream",
                "value": "null",
                "string": "that.stream",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.onReceiveUserMedia"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "RTCMediaStream"
                    ],
                    "name": "theStream",
                    "description": ""
                },
                {
                    "type": "fires",
                    "string": "respoke.LocalMedia#stream-received"
                }
            ],
            "description": {
                "full": "<p>Save the local stream. Kick off SDP creation.</p>\n",
                "summary": "<p>Save the local stream. Kick off SDP creation.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.LocalMedia#stream-received"
            ],
            "ignore": false,
            "code": "function onReceiveUserMedia(theStream) {\n        that.stream = theStream;\n        clearTimeout(allowTimer);",
            "ctx": {
                "type": "function",
                "name": "onReceiveUserMedia",
                "string": "onReceiveUserMedia()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.LocalMedia#allow"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>The user has approved the request for media. Any UI changes made to remind the user to click Allow\nshould be canceled now. This event is the same as the <code>onAllow</code> callback.  This event gets fired\neven if the allow process is automatic, i. e., permission and media is granted by the browser\nwithout asking the user to approve it.</p>\n",
                "summary": "<p>The user has approved the request for media. Any UI changes made to remind the user to click Allow\nshould be canceled now. This event is the same as the <code>onAllow</code> callback.  This event gets fired\neven if the allow process is automatic, i. e., permission and media is granted by the browser\nwithout asking the user to approve it.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('allow');\n        log.debug('User gave permission to use media.');\n        log.debug('onReceiveUserMedia');",
            "ctx": {
                "type": "event",
                "name": "respoke.LocalMedia#allow",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.getAudioTracks"
                }
            ],
            "description": {
                "full": "<p>Expose getAudioTracks.</p>\n",
                "summary": "<p>Expose getAudioTracks.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getAudioTracks = that.stream.getAudioTracks.bind(that.stream);",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "getAudioTracks",
                "value": "that.stream.getAudioTracks.bind(that.stream)",
                "string": "that.getAudioTracks",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.getVideoTracks"
                }
            ],
            "description": {
                "full": "<p>Expose getVideoTracks.</p>\n",
                "summary": "<p>Expose getVideoTracks.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getVideoTracks = that.stream.getVideoTracks.bind(that.stream);\n\n        // This happens when we get an automatic hangup or reject from the other side.\n        if (pc === null) {\n            that.hangup({signal: false});\n            return;\n        }\n\n        that.element = that.element || document.createElement('video');\n\n        // This still needs some work. Using cached streams causes an unused video element to be passed\n        // back to the App. This is because we assume at the moment that only one local media video element\n        // will be needed. The first one passed back will contain media and the others will fake it. Media\n        // will still be sent with every peer connection. Also need to study the use of getLocalElement\n        // and the implications of passing back a video element with no media attached.\n        var aStream = getStream(that.constraints);\n        if (aStream) {\n            aStream.numPc += 1;\n\n            attachMediaStream(that.element, that.stream);\n            // We won't want our local video outputting audio.\n            that.element.muted = true;\n            that.element.autoplay = true;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "getVideoTracks",
                "value": "that.stream.getVideoTracks.bind(that.stream)",
                "string": "that.getVideoTracks",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "Element"
                    ],
                    "name": "element",
                    "description": "- the HTML5 Video element with the new stream attached."
                },
                {
                    "type": "property",
                    "types": [
                        "RTCMediaStream"
                    ],
                    "name": "stream",
                    "description": "- the HTML5 Video stream"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.LocalMedia#stream-received</p>\n",
                "summary": "<p>@event respoke.LocalMedia#stream-received</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('stream-received', {\n                element: that.element,\n                stream: that.stream\n            });\n        } else {\n            that.stream.numPc = 1;\n            respoke.streams.push({stream: that.stream, constraints: that.constraints});\n\n            that.stream.id = client.endpointId;\n            attachMediaStream(that.element, that.stream);\n            // We won't want our local video outputting audio.\n            that.element.muted = true;\n            that.element.autoplay = true;",
            "ctx": {
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "Element"
                    ],
                    "name": "element",
                    "description": "- the HTML5 Video element with the new stream attached."
                },
                {
                    "type": "property",
                    "types": [
                        "RTCMediaStream"
                    ],
                    "name": "stream",
                    "description": "- the HTML5 Video stream"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.LocalMedia#stream-received</p>\n",
                "summary": "<p>@event respoke.LocalMedia#stream-received</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('stream-received', {\n                element: that.element,\n                stream: that.stream\n            });\n        }\n    }",
            "ctx": {
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.requestMedia"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Create the RTCPeerConnection and add handlers. Process any offer we have already received.</p>\n",
                "summary": "<p>Create the RTCPeerConnection and add handlers. Process any offer we have already received.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function requestMedia() {\n        log.debug('requestMedia');\n\n        if (!that.constraints) {\n            throw new Error('No constraints.');\n        }\n\n        var theStream = getStream(that.constraints);\n        if (theStream) {\n            log.debug('using old stream');\n            onReceiveUserMedia(theStream);\n            return;\n        }\n\n        try {\n            log.debug(\"Running getUserMedia with constraints\", that.constraints);\n            // TODO set getStream(that.constraints) = true as a flag that we are already\n            // attempting to obtain this media so the race condition where gUM is called twice with\n            // the same constraints when calls are placed too quickly together doesn't occur.\n            allowTimer = setTimeout(function allowTimer() {",
            "ctx": {
                "type": "function",
                "name": "requestMedia",
                "string": "requestMedia()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.LocalMedia#requesting-media"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>The browser is asking for permission to access the User&#39;s media. This would be an ideal time\nto modify the UI of the application so that the user notices the request for permissions\nand approves it.</p>\n",
                "summary": "<p>The browser is asking for permission to access the User&#39;s media. This would be an ideal time\nto modify the UI of the application so that the user notices the request for permissions\nand approves it.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('requesting-media');\n            }, 500);\n            getUserMedia(that.constraints, onReceiveUserMedia, onUserMediaError);\n        } catch (e) {\n            log.error(\"Couldn't get user media: \" + e.message);\n        }\n    }",
            "ctx": {
                "type": "event",
                "name": "respoke.LocalMedia#requesting-media",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.onUserMediaError"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Handle any error that comes up during the process of getting user media.</p>\n",
                "summary": "<p>Handle any error that comes up during the process of getting user media.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function onUserMediaError(p) {\n        log.debug('onUserMediaError');\n        if (p.code === 1) {\n            log.warn(\"Permission denied.\");",
            "ctx": {
                "type": "function",
                "name": "onUserMediaError",
                "string": "onUserMediaError()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.LocalMedia#requesting-media"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Indicate there has been an error obtaining media.</p>\n",
                "summary": "<p>Indicate there has been an error obtaining media.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('error', {error: 'Permission denied.'});\n        } else {\n            log.warn(p);",
            "ctx": {
                "type": "event",
                "name": "respoke.LocalMedia#requesting-media",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.LocalMedia#requesting-media"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Indicate there has been an error obtaining media.</p>\n",
                "summary": "<p>Indicate there has been an error obtaining media.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('error', {error: p.code});\n        }\n    }",
            "ctx": {
                "type": "event",
                "name": "respoke.LocalMedia#requesting-media",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "returns",
                    "string": "boolean"
                }
            ],
            "description": {
                "full": "<p>Whether the video stream is muted.</p>\n<p>All video tracks must be muted for this to return <code>false</code>.</p>\n",
                "summary": "<p>Whether the video stream is muted.</p>\n",
                "body": "<p>All video tracks must be muted for this to return <code>false</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.isVideoMuted = function () {\n        if (!that.stream) {\n            return false;\n        }\n        return that.stream.getVideoTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "isVideoMuted",
                "string": "that.isVideoMuted()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.muteVideo"
                },
                {
                    "type": "fires",
                    "string": "respoke.LocalMedia#mute"
                }
            ],
            "description": {
                "full": "<p>Mute local video stream.</p>\n",
                "summary": "<p>Mute local video stream.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.LocalMedia#mute"
            ],
            "ignore": false,
            "code": "that.muteVideo = function () {\n        if (that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "muteVideo",
                "string": "that.muteVideo()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "type",
                    "description": "- Either \"audio\" or \"video\" to specify the type of stream whose muted state\nhas been changed."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "muted",
                    "description": "- Whether the stream is now muted. Will be set to false if mute was turned off."
                }
            ],
            "description": {
                "full": "<p>@event respoke.LocalMedia#mute</p>\n",
                "summary": "<p>@event respoke.LocalMedia#mute</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('mute', {\n            type: 'video',\n            muted: true\n        });\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.unmuteVideo"
                },
                {
                    "type": "fires",
                    "string": "respoke.LocalMedia#mute"
                }
            ],
            "description": {
                "full": "<p>Unmute local video stream.</p>\n",
                "summary": "<p>Unmute local video stream.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.LocalMedia#mute"
            ],
            "ignore": false,
            "code": "that.unmuteVideo = function () {\n        if (!that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "unmuteVideo",
                "string": "that.unmuteVideo()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "type",
                    "description": "- Either \"audio\" or \"video\" to specify the type of stream whose muted state\nhas been changed."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "muted",
                    "description": "- Whether the stream is now muted. Will be set to false if mute was turned off."
                }
            ],
            "description": {
                "full": "<p>@event respoke.LocalMedia#mute</p>\n",
                "summary": "<p>@event respoke.LocalMedia#mute</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('mute', {\n            type: 'video',\n            muted: false\n        });\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "returns",
                    "string": "boolean"
                }
            ],
            "description": {
                "full": "<p>Whether the audio stream is muted.</p>\n<p>All audio tracks must be muted for this to return <code>false</code>.</p>\n",
                "summary": "<p>Whether the audio stream is muted.</p>\n",
                "body": "<p>All audio tracks must be muted for this to return <code>false</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.isAudioMuted = function () {\n        if (!that.stream) {\n            return false;\n        }\n        return that.stream.getAudioTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "isAudioMuted",
                "string": "that.isAudioMuted()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.muteAudio"
                },
                {
                    "type": "fires",
                    "string": "respoke.LocalMedia#mute"
                }
            ],
            "description": {
                "full": "<p>Mute local audio stream.</p>\n",
                "summary": "<p>Mute local audio stream.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.LocalMedia#mute"
            ],
            "ignore": false,
            "code": "that.muteAudio = function () {\n        if (that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "muteAudio",
                "string": "that.muteAudio()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "type",
                    "description": "- Either \"audio\" or \"video\" to specify the type of stream whose muted state\nhas been changed."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "muted",
                    "description": "- Whether the stream is now muted. Will be set to false if mute was turned off."
                }
            ],
            "description": {
                "full": "<p>@event respoke.LocalMedia#mute</p>\n",
                "summary": "<p>@event respoke.LocalMedia#mute</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('mute', {\n            type: 'audio',\n            muted: true\n        });\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.unmuteAudio"
                },
                {
                    "type": "fires",
                    "string": "respoke.LocalMedia#mute"
                }
            ],
            "description": {
                "full": "<p>Unmute local audio stream.</p>\n",
                "summary": "<p>Unmute local audio stream.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.LocalMedia#mute"
            ],
            "ignore": false,
            "code": "that.unmuteAudio = function () {\n        if (!that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "unmuteAudio",
                "string": "that.unmuteAudio()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "type",
                    "description": "- Either \"audio\" or \"video\" to specify the type of stream whose muted state\nhas been changed."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "muted",
                    "description": "- Whether the stream is now muted. Will be set to false if mute was turned off."
                }
            ],
            "description": {
                "full": "<p>@event respoke.LocalMedia#mute</p>\n",
                "summary": "<p>@event respoke.LocalMedia#mute</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('mute', {\n            type: 'audio',\n            muted: false\n        });\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.stop"
                },
                {
                    "type": "fires",
                    "string": "respoke.LocalMedia#stop"
                }
            ],
            "description": {
                "full": "<p>Stop the stream.</p>\n",
                "summary": "<p>Stop the stream.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.LocalMedia#stop"
            ],
            "ignore": false,
            "code": "that.stop = function () {\n        if (!that.stream) {\n            return;\n        }\n\n        that.stream.numPc -= 1;\n        if (that.stream.numPc === 0) {\n            that.stream.stop();\n            removeStream(that.constraints);\n        }\n        that.stream = null;",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "stop",
                "string": "that.stop()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.LocalMedia"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.LocalMedia#stop</p>\n",
                "summary": "<p>@event respoke.LocalMedia#stop</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('stop');\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.hasVideo"
                },
                {
                    "type": "return",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Indicate whether we are sending video.</p>\n",
                "summary": "<p>Indicate whether we are sending video.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.hasVideo = function () {\n        if (that.stream) {\n            return (that.stream.getVideoTracks().length > 0);\n        }\n        return sdpHasVideo;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "hasVideo",
                "string": "that.hasVideo()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.hasAudio"
                },
                {
                    "type": "return",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Indicate whether we are sending audio.</p>\n",
                "summary": "<p>Indicate whether we are sending audio.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.hasAudio = function () {\n        if (that.stream) {\n            return (that.stream.getAudioTracks().length > 0);\n        }\n        return sdpHasAudio;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "hasAudio",
                "string": "that.hasAudio()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.hasMedia"
                },
                {
                    "type": "return",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Indicate whether we have media yet.</p>\n",
                "summary": "<p>Indicate whether we have media yet.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.hasMedia = function () {\n        return !!that.stream;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "hasMedia",
                "string": "that.hasMedia()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.setSDP"
                },
                {
                    "type": "param",
                    "types": [
                        "RTCSessionDescription"
                    ],
                    "name": "oSession",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Save and parse the SDP.</p>\n",
                "summary": "<p>Save and parse the SDP.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.setSDP = function (oSession) {\n        sdpHasVideo = respoke.sdpHasVideo(oSession.sdp);\n        sdpHasAudio = respoke.sdpHasAudio(oSession.sdp);\n        sdpHasDataChannel = respoke.sdpHasDataChannel(oSession.sdp);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "setSDP",
                "string": "that.setSDP()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.LocalMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.LocalMedia.start"
                },
                {
                    "type": "fires",
                    "string": "respoke.LocalMedia#start"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Start the stream.</p>\n",
                "summary": "<p>Start the stream.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.LocalMedia#start"
            ],
            "ignore": false,
            "code": "that.start = function () {\n        requestMedia();\n    };\n\n    return that;\n}; // End respoke.LocalMedia",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "start",
                "string": "that.start()",
                "file": {
                    "input": "respoke/localMedia.js",
                    "output": ".docs/site/respoke/localMedia.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var respoke = require('./respoke');",
            "ctx": {
                "type": "declaration",
                "name": "respoke",
                "value": "require('./respoke')",
                "string": "respoke",
                "file": {
                    "input": "respoke/presentable.js",
                    "output": ".docs/site/respoke/presentable.js.json"
                }
            }
        }
    ],
    "respoke.Presentable": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.Presentable"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "augments",
                    "otherClass": "respoke.EventEmitter"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.instanceId",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.id",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{respoke.Presentable}"
                }
            ],
            "description": {
                "full": "<p>The purpose of the class is to allow multiple types of entities to expose presence functionality.</p>\n<p>Setting the presence on a client is provided via <code>client.setPresence({ presence: &quot;At lunch&quot; })</code>.</p>\n",
                "summary": "<p>The purpose of the class is to allow multiple types of entities to expose presence functionality.</p>\n",
                "body": "<p>Setting the presence on a client is provided via <code>client.setPresence({ presence: &quot;At lunch&quot; })</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "module.exports = function (params) {\n    \"use strict\";\n    params = params || {};",
            "ctx": {
                "type": "method",
                "receiver": "module",
                "name": "respoke.Presentable",
                "string": "module.exports()",
                "file": {
                    "input": "respoke/presentable.js",
                    "output": ".docs/site/respoke/presentable.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "instanceId"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.Presentable</p>\n",
                "summary": "<p>@memberof! respoke.Presentable</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;",
            "ctx": {
                "type": "declaration",
                "name": "instanceId",
                "value": "params.instanceId",
                "string": "instanceId",
                "file": {
                    "input": "respoke/presentable.js",
                    "output": ".docs/site/respoke/presentable.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Presentable"
                },
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>A name to identify the type of this object.</p>\n",
                "summary": "<p>A name to identify the type of this object.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.Presentable';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.Presentable'",
                "string": "that.className",
                "file": {
                    "input": "respoke/presentable.js",
                    "output": ".docs/site/respoke/presentable.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Presentable"
                },
                {
                    "type": "name",
                    "string": "presence"
                },
                {
                    "type": "type",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "Array"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Represents the presence status. Typically a string, but other types are supported.\nDefaults to <code>&#39;unavailable&#39;</code>.</p>\n<p><strong>Do not modify this directly</strong> - it won&#39;t update presence with Respoke. Use <code>setPresence()</code>.</p>\n",
                "summary": "<p>Represents the presence status. Typically a string, but other types are supported.\nDefaults to <code>&#39;unavailable&#39;</code>.</p>\n",
                "body": "<p><strong>Do not modify this directly</strong> - it won&#39;t update presence with Respoke. Use <code>setPresence()</code>.</p>\n"
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.presence = 'unavailable';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "presence",
                "value": "'unavailable'",
                "string": "that.presence",
                "file": {
                    "input": "respoke/presentable.js",
                    "output": ".docs/site/respoke/presentable.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "client"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Client"
                    ]
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.DirectConnection</p>\n",
                "summary": "<p>@memberof! respoke.DirectConnection</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var client = respoke.getClient(instanceId);",
            "ctx": {
                "type": "declaration",
                "name": "client",
                "value": "respoke.getClient(instanceId)",
                "string": "client",
                "file": {
                    "input": "respoke/presentable.js",
                    "output": ".docs/site/respoke/presentable.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Presentable"
                },
                {
                    "type": "method",
                    "string": "respoke.Presentable.setPresence"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "Array"
                    ],
                    "name": "[params.presence=available]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.connectionId",
                    "description": ""
                },
                {
                    "type": "fires",
                    "string": "respoke.Presentable#presence"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Set the presence on the object for this session.</p>\n",
                "summary": "<p>Set the presence on the object for this session.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [
                "respoke.Presentable#presence"
            ],
            "ignore": false,
            "code": "that.setPresence = function (params) {\n        var connection;\n        params = params || {};\n        params.presence = params.presence || 'available';\n        params.connectionId = params.connectionId || that.connectionId;\n\n        if (that.className === 'respoke.Client' || that.className === 'respoke.Connection') {\n            that.presence = params.presence;\n            if (that.className === 'respoke.Connection') {\n                that.getEndpoint().resolvePresence();\n            }\n        } else if (that.className === 'respoke.Endpoint') {\n            if (!params.connectionId) {\n                throw new Error(\"Can't set Endpoint presence without a connectionId.\");\n            }\n\n            connection = that.getConnection({connectionId: params.connectionId}) || client.getConnection({\n                connectionId: params.connectionId,\n                skipCreate: false,\n                endpointId: that.id\n            });\n\n            connection.presence = params.presence;\n            that.resolvePresence();\n        }",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "setPresence",
                "string": "that.setPresence()",
                "file": {
                    "input": "respoke/presentable.js",
                    "output": ".docs/site/respoke/presentable.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "event",
                    "string": "respoke.Presentable#presence"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.Event"
                    ]
                },
                {
                    "type": "property",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "Array"
                    ],
                    "name": "presence",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.Presentable"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>This event indicates that the presence for this endpoint has been updated.</p>\n",
                "summary": "<p>This event indicates that the presence for this endpoint has been updated.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('presence', {\n            presence: that.presence\n        });\n    };",
            "ctx": {
                "type": "event",
                "name": "respoke.Presentable#presence",
                "file": {
                    "input": "respoke/presentable.js",
                    "output": ".docs/site/respoke/presentable.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.Presentable"
                },
                {
                    "type": "method",
                    "string": "respoke.Presentable.getPresence"
                },
                {
                    "type": "returns",
                    "string": "{string|number|object|array} the current presence of this endpoint."
                }
            ],
            "description": {
                "full": "<p>Get the presence of a Presentable instance.</p>\n<pre><code> var billy = client.getEndpoint({ id: &quot;billychia&quot; });\n var pres = billy.getPresence();\n console.log(&#39;Billy is&#39;, pres); // &quot;Billy is available&quot;\n</code></pre>",
                "summary": "<p>Get the presence of a Presentable instance.</p>\n",
                "body": "<pre><code> var billy = client.getEndpoint({ id: &quot;billychia&quot; });\n var pres = billy.getPresence();\n console.log(&#39;Billy is&#39;, pres); // &quot;Billy is available&quot;\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getPresence = function () {\n        return that.presence;\n    };\n\n    return that;\n}; // End respoke.Presentable",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getPresence",
                "string": "that.getPresence()",
                "file": {
                    "input": "respoke/presentable.js",
                    "output": ".docs/site/respoke/presentable.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var log = require('loglevel');\nvar respoke = require('./respoke');",
            "ctx": {
                "type": "declaration",
                "name": "log",
                "value": "require('loglevel')",
                "string": "log",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        }
    ],
    "respoke.RemoteMedia": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "augments",
                    "otherClass": "respoke.EventEmitter"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.instanceId",
                    "description": "- client id"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "params.callId",
                    "description": "- call id"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params.constraints",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "HTMLVideoElement"
                    ],
                    "name": "params.videoRemoteElement",
                    "description": "- Pass in an optional html video element to have remote video attached to it."
                },
                {
                    "type": "returns",
                    "string": "{respoke.RemoteMedia}"
                }
            ],
            "description": {
                "full": "<p>Class for managing the remote media stream, \nwhich is attached to a call at <code>call.outgoingMedia</code>.</p>\n",
                "summary": "<p>Class for managing the remote media stream, \nwhich is attached to a call at <code>call.outgoingMedia</code>.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "module.exports = function (params) {\n    \"use strict\";\n    params = params || {};",
            "ctx": {
                "type": "method",
                "receiver": "module",
                "name": "respoke.RemoteMedia",
                "string": "module.exports()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "instanceId"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "summary": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var instanceId = params.instanceId;\n    var that = respoke.EventEmitter(params);\n    delete that.instanceId;",
            "ctx": {
                "type": "declaration",
                "name": "instanceId",
                "value": "params.instanceId",
                "string": "instanceId",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "summary": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.RemoteMedia';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.RemoteMedia'",
                "string": "that.className",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "name",
                    "string": "id"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>Respoke media ID (different from a <code>MediaStream.id</code>).</p>\n",
                "summary": "<p>Respoke media ID (different from a <code>MediaStream.id</code>).</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.id = respoke.makeGUID();",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "id",
                "value": "respoke.makeGUID()",
                "string": "that.id",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "client"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.getClient"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "summary": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var client = respoke.getClient(instanceId);",
            "ctx": {
                "type": "declaration",
                "name": "client",
                "value": "respoke.getClient(instanceId)",
                "string": "client",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "name",
                    "string": "element"
                },
                {
                    "type": "type",
                    "types": [
                        "HTMLVideoElement"
                    ]
                }
            ],
            "description": {
                "full": "<p>The HTML element with attached video.</p>\n",
                "summary": "<p>The HTML element with attached video.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.element = params.videoRemoteElement;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "element",
                "value": "params.videoRemoteElement",
                "string": "that.element",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "sdpHasAudio"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "summary": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var sdpHasAudio = false;",
            "ctx": {
                "type": "declaration",
                "name": "sdpHasAudio",
                "value": "false",
                "string": "sdpHasAudio",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "sdpHasVideo"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "summary": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var sdpHasVideo = false;",
            "ctx": {
                "type": "declaration",
                "name": "sdpHasVideo",
                "value": "false",
                "string": "sdpHasVideo",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "sdpHasDataChannel"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "summary": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var sdpHasDataChannel = false;",
            "ctx": {
                "type": "declaration",
                "name": "sdpHasDataChannel",
                "value": "false",
                "string": "sdpHasDataChannel",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "name",
                    "string": "allowTimer"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "number"
                    ]
                }
            ],
            "description": {
                "full": "<p>A timer to make sure we only fire {respoke.RemoteMedia#requesting-media} if the browser doesn&#39;t\nautomatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.</p>\n",
                "summary": "<p>A timer to make sure we only fire {respoke.RemoteMedia#requesting-media} if the browser doesn&#39;t\nautomatically grant permission on behalf of the user. Timer is canceled in onReceiveUserMedia.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var allowTimer = 0;",
            "ctx": {
                "type": "declaration",
                "name": "allowTimer",
                "value": "0",
                "string": "allowTimer",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "mediaOptions"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "summary": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var mediaOptions = {\n        optional: [\n            { DtlsSrtpKeyAgreement: true },\n            { RtpDataChannels: false }\n        ]\n    };",
            "ctx": {
                "type": "declaration",
                "name": "mediaOptions",
                "value": "{",
                "string": "mediaOptions",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "pc"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "type",
                    "types": [
                        "respoke.PeerConnection"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "summary": "<p>@memberof! respoke.RemoteMedia</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var pc = params.pc;\n    delete that.pc;",
            "ctx": {
                "type": "declaration",
                "name": "pc",
                "value": "params.pc",
                "string": "pc",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "name",
                    "string": "stream"
                },
                {
                    "type": "type",
                    "types": [
                        "RTCMediaStream"
                    ]
                }
            ],
            "description": {
                "full": "<p>The remote <code>MediaStream</code>.</p>\n",
                "summary": "<p>The remote <code>MediaStream</code>.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.stream = null;",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "stream",
                "value": "null",
                "string": "that.stream",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.hasVideo"
                },
                {
                    "type": "return",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Indicate whether we are receiving video.</p>\n",
                "summary": "<p>Indicate whether we are receiving video.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.hasVideo = function () {\n        if (that.stream) {\n            return (that.stream.getVideoTracks().length > 0);\n        }\n        return sdpHasVideo;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "hasVideo",
                "string": "that.hasVideo()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.hasAudio"
                },
                {
                    "type": "return",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Indicate whether we are receiving audio.</p>\n",
                "summary": "<p>Indicate whether we are receiving audio.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.hasAudio = function () {\n        if (that.stream) {\n            return (that.stream.getAudioTracks().length > 0);\n        }\n        return sdpHasAudio;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "hasAudio",
                "string": "that.hasAudio()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.hasMedia"
                },
                {
                    "type": "return",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Indicate whether we have media yet.</p>\n",
                "summary": "<p>Indicate whether we have media yet.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.hasMedia = function () {\n        return !!that.stream;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "hasMedia",
                "string": "that.hasMedia()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.setSDP"
                },
                {
                    "type": "param",
                    "types": [
                        "RTCSessionDescription"
                    ],
                    "name": "oSession",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Save and parse the SDP</p>\n",
                "summary": "<p>Save and parse the SDP</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.setSDP = function (oSession) {\n        sdpHasVideo = respoke.sdpHasVideo(oSession.sdp);\n        sdpHasAudio = respoke.sdpHasAudio(oSession.sdp);\n        sdpHasDataChannel = respoke.sdpHasDataChannel(oSession.sdp);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "setSDP",
                "string": "that.setSDP()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.setConstraints"
                },
                {
                    "type": "param",
                    "types": [
                        "MediaConstraints"
                    ],
                    "name": "constraints",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Parse the constraints.</p>\n",
                "summary": "<p>Parse the constraints.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.setConstraints = function (constraints) {\n        that.constraints = constraints;\n        sdpHasVideo = respoke.constraintsHasVideo(that.constraints);\n        sdpHasAudio = respoke.constraintsHasAudio(that.constraints);\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "setConstraints",
                "string": "that.setConstraints()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.setStream"
                },
                {
                    "type": "param",
                    "types": [
                        "MediaStream"
                    ],
                    "name": "str",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Save the media stream</p>\n",
                "summary": "<p>Save the media stream</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "that.setStream = function (str) {\n        if (str) {\n            that.stream = str;",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "setStream",
                "string": "that.setStream()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Expose getAudioTracks.</p>\n",
                "summary": "<p>Expose getAudioTracks.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getAudioTracks = that.stream.getAudioTracks.bind(that.stream);",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "getAudioTracks",
                "value": "that.stream.getAudioTracks.bind(that.stream)",
                "string": "that.getAudioTracks",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Expose getVideoTracks.</p>\n",
                "summary": "<p>Expose getVideoTracks.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getVideoTracks = that.stream.getVideoTracks.bind(that.stream);\n            that.element = that.element || document.createElement('video');\n            attachMediaStream(that.element, that.stream);\n            that.element.autoplay = true;\n            setTimeout(that.element.play.bind(that.element));\n        }\n    };",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "getVideoTracks",
                "value": "that.stream.getVideoTracks.bind(that.stream)",
                "string": "that.getVideoTracks",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.stop"
                },
                {
                    "type": "fires",
                    "string": "respoke.RemoteMedia#stop"
                }
            ],
            "description": {
                "full": "<p>Stop the stream.</p>\n",
                "summary": "<p>Stop the stream.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.RemoteMedia#stop"
            ],
            "ignore": false,
            "code": "that.stop = function () {\n        if (!that.stream) {\n            return;\n        }\n\n        that.stream.numPc -= 1;\n        if (that.stream.numPc === 0) {\n            that.stream.stop();\n            delete respoke.streams[that.constraints];\n        }\n        that.stream = null;",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "stop",
                "string": "that.stop()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.RemoteMedia"
                    ],
                    "name": "target",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>@event respoke.RemoteMedia#stop</p>\n",
                "summary": "<p>@event respoke.RemoteMedia#stop</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('stop');\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "returns",
                    "string": "boolean"
                }
            ],
            "description": {
                "full": "<p>Whether the video stream is muted.</p>\n<p>All video tracks must be muted for this to return <code>false</code>.</p>\n",
                "summary": "<p>Whether the video stream is muted.</p>\n",
                "body": "<p>All video tracks must be muted for this to return <code>false</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.isVideoMuted = function () {\n        if (!that.stream) {\n            return false;\n        }\n        return that.stream.getVideoTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "isVideoMuted",
                "string": "that.isVideoMuted()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.muteVideo"
                },
                {
                    "type": "fires",
                    "string": "respoke.RemoteMedia#mute"
                }
            ],
            "description": {
                "full": "<p>Mute remote video stream.</p>\n",
                "summary": "<p>Mute remote video stream.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.RemoteMedia#mute"
            ],
            "ignore": false,
            "code": "that.muteVideo = function () {\n        if (that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "muteVideo",
                "string": "that.muteVideo()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.RemoteMedia"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "type",
                    "description": "- Either \"audio\" or \"video\" to specify the type of stream whose muted state\nhas been changed."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "muted",
                    "description": "- Whether the stream is now muted. Will be set to false if mute was turned off."
                }
            ],
            "description": {
                "full": "<p>@event respoke.RemoteMedia#mute</p>\n",
                "summary": "<p>@event respoke.RemoteMedia#mute</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('mute', {\n            type: 'video',\n            muted: true\n        });\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.unmuteVideo"
                },
                {
                    "type": "fires",
                    "string": "respoke.RemoteMedia#mute"
                }
            ],
            "description": {
                "full": "<p>Unmute remote video stream.</p>\n",
                "summary": "<p>Unmute remote video stream.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.RemoteMedia#mute"
            ],
            "ignore": false,
            "code": "that.unmuteVideo = function () {\n        if (!that.isVideoMuted()) {\n            return;\n        }\n        that.stream.getVideoTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "unmuteVideo",
                "string": "that.unmuteVideo()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.RemoteMedia"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "type",
                    "description": "- Either \"audio\" or \"video\" to specify the type of stream whose muted state\nhas been changed."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "muted",
                    "description": "- Whether the stream is now muted. Will be set to false if mute was turned off."
                }
            ],
            "description": {
                "full": "<p>@event respoke.RemoteMedia#mute</p>\n",
                "summary": "<p>@event respoke.RemoteMedia#mute</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('mute', {\n            type: 'video',\n            muted: false\n        });\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "returns",
                    "string": "boolean"
                }
            ],
            "description": {
                "full": "<p>Whether the audio stream is muted.</p>\n<p>All audio tracks must be muted for this to return <code>false</code>.</p>\n",
                "summary": "<p>Whether the audio stream is muted.</p>\n",
                "body": "<p>All audio tracks must be muted for this to return <code>false</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.isAudioMuted = function () {\n        if (!that.stream) {\n            return false;\n        }\n        return that.stream.getAudioTracks().every(function (track) {\n            return !track.enabled;\n        });\n    };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "isAudioMuted",
                "string": "that.isAudioMuted()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.muteAudio"
                },
                {
                    "type": "fires",
                    "string": "respoke.RemoteMedia#mute"
                }
            ],
            "description": {
                "full": "<p>Mute remote audio stream.</p>\n",
                "summary": "<p>Mute remote audio stream.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.RemoteMedia#mute"
            ],
            "ignore": false,
            "code": "that.muteAudio = function () {\n        if (that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = false;\n        });",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "muteAudio",
                "string": "that.muteAudio()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.RemoteMedia"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "type",
                    "description": "- Either \"audio\" or \"video\" to specify the type of stream whose muted state\nhas been changed."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "muted",
                    "description": "- Whether the stream is now muted. Will be set to false if mute was turned off."
                }
            ],
            "description": {
                "full": "<p>@event respoke.RemoteMedia#mute</p>\n",
                "summary": "<p>@event respoke.RemoteMedia#mute</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('mute', {\n            type: 'audio',\n            muted: true\n        });\n    };",
            "ctx": {
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.RemoteMedia"
                },
                {
                    "type": "method",
                    "string": "respoke.RemoteMedia.unmuteAudio"
                },
                {
                    "type": "fires",
                    "string": "respoke.RemoteMedia#mute"
                }
            ],
            "description": {
                "full": "<p>Unmute remote audio stream.</p>\n",
                "summary": "<p>Unmute remote audio stream.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [
                "respoke.RemoteMedia#mute"
            ],
            "ignore": false,
            "code": "that.unmuteAudio = function () {\n        if (!that.isAudioMuted()) {\n            return;\n        }\n        that.stream.getAudioTracks().forEach(function eachTrack(track) {\n            track.enabled = true;\n        });",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "unmuteAudio",
                "string": "that.unmuteAudio()",
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "- the event name."
                },
                {
                    "type": "property",
                    "types": [
                        "respoke.RemoteMedia"
                    ],
                    "name": "target",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "type",
                    "description": "- Either \"audio\" or \"video\" to specify the type of stream whose muted state\nhas been changed."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "muted",
                    "description": "- Whether the stream is now muted. Will be set to false if mute was turned off."
                }
            ],
            "description": {
                "full": "<p>@event respoke.RemoteMedia#mute</p>\n",
                "summary": "<p>@event respoke.RemoteMedia#mute</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.fire('mute', {\n            type: 'audio',\n            muted: false\n        });\n    };\n\n    return that;\n}; // End respoke.RemoteMedia",
            "ctx": {
                "file": {
                    "input": "respoke/remoteMedia.js",
                    "output": ".docs/site/respoke/remoteMedia.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>lobal Bugsnag: true</p>\n",
                "summary": "<p>lobal Bugsnag: true</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>shint bitwise: false</p>\n",
                "summary": "<p>shint bitwise: false</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var log = require('loglevel');\nlog.setLevel('warn');\n\nvar Q = require('q');\nQ.longStackSupport = true;\nQ.stackJumpLimit = 5;\nQ.longStackJumpLimit = 20;\nQ.stopUnhandledRejectionTracking();\n\nrequire('./deps/adapter');",
            "ctx": {
                "type": "declaration",
                "name": "log",
                "value": "require('loglevel')",
                "string": "log",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        }
    ],
    "respoke": [
        {
            "tags": [
                {
                    "type": "namespace",
                    "string": "respoke"
                },
                {
                    "type": "class",
                    "string": "respoke"
                },
                {
                    "type": "global",
                    "string": ""
                },
                {
                    "type": "link",
                    "string": "https://cdn.respoke.io/respoke.min.js"
                }
            ],
            "description": {
                "full": "<p><code>respoke</code> is a global static class.</p>\n<p>Include the <a href=\"https://cdn.respoke.io/respoke.min.js\">latest version</a> or\n<a href=\"http://cdn.respoke.io/list.html\">choose a previous release</a>.</p>\n<p>Or use <code>npm install --save respoke</code>.</p>\n<p>Interact with Respoke primarily via <a href=\"respoke.Client.html\"><code>respoke.Client</code></a>:</p>\n<pre><code> var client = respoke.createClient();\n</code></pre><p><strong>Development mode without brokered auth</strong></p>\n<pre><code> var client = respoke.createClient({\n     appId: &quot;XXXXXXX-my-app-id-XXXXXX&quot;,\n     developmentMode: true,\n     endpointId: &quot;billy&quot;\n });\n\n client.listen(&#39;connect&#39;, function () {\n     console.log(&#39;connected to respoke!&#39;);\n });\n\n client.listen(&#39;error&#39;, function (err) {\n     console.error(&#39;Connection to Respoke failed.&#39;, err);\n });\n\n client.connect();\n</code></pre><p><strong>Production mode with brokered auth</strong></p>\n<pre><code> var client = respoke.createClient();\n\n client.listen(&#39;connect&#39;, function () {\n     console.log(&#39;connected to respoke!&#39;);\n });\n\n client.listen(&#39;error&#39;, function (err) {\n     console.error(&#39;Connection to Respoke failed.&#39;, err);\n });\n\n // Respoke auth token obtained by your server.\n // This is how you control who can connect to Respoke app.\n // See API docs for POST [base]/tokens\n var tokenId = &quot;XXXX-XXXX-brokered-auth-token-XXXXX&quot;;\n\n // connect to respoke with the token\n client.connect({\n     token: tokenId\n });\n\n // fetch a new token from your server if it expires\n client.listen(&#39;disconnect&#39;, function (evt) {\n     // fetch another token from your server.\n     var newTokenId = &quot;XXXX-XXXX-brokered-auth-token2-XXXXX&quot;;\n     client.connect({\n         token: newTokenId\n     });\n });\n</code></pre><h3 id=\"event-listeners-vs-callback-handlers\">Event listeners vs callback handlers</h3>\n<p>There are two ways to attach listeners. It is highly recommended that you choose one pattern\nand stick to it throughout your app.</p>\n<p>For every <code>event-name</code>, there is a corresponding callback <code>onEventName</code>.</p>\n<p><strong>With a listener</strong></p>\n<pre><code> var client = respoke.createClient();\n client.listen(&#39;connect&#39;, function () { });\n</code></pre><p><strong>or with a callback</strong></p>\n<pre><code> var client = respoke.createClient({\n     // other options go here\n\n     onConnect: function () { }\n });\n</code></pre>",
                "summary": "<p><code>respoke</code> is a global static class.</p>\n",
                "body": "<p>Include the <a href=\"https://cdn.respoke.io/respoke.min.js\">latest version</a> or\n<a href=\"http://cdn.respoke.io/list.html\">choose a previous release</a>.</p>\n<p>Or use <code>npm install --save respoke</code>.</p>\n<p>Interact with Respoke primarily via <a href=\"respoke.Client.html\"><code>respoke.Client</code></a>:</p>\n<pre><code> var client = respoke.createClient();\n</code></pre><p><strong>Development mode without brokered auth</strong></p>\n<pre><code> var client = respoke.createClient({\n     appId: &quot;XXXXXXX-my-app-id-XXXXXX&quot;,\n     developmentMode: true,\n     endpointId: &quot;billy&quot;\n });\n\n client.listen(&#39;connect&#39;, function () {\n     console.log(&#39;connected to respoke!&#39;);\n });\n\n client.listen(&#39;error&#39;, function (err) {\n     console.error(&#39;Connection to Respoke failed.&#39;, err);\n });\n\n client.connect();\n</code></pre><p><strong>Production mode with brokered auth</strong></p>\n<pre><code> var client = respoke.createClient();\n\n client.listen(&#39;connect&#39;, function () {\n     console.log(&#39;connected to respoke!&#39;);\n });\n\n client.listen(&#39;error&#39;, function (err) {\n     console.error(&#39;Connection to Respoke failed.&#39;, err);\n });\n\n // Respoke auth token obtained by your server.\n // This is how you control who can connect to Respoke app.\n // See API docs for POST [base]/tokens\n var tokenId = &quot;XXXX-XXXX-brokered-auth-token-XXXXX&quot;;\n\n // connect to respoke with the token\n client.connect({\n     token: tokenId\n });\n\n // fetch a new token from your server if it expires\n client.listen(&#39;disconnect&#39;, function (evt) {\n     // fetch another token from your server.\n     var newTokenId = &quot;XXXX-XXXX-brokered-auth-token2-XXXXX&quot;;\n     client.connect({\n         token: newTokenId\n     });\n });\n</code></pre><h3 id=\"event-listeners-vs-callback-handlers\">Event listeners vs callback handlers</h3>\n<p>There are two ways to attach listeners. It is highly recommended that you choose one pattern\nand stick to it throughout your app.</p>\n<p>For every <code>event-name</code>, there is a corresponding callback <code>onEventName</code>.</p>\n<p><strong>With a listener</strong></p>\n<pre><code> var client = respoke.createClient();\n client.listen(&#39;connect&#39;, function () { });\n</code></pre><p><strong>or with a callback</strong></p>\n<pre><code> var client = respoke.createClient({\n     // other options go here\n\n     onConnect: function () { }\n });\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var respoke = module.exports = {\n    buildNumber: 'NO BUILD NUMBER',\n    streams: [],\n    instances: {}\n};",
            "ctx": {
                "type": "declaration",
                "name": "respoke",
                "value": "module.exports = {",
                "string": "respoke",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p><code>&quot;v0.0.0&quot;</code></p>\n<p>The respoke.min.js version.</p>\n<p>Past versions can be found at <a href=\"http://cdn.respoke.io/list.html\">cdn.respoke.io/list.html</a></p>\n",
                "summary": "<p><code>&quot;v0.0.0&quot;</code></p>\n",
                "body": "<p>The respoke.min.js version.</p>\n<p>Past versions can be found at <a href=\"http://cdn.respoke.io/list.html\">cdn.respoke.io/list.html</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.version = respoke.buildNumber + \"\";\n\nrespoke.EventEmitter = require('./event');\nrespoke.Client = require('./client');\nrespoke.Presentable = require('./presentable');\nrespoke.Connection = require('./connection');\nrespoke.Endpoint = require('./endpoint');\nrespoke.TextMessage = require('./textMessage');\nrespoke.SignalingMessage = require('./signalingMessage');\nrespoke.Group = require('./group');\nrespoke.SignalingChannel = require('./signalingChannel');\nrespoke.DirectConnection = require('./directConnection');\nrespoke.PeerConnection = require('./peerConnection');\nrespoke.CallState = require('./callState');\nrespoke.Call = require('./call');\nrespoke.LocalMedia = require('./localMedia');\nrespoke.RemoteMedia = require('./remoteMedia');\nrespoke.log = log;\nrespoke.Q = Q;\n\nif (!window.skipBugsnag) {\n    // Use airbrake.\n    var airbrake = document.createElement('script');\n    var first = document.getElementsByTagName('script')[0];\n    first.parentNode.insertBefore(airbrake, first);\n\n    airbrake.src = \"https://ssljscdn.airbrake.io/0.3/airbrake.min.js\";\n    airbrake.setAttribute('data-airbrake-project-id', '98133');\n    airbrake.setAttribute('data-airbrake-project-key', 'cd3e085acc5e554658ebcdabd112a6f4');\n    airbrake.setAttribute('data-airbrake-project-environment-name', 'production');\n\n    airbrake.onload = function () {\n        window.onerror = function (message, file, line) {\n            //Only send errors from the respoke.js file to Airbrake\n            if (file.match(/respoke/)) {\n                Airbrake.push({error: {message: message, fileName: file, lineNumber: line}});\n            }\n        };\n    };\n}",
            "ctx": {
                "type": "property",
                "receiver": "respoke",
                "name": "version",
                "value": "respoke.buildNumber + \"\"",
                "string": "respoke.version",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": "Parameters to the respoke.Client constructor."
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.appId]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.baseURL]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "[params.token]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string",
                        "number",
                        "object",
                        "Array"
                    ],
                    "name": "[params.presence]",
                    "description": "The initial presence to set once connected."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.developmentMode=false]",
                    "description": "- Indication to obtain an authentication token from the service.\nNote: Your app must be in developer mode to use this feature. This is not intended as a long-term mode of\noperation and will limit the services you will be able to use."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.reconnect=false]",
                    "description": "- Whether or not to automatically reconnect to the Respoke service\nwhen a disconnect occurs."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this invocation of this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "[params.onJoin]",
                    "description": "- Callback for when this client's endpoint joins a group."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "[params.onLeave]",
                    "description": "- Callback for when this client's endpoint leaves a group."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "[params.onMessage]",
                    "description": "- Callback for when any message is received from anywhere on the system."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "[params.onDisconnect]",
                    "description": "- Callback for Client disconnect."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "[params.onReconnect]",
                    "description": "- Callback for Client reconnect. Not Implemented."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "[params.onCall]",
                    "description": "- Callback for when this client's user receives a call."
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "[params.onDirectConnection]",
                    "description": "- Callback for when this client's user receives a request for a\ndirect connection."
                },
                {
                    "type": "param",
                    "types": [
                        "boolean"
                    ],
                    "name": "[params.enableCallDebugReport=true]",
                    "description": "- Optional flag defaulting to true which allows sending\ndebugging information."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Client}"
                }
            ],
            "description": {
                "full": "<p>This is one of two possible entry points for interating with the library.</p>\n<p>This method creates a new Client object\nwhich represents your user&#39;s connection to your Respoke app.</p>\n<p>This method <strong>automatically calls client.connect(params)</strong> after the client is created.</p>\n",
                "summary": "<p>This is one of two possible entry points for interating with the library.</p>\n",
                "body": "<p>This method creates a new Client object\nwhich represents your user&#39;s connection to your Respoke app.</p>\n<p>This method <strong>automatically calls client.connect(params)</strong> after the client is created.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.connect = function (params) {\n    var client = respoke.Client(params);\n    client.connect(params);\n    return client;\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "connect",
                "string": "respoke.connect()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "param",
                    "types": [
                        "number"
                    ],
                    "name": "id",
                    "description": "The Client ID."
                },
                {
                    "type": "returns",
                    "string": "{respoke.Client}"
                }
            ],
            "description": {
                "full": "<p>Getter for the respoke client.</p>\n<p>You can have more than one active client, so this method provides a way to retrieve a specific instance.</p>\n",
                "summary": "<p>Getter for the respoke client.</p>\n",
                "body": "<p>You can have more than one active client, so this method provides a way to retrieve a specific instance.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.getClient = function (id) {\n    if (id === undefined) {\n        log.debug(\"Can't call getClient with no client ID.\", new Error().stack);\n    }\n    if (!respoke.instances[id]) {\n        log.debug(\"No client instance with id\", id);\n    }\n    return respoke.instances[id];\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "getClient",
                "string": "respoke.getClient()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": "Parameters to respoke.Client - same as respoke.connect()"
                },
                {
                    "type": "returns",
                    "string": "{respoke.Client}"
                }
            ],
            "description": {
                "full": "<p>This is one of two possible entry points for interating with the library.</p>\n<p>This method creates a new Client object which represents your user&#39;s connection to your Respoke app.</p>\n<p>It <strong>does NOT automatically call the client.connect() method</strong> after the client is created.</p>\n<p>The <code>params</code> argument is the same as <code>respoke.connect(params)</code>.</p>\n",
                "summary": "<p>This is one of two possible entry points for interating with the library.</p>\n",
                "body": "<p>This method creates a new Client object which represents your user&#39;s connection to your Respoke app.</p>\n<p>It <strong>does NOT automatically call the client.connect() method</strong> after the client is created.</p>\n<p>The <code>params</code> argument is the same as <code>respoke.connect(params)</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.createClient = function (params) {\n    var client;\n    params = params || {};\n    if (params.instanceId) {\n        client = respoke.getClient(params.instanceId);\n        if (client) {\n            return client;\n        }\n    }\n    return respoke.Client(params);\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "createClient",
                "string": "respoke.createClient()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "func",
                    "description": ""
                },
                {
                    "type": "return",
                    "string": "{function}"
                }
            ],
            "description": {
                "full": "<p>Build a closure from a listener that will ensure the listener can only be called once.</p>\n",
                "summary": "<p>Build a closure from a listener that will ensure the listener can only be called once.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "respoke.once = function (func) {\n    return (function () {\n        var called = false;\n        return function () {\n            if (called === false) {\n                func.apply(null, arguments);\n                called = true;\n            }\n        };\n    })();\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "once",
                "string": "respoke.once()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "returns",
                    "string": "{number}"
                }
            ],
            "description": {
                "full": "<p>@static</p>\n",
                "summary": "<p>@static</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "respoke.makeGUID = function () {\n    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n    var uuid = new Array(36);\n    var rnd = 0;\n    var r;\n    for (var i = 0; i < 36; i += 1) {\n        if (i === 8 || i === 13 ||  i === 18 || i === 23) {\n            uuid[i] = '-';\n        } else if (i === 14) {\n            uuid[i] = '4';\n        } else {\n            if (rnd <= 0x02) {\n                rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\n            }\n            r = rnd & 0xf;\n            rnd = rnd >> 4;\n            uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];\n        }\n    }\n    return uuid.join('');\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "makeGUID",
                "string": "respoke.makeGUID()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "param",
                    "types": [
                        "Promise"
                    ],
                    "name": "promise",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "onSuccess",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "function"
                    ],
                    "name": "onError",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{Promise|undefined}"
                }
            ],
            "description": {
                "full": "<p>This method is used internally to attach handlers to promises that are returned by many methods in the library.\nIt&#39;s not recommended that this method be used by developers and apps.</p>\n",
                "summary": "<p>This method is used internally to attach handlers to promises that are returned by many methods in the library.\nIt&#39;s not recommended that this method be used by developers and apps.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "respoke.handlePromise = function (promise, onSuccess, onError) {\n    var returnUndef = false;\n    if (onSuccess || onError) {\n        returnUndef = true;\n    }\n\n    onSuccess = typeof onSuccess === 'function' ? onSuccess : function () {};\n    onError = typeof onError === 'function' ? onError : function () {};\n    promise.done(onSuccess, onError);\n    return (returnUndef ? undefined : promise);\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "handlePromise",
                "string": "respoke.handlePromise()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.Class"
                },
                {
                    "type": "classdesc",
                    "string": "Empty base class."
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Empty base class. Use params.that (if exists) for the base object, but delete it from the instance.  Copy all\nparams that were passed in onto the base object. Add the class name.</p>\n",
                "summary": "<p>Empty base class. Use params.that (if exists) for the base object, but delete it from the instance.  Copy all\nparams that were passed in onto the base object. Add the class name.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "respoke.Class = function (params) {\n    params = params || {};\n    var that = params.that || {};\n    var client = params.client;\n\n    that.className = 'respoke.Class';\n    delete params.that;\n    delete that.client;\n\n    Object.keys(params).forEach(function copyParam(name) {\n        that[name] = params[name];\n    });\n\n    return that;\n}; // end of respoke.Class",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "Class",
                "string": "respoke.Class()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Does the browser support <code>UserMedia</code>?</p>\n",
                "summary": "<p>Does the browser support <code>UserMedia</code>?</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.hasUserMedia = function () {\n    return (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) instanceof Function;\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "hasUserMedia",
                "string": "respoke.hasUserMedia()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Does the browser support <code>RTCPeerConnection</code>?</p>\n",
                "summary": "<p>Does the browser support <code>RTCPeerConnection</code>?</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.hasRTCPeerConnection = function () {\n    return (window.RTCPeerConnection || window.webkitRTCPeerConnection ||\n            window.mozRTCPeerConnection) instanceof Function;\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "hasRTCPeerConnection",
                "string": "respoke.hasRTCPeerConnection()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Does the browser support <code>WebSocket</code>?</p>\n",
                "summary": "<p>Does the browser support <code>WebSocket</code>?</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.hasWebsocket = function () {\n    return (window.WebSocket || window.webkitWebSocket || window.MozWebSocket) instanceof Function;\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "hasWebsocket",
                "string": "respoke.hasWebsocket()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "param",
                    "types": [
                        "Object"
                    ],
                    "name": "source",
                    "description": "- The object to clone"
                },
                {
                    "type": "returns",
                    "string": "{Object}"
                }
            ],
            "description": {
                "full": "<p>Clone an object.</p>\n",
                "summary": "<p>Clone an object.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.clone = function (source) {\n    if (source) {\n        return JSON.parse(JSON.stringify(source));\n    }\n    return source;\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "clone",
                "string": "respoke.clone()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "param",
                    "types": [
                        "Object"
                    ],
                    "name": "a",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "Object"
                    ],
                    "name": "b",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Compares two objects for equality</p>\n",
                "summary": "<p>Compares two objects for equality</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.isEqual = function (a, b) {\n    var aKeys;\n\n    //check if arrays\n    if (a.hasOwnProperty('length') && b.hasOwnProperty('length') && a.splice && b.splice) {\n        if (a.length !== b.length) {\n            //short circuit if arrays are different length\n            return false;\n        }\n\n        for (var i = 0; i < a.length; i += 1) {\n            if (!respoke.isEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    if (typeof a === 'object' && typeof b === 'object') {\n        aKeys = Object.keys(a);\n        for (var i = 0; i < aKeys.length; i += 1) {\n            if (!respoke.isEqual(a[aKeys[i]], b[aKeys[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    return a === b;\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "isEqual",
                "string": "respoke.isEqual()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "params",
                    "string": "{RTCSessionDescription}"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Does the sdp indicate an audio stream?</p>\n",
                "summary": "<p>Does the sdp indicate an audio stream?</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.sdpHasAudio = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasAudio called with no parameters.\");\n    }\n    return sdp.indexOf('m=audio') !== -1;\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "sdpHasAudio",
                "string": "respoke.sdpHasAudio()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "params",
                    "string": "{RTCSessionDescription}"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Does the sdp indicate a video stream?</p>\n",
                "summary": "<p>Does the sdp indicate a video stream?</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.sdpHasVideo = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasVideo called with no parameters.\");\n    }\n    return sdp.indexOf('m=video') !== -1;\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "sdpHasVideo",
                "string": "respoke.sdpHasVideo()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "params",
                    "string": "{RTCSessionDescription}"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Does the sdp indicate a data channel?</p>\n",
                "summary": "<p>Does the sdp indicate a data channel?</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.sdpHasDataChannel = function (sdp) {\n    if (!sdp) {\n        throw new Error(\"respoke.sdpHasDataChannel called with no parameters.\");\n    }\n    return sdp.indexOf('m=application') !== -1;\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "sdpHasDataChannel",
                "string": "respoke.sdpHasDataChannel()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "params",
                    "string": "{MediaConstraints}"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Does the sdp indicate an audio stream?</p>\n",
                "summary": "<p>Does the sdp indicate an audio stream?</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.constraintsHasAudio = function (constraints) {\n    if (!constraints) {\n        throw new Error(\"respoke.constraintsHasAudio called with no parameters.\");\n    }\n    return (constraints.audio === true);\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "constraintsHasAudio",
                "string": "respoke.constraintsHasAudio()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "static",
                    "string": ""
                },
                {
                    "type": "memberof",
                    "string": "respoke"
                },
                {
                    "type": "params",
                    "string": "{MediaConstraints}"
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                }
            ],
            "description": {
                "full": "<p>Does the constraints indicate a video stream?</p>\n",
                "summary": "<p>Does the constraints indicate a video stream?</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.constraintsHasVideo = function (constraints) {\n    if (!constraints) {\n        throw new Error(\"respoke.constraintsHasVideo called with no parameters.\");\n    }\n    return (constraints.video === true || typeof constraints.video === 'object');\n};",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "constraintsHasVideo",
                "string": "respoke.constraintsHasVideo()",
                "file": {
                    "input": "respoke/respoke.js",
                    "output": ".docs/site/respoke/respoke.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global define: false, respoke: false</p>\n",
                "summary": "<p>global define: false, respoke: false</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "ignore",
                    "string": ""
                }
            ],
            "description": {
                "full": "<p>Copyright (c) 2014, D.C.S. LLC. All Rights Reserved. Licensed Software.</p>\n",
                "summary": "<p>Copyright (c) 2014, D.C.S. LLC. All Rights Reserved. Licensed Software.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "// UMD wrapper to provide support for CommonJS, AMD, and browser globals\n(function (factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['respoke'], factory);\n    } else if (typeof exports === 'object') {\n        // Node/CommonJS\n        factory(require('respoke'));\n    } else {\n        // Browser globals\n        factory(respoke);\n    }\n}(function (respoke) {\n    \"use strict\";",
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        }
    ],
    "respoke.MediaStats": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "link",
                    "string": "https://cdn.respoke.io/respoke-stats.min.js"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "params",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>A report containing statistical information about the flow of media with the latest live statistics.</p>\n<p>This is a <strong>plugin</strong> for respoke. To leverage it, include <code>&lt;script src=&quot;https://cdn.respoke.io/respoke-stats.min.js&quot;&gt;&lt;/script&gt;</code>.</p>\n<p>The plugin adds the methods <code>getStats()</code> and <code>stopStats()</code> to <code>respoke.Call</code>.</p>\n<h2 id=\"usage\">Usage</h2>\n<p>Once you have a <code>Call</code> instance after <code>endpoint.startCall()</code> or in the <code>client.on(&#39;call&#39;)</code> / <code>new Client({ onCall: yourCallHandler })</code> event listener:</p>\n<p><strong>using callbacks</strong></p>\n<pre><code> call.getStats({\n     onStats: function continualStatsHandler(evt) { . . . },\n     onSuccess: yourOnSuccessHandler,\n     onError: yourOnErrorHandler \n });\n</code></pre><p><strong>or using a promise</strong></p>\n<pre><code> call.getStats({\n     onStats: function continualStatsHandler(evt) { . . . },\n }).done(onSuccess, onFailure);\n</code></pre>",
                "summary": "<p>A report containing statistical information about the flow of media with the latest live statistics.</p>\n",
                "body": "<p>This is a <strong>plugin</strong> for respoke. To leverage it, include <code>&lt;script src=&quot;https://cdn.respoke.io/respoke-stats.min.js&quot;&gt;&lt;/script&gt;</code>.</p>\n<p>The plugin adds the methods <code>getStats()</code> and <code>stopStats()</code> to <code>respoke.Call</code>.</p>\n<h2 id=\"usage\">Usage</h2>\n<p>Once you have a <code>Call</code> instance after <code>endpoint.startCall()</code> or in the <code>client.on(&#39;call&#39;)</code> / <code>new Client({ onCall: yourCallHandler })</code> event listener:</p>\n<p><strong>using callbacks</strong></p>\n<pre><code> call.getStats({\n     onStats: function continualStatsHandler(evt) { . . . },\n     onSuccess: yourOnSuccessHandler,\n     onError: yourOnErrorHandler \n });\n</code></pre><p><strong>or using a promise</strong></p>\n<pre><code> call.getStats({\n     onStats: function continualStatsHandler(evt) { . . . },\n }).done(onSuccess, onFailure);\n</code></pre>"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "respoke.MediaStats = function (params) {\n        params = JSON.parse(JSON.stringify(params || {}));",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "respoke.MediaStats",
                "string": "respoke.MediaStats()",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                },
                {
                    "type": "name",
                    "string": "connection"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "channelId",
                    "description": "- A string which identifies this media stream (which may contain several\nmedia stream tracks) to the browser."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "foundIncomingNetworkPaths",
                    "description": "- Whether or not the ICE hole-punching process has found\na suitable network path from the remote party to this client."
                },
                {
                    "type": "property",
                    "types": [
                        "boolean"
                    ],
                    "name": "foundOutgoingNetworkPaths",
                    "description": "- Whether or not the ICE hole-punching process has found\na suitable network path from this client to the remote party."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "localHost",
                    "description": "- The local IP and port number of the media connection."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "remoteHost",
                    "description": "- The remote IP and port number of the media connection."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "localMediaPath",
                    "description": "- The type of network path the local media is taking to the remote\nparty, one of \"local\", \"srflx\", \"prflx\", \"relay\"."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "remoteMediaPath",
                    "description": "- The type of network path the local media is taking to the remote\nparty, one of \"local\", \"srflx\", \"prflx\", \"relay\"."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "roundTripTime",
                    "description": "- How long it takes media packets to traverse the network path."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "transport",
                    "description": "- Whether the media is flowing via UDP or TCP"
                }
            ],
            "description": {
                "full": "<p>Information about the connection.</p>\n",
                "summary": "<p>Information about the connection.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                },
                {
                    "type": "name",
                    "string": "localaudio"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "audioInputLevel",
                    "description": "- Microphone volume."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "codec",
                    "description": "- Audio codec in use."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "totalBytesSent",
                    "description": "- Total number of bytes sent since media first began flowing."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "periodBytesSent",
                    "description": "- Number of bytes sent since the last stats event."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "totalPacketsSent",
                    "description": "- Total number of packets sent since media first began flowing."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "periodPacketsSent",
                    "description": "- Number of packets sent since the last stats event."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "transportId",
                    "description": "- The identifer of the media stream to which this media stream track belongs."
                }
            ],
            "description": {
                "full": "<p>Information about the local audio stream track.</p>\n",
                "summary": "<p>Information about the local audio stream track.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                },
                {
                    "type": "name",
                    "string": "localvideo"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "codec",
                    "description": "- Video codec in use."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "totalBytesSent",
                    "description": "- Total number of bytes sent since media first began flowing."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "periodBytesSent",
                    "description": "- Number of bytes sent since the last stats event."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "totalPacketsSent",
                    "description": "- Total number of packets sent since media first began flowing."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "periodPacketsSent",
                    "description": "- Number of packets sent since the last stats event."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "transportId",
                    "description": "- The identifer of the media stream to which this media stream track belongs."
                }
            ],
            "description": {
                "full": "<p>Information about the local video stream track.</p>\n",
                "summary": "<p>Information about the local video stream track.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                },
                {
                    "type": "name",
                    "string": "remoteaudio"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "audioOutputLevel",
                    "description": ""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "totalBytesReceived",
                    "description": "- Total number of bytes received since media first began flowing."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "periodBytesReceived",
                    "description": "- Number of bytes received since the last stats event."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "packetsLost",
                    "description": "- Total number of packets lost."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "totalPacketsReceived",
                    "description": "- Total number of packets received since media first began flowing."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "periodPacketsReceived",
                    "description": "- Number of packets received since the last stats event."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "transportId",
                    "description": "- The identifer of the media stream to which this media stream track\nbelongs."
                }
            ],
            "description": {
                "full": "<p>Information about the remote audio stream track.</p>\n",
                "summary": "<p>Information about the remote audio stream track.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                },
                {
                    "type": "name",
                    "string": "remotevideo"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "totalBytesReceived",
                    "description": "- Total number of bytes received since media first began flowing."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "periodBytesReceived",
                    "description": "- Number of bytes received since the last stats event."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "packetsLost",
                    "description": "- Total number of packets lost."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "totalPacketsReceived",
                    "description": "- Total number of packets received since media first began flowing."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "periodPacketsReceived",
                    "description": "- Number of packets received since the last stats event."
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "transportId",
                    "description": "- The identifer of the media stream to which this media stream track belongs."
                }
            ],
            "description": {
                "full": "<p>Information about the remote video stream track.</p>\n",
                "summary": "<p>Information about the remote video stream track.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                },
                {
                    "type": "name",
                    "string": "state"
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "iceConnectionState",
                    "description": "- Indicates where we are in terms of ICE network negotiation -- \"hole\npunching.\""
                },
                {
                    "type": "property",
                    "types": [
                        "string"
                    ],
                    "name": "iceGatheringState",
                    "description": "- Indicates whether we have started or finished gathering ICE\ncandidates from the browser."
                }
            ],
            "description": {
                "full": "<p>Information about connection state.</p>\n",
                "summary": "<p>Information about connection state.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "name",
                    "string": "timestamp"
                },
                {
                    "type": "type",
                    "types": [
                        "date"
                    ]
                }
            ],
            "description": {
                "full": "<p>The date and time at which this stats snapshot was taken.</p>\n",
                "summary": "<p>The date and time at which this stats snapshot was taken.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "name",
                    "string": "periodLength"
                },
                {
                    "type": "type",
                    "types": [
                        "number"
                    ]
                }
            ],
            "description": {
                "full": "<p>The time that has passed since the last stats snapshot was taken.</p>\n",
                "summary": "<p>The time that has passed since the last stats snapshot was taken.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "name",
                    "string": "aliases"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                }
            ],
            "description": {
                "full": "<p>These aliases define what things should be renamed before report is sent.</p>\n",
                "summary": "<p>These aliases define what things should be renamed before report is sent.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var aliases = {\n            cons: {\n                newname: 'connection',\n                members: {\n                    googChannelId: 'channelId',\n                    googLocalAddress: 'localHost',\n                    googRemoteAddress: 'remoteHost',\n                    googLocalCandidateType: 'localMediaPath',\n                    googRemoteCandidateType: 'remoteMediaPath',\n                    googReadable: 'foundIncomingNetworkPaths',\n                    googRtt: 'roundTripTime',\n                    googTransportType: 'transport',\n                    googWritable: 'foundOutgoingNetworkPaths'\n                }\n            },\n            localaudio: {\n                members: {\n                    googCodecName: 'codec',\n                    bytesSent: 'totalBytesSent',\n                    packetsSent: 'totalPacketsSent'\n                }\n            },\n            localvideo: {\n                members: {\n                    googCodecName: 'codec',\n                    bytesSent: 'totalBytesSent',\n                    packetsSent: 'totalPacketsSent'\n                }\n            },\n            remoteaudio: {\n                members: {\n                    googCodecName: 'codec',\n                    bytesReceived: 'totalBytesReceived',\n                    packetsReceived: 'totalPacketsReceived'\n                }\n            },\n            remotevideo: {\n                members: {\n                    googCodecName: 'codec',\n                    bytesReceived: 'totalBytesReceived',\n                    packetsReceived: 'totalPacketsReceived'\n                }\n            }\n        };",
            "ctx": {
                "type": "declaration",
                "name": "aliases",
                "value": "{",
                "string": "aliases",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStats"
                },
                {
                    "type": "method",
                    "string": "respoke.MediaStats.format"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "report",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "aliases",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{object}"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Rename report attributes to have more readable, understandable names.</p>\n",
                "summary": "<p>Rename report attributes to have more readable, understandable names.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function format(report, aliases) {\n            Object.keys(aliases).forEach(function eachAttr(oldName) {\n                var name;\n                if (typeof aliases[oldName] === 'string') {\n                    report[aliases[oldName]] = report[oldName];\n                    delete report[oldName];\n                } else if (typeof aliases[oldName] === 'object') {\n                    name = oldName;\n                    if (aliases[oldName].newname) {\n                        report[aliases[oldName].newname] = report[oldName];\n                        name = aliases[oldName].newname;\n                        delete report[oldName];\n                    }\n                    if (aliases[oldName].members) {\n                        format(report[name], aliases[oldName].members);\n                    }\n                }\n            });\n\n            if (report.connection) {\n                report.connection.foundIncomingNetworkPaths = ('true' === report.connection.foundIncomingNetworkPaths);\n                report.connection.foundOutgoingNetworkPaths = ('true' === report.connection.foundOutgoingNetworkPaths);\n            }\n            return report;\n        }\n        return format(params, aliases);\n    }; // End respoke.MediaStats",
            "ctx": {
                "type": "function",
                "name": "format",
                "string": "format()",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "class",
                    "string": "respoke.MediaStatsParser"
                },
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "augments",
                    "otherClass": "respoke.Class"
                },
                {
                    "type": "param",
                    "types": [
                        "RTCPeerConnection"
                    ],
                    "name": "peerConnection",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>A handler for WebRTC statistics. This class takes an <code>onStats</code> callback which it calls every <code>interval</code> seconds\nwith the latest live statistics.</p>\n",
                "summary": "<p>A handler for WebRTC statistics. This class takes an <code>onStats</code> callback which it calls every <code>interval</code> seconds\nwith the latest live statistics.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "respoke.MediaStatsParser = function (params) {\n        params = params || {};\n        var that = respoke.Class(params);",
            "ctx": {
                "type": "method",
                "receiver": "respoke",
                "name": "MediaStatsParser",
                "string": "respoke.MediaStatsParser()",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "name",
                    "string": "className"
                },
                {
                    "type": "type",
                    "types": [
                        "string"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "summary": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.className = 'respoke.MediaStatsParser';",
            "ctx": {
                "type": "property",
                "receiver": "that",
                "name": "className",
                "value": "'respoke.MediaStatsParser'",
                "string": "that.className",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "name",
                    "string": "oldStats"
                },
                {
                    "type": "type",
                    "types": [
                        "boolean"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "summary": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var oldStats = false;",
            "ctx": {
                "type": "declaration",
                "name": "oldStats",
                "value": "false",
                "string": "oldStats",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "name",
                    "string": "pc"
                },
                {
                    "type": "type",
                    "types": [
                        "RTCPeerConnection"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "summary": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var pc = params.peerConnection;\n        delete params.peerConnection;",
            "ctx": {
                "type": "declaration",
                "name": "pc",
                "value": "params.peerConnection",
                "string": "pc",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "name",
                    "string": "timer"
                },
                {
                    "type": "type",
                    "types": [
                        "number"
                    ]
                },
                {
                    "type": "desc",
                    "string": "The timer for calling the onStats callback; the output of setInterval."
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "summary": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var timer = 0;",
            "ctx": {
                "type": "declaration",
                "name": "timer",
                "value": "0",
                "string": "timer",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "name",
                    "string": "statsInterval"
                },
                {
                    "type": "type",
                    "types": [
                        "number"
                    ]
                },
                {
                    "type": "desc",
                    "string": "The millisecond interval on which we call the onStats callback."
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "summary": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var statsInterval = params.interval || 5000;",
            "ctx": {
                "type": "declaration",
                "name": "statsInterval",
                "value": "params.interval || 5000",
                "string": "statsInterval",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The data you get out of getStats needs some pruning and a tidy up\nso I define some things I think are &#39;interesting&#39; and how to find them.</p>\n<p>getStats gives you an array of results each of which has a type.\nEach result contains a list of keys and a dictionary of values that can\nbe retrieved by key. (no ,they aren&#39;t properties)</p>\n<p>The interesting stats object is a list of objects, each describing the\ntype of result that contains the stats, the names of the relevant stats\nand a way to filter out the irrelevant results objects of the same type.</p>\n<p>An added complication is that the standards are in flux so google add\ndata in chrome (some of it useful) that isn;t in the draft standard.</p>\n",
                "summary": "<p>The data you get out of getStats needs some pruning and a tidy up\nso I define some things I think are &#39;interesting&#39; and how to find them.</p>\n",
                "body": "<p>getStats gives you an array of results each of which has a type.\nEach result contains a list of keys and a dictionary of values that can\nbe retrieved by key. (no ,they aren&#39;t properties)</p>\n<p>The interesting stats object is a list of objects, each describing the\ntype of result that contains the stats, the names of the relevant stats\nand a way to filter out the irrelevant results objects of the same type.</p>\n<p>An added complication is that the standards are in flux so google add\ndata in chrome (some of it useful) that isn;t in the draft standard.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "name",
                    "string": "interestingStats"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "summary": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var interestingStats = {\n            cons: {\n                type: \"googCandidatePair\",\n                match: {key: \"googActiveConnection\", value: \"true\"},\n                keys: [\n                    \"googWritable\", \"googReadable\", \"googTransportType\", \"googLocalCandidateType\",\n                    \"googRemoteCandidateType\", \"googRemoteAddress\", \"googLocalAddress\", \"googRtt\", \"googChannelId\"\n                ]\n            },\n            // the next 4 property names _matter_ they have to finish with the value of an m= line\n            // if you change them things won't work.\n            localaudio: {\n                type: \"ssrc\",\n                match: {key: \"ssrc\", value: \"\"},\n                keys: [\"audioInputLevel\", \"packetsSent\", \"bytesSent\", \"transportId\", \"googCodecName\"]\n            },\n            remoteaudio: {\n                type: \"ssrc\",\n                match: {key: \"ssrc\", value: \"\"},\n                keys: [\"audioOutputLevel\", \"packetsReceived\", \"packetsLost\", \"bytesReceived\", \"transportId\"]\n            },\n            remotevideo: {\n                type: \"ssrc\",\n                match: {key: \"ssrc\", value: \"\"},\n                keys: [\"packetsReceived\", \"packetsLost\", \"bytesReceived\", \"transportId\"]\n            },\n            localvideo: {\n                type: \"ssrc\",\n                match: {key: \"ssrc\", value: \"\"},\n                keys: [\"packetsSent\", \"bytesSent\", \"transportId\", \"googCodecName\"]\n            }\n        };",
            "ctx": {
                "type": "declaration",
                "name": "interestingStats",
                "value": "{",
                "string": "interestingStats",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "private",
                    "visibility": "private"
                },
                {
                    "type": "name",
                    "string": "deltas"
                },
                {
                    "type": "type",
                    "types": [
                        "object"
                    ]
                }
            ],
            "description": {
                "full": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "summary": "<p>@memberof! respoke.MediaStatsParser</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "var deltas = {\n            packetsSent: true,\n            bytesSent: true,\n            packetsReceived: true,\n            bytesReceived: true\n        };",
            "ctx": {
                "type": "declaration",
                "name": "deltas",
                "value": "{",
                "string": "deltas",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStatsParser"
                },
                {
                    "type": "method",
                    "string": "respoke.MediaStatsParser.startsWith"
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "string",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "string"
                    ],
                    "name": "value",
                    "description": ""
                },
                {
                    "type": "returns",
                    "string": "{boolean}"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Determine if a string starts with the given value.</p>\n",
                "summary": "<p>Determine if a string starts with the given value.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function startsWith(string, value) {\n            return (string && string.slice && (string.slice(0, value.length) === value));\n        }",
            "ctx": {
                "type": "function",
                "name": "startsWith",
                "string": "startsWith()",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStatsParser"
                },
                {
                    "type": "method",
                    "string": "respoke.MediaStatsParser.initStats"
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Parse the SDPs. Kick off continuous calling of getStats() every <code>interval</code> milliseconds.</p>\n",
                "summary": "<p>Parse the SDPs. Kick off continuous calling of getStats() every <code>interval</code> milliseconds.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function initStats() {\n            var sdp = {};\n            if (!pc || !pc.remoteDescription || !pc.remoteDescription.sdp ||\n                !pc.localDescription || !pc.localDescription.sdp) {\n                respoke.log.warn(\"missing info.\");\n                return;\n            }\n\n            sdp = {\n                remote: pc.remoteDescription.sdp,\n                local: pc.localDescription.sdp\n            };",
            "ctx": {
                "type": "function",
                "name": "initStats",
                "string": "initStats()",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>extract the ssrcs from the sdp, because it isn&#39;t anwhere else.\nwe will use them to map results to audio/video etc</p>\n",
                "summary": "<p>extract the ssrcs from the sdp, because it isn&#39;t anwhere else.\nwe will use them to map results to audio/video etc</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "Object.keys(sdp).forEach(function eachKey(side) {\n                var rsdp = sdp[side];\n                // filet the sdp\n                var lines = rsdp.split(\"\\r\\n\");\n                var mediaType = null;\n\n                Object.keys(lines).forEach(function lineNum(lineIndex) {\n                    var line = lines[lineIndex];\n                    var lbits = null;\n                    var ssrc = null;\n\n                    if (startsWith(line, \"m=\")) { // take a note of the sort of media we are looking at\n                        mediaType = line.substring(2, 7); // should be either 'audio' or 'video'\n                    } else if (startsWith(line, \"a=ssrc:\")) {\n                        lbits = line.split(\" \");\n                        ssrc = lbits[0].substring(\"a=ssrc:\".length);\n\n                        if (interestingStats[side + mediaType]) {\n                            // fill in the value of the respective 'match'\n                            // build the name of the stat from parts\n                            if (interestingStats[side + mediaType].match.value.length === 0){\n                                interestingStats[side + mediaType].match.value = ssrc;\n                            }\n                        }\n                    }\n                });\n            });\n\n            if (params.onStats) {\n                timer = setInterval(function statsTimerHandler() {\n                    that.getStats().done(params.onStats, function errorHandler(err) {\n                        respoke.log.error(\"error in getStats\", err.message, err.stack);\n                    });\n                }, statsInterval);\n            } else {\n                respoke.log.warn(\"Not starting stats, no onStats callback provided.\");\n            }\n        }",
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStatsParser"
                },
                {
                    "type": "method",
                    "string": "respoke.MediaStatsParser.getStats"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "[params]",
                    "description": ""
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onSuccess]",
                    "description": "- Success handler for this\ninvocation of this method only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.Client.errorHandler"
                    ],
                    "name": "[params.onError]",
                    "description": "- Error handler for this invocation of this\nmethod only."
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStatsParser.statsHandler"
                    ],
                    "name": "[params.onStats]",
                    "description": "- Callback accepting a single `event` argument."
                },
                {
                    "type": "returns",
                    "string": "{Promise<object>|undefined}"
                }
            ],
            "description": {
                "full": "<p>Get one snapshot of stats from the call&#39;s PeerConnection.</p>\n",
                "summary": "<p>Get one snapshot of stats from the call&#39;s PeerConnection.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.getStats = function (params) {\n            params = params || {};\n            var deferred = respoke.Q.defer();\n            var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n            var args = [];\n\n            if (!pc.getStats) {\n                deferred.reject(new Error(\"no peer connection getStats()\"));\n                return retVal;\n            }\n\n            if (navigator.mozGetUserMedia) {\n                args.push(null);\n            }\n\n            args.push(function successHandler(stats) {\n                deferred.resolve(respoke.MediaStats(buildStats(stats)));\n            });\n            args.push(function errorHandler(err) {\n                respoke.log.error(err);\n                deferred.reject(new Error(\"Can't get stats.\"));\n            });\n            pc.getStats.apply(pc, args);\n            return retVal;\n        };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "getStats",
                "string": "that.getStats()",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStatsParser"
                },
                {
                    "type": "method",
                    "string": "respoke.MediaStatsParser.stopStats"
                }
            ],
            "description": {
                "full": "<p>Stop fetching and processing of call stats.</p>\n",
                "summary": "<p>Stop fetching and processing of call stats.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "that.stopStats = function () {\n            clearInterval(timer);\n        };",
            "ctx": {
                "type": "method",
                "receiver": "that",
                "name": "stopStats",
                "string": "that.stopStats()",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "memberof",
                    "string": "respoke.MediaStatsParser"
                },
                {
                    "type": "method",
                    "string": "respoke.MediaStatsParser.buildStats"
                },
                {
                    "type": "param",
                    "types": [
                        "object"
                    ],
                    "name": "rawStats",
                    "description": ""
                },
                {
                    "type": "private",
                    "visibility": "private"
                }
            ],
            "description": {
                "full": "<p>Receive raw stats and parse them.</p>\n",
                "summary": "<p>Receive raw stats and parse them.</p>\n",
                "body": ""
            },
            "isPrivate": true,
            "fires": [],
            "ignore": false,
            "code": "function buildStats(rawStats) {\n            // extract and repackage 'interesting' stats using the rules above\n            var stats = rawStats; // might need to re-instate some sort of wrapper here\n            var results = stats.result();\n\n            var allStats = {\n                state: {\n                    iceGatheringState: pc.icegatheringState,\n                    iceConnectionState: pc.iceConnectionState\n                }\n            };\n\n            Object.keys(interestingStats).forEach(function eachStatType(statType) {\n                var eachStat = {};\n                var rule = interestingStats[statType];\n                var report = results.filter(function eachResult(result) {\n                    var typeMatch = (result.type === rule.type);\n                    var keyMatch = (result.stat(rule.match.key) === rule.match.value);\n                    return (typeMatch && keyMatch);\n                });\n\n                if (report.length > 0) {\n                    if (report[0].timestamp) {\n                        allStats.timestamp = report[0].timestamp;\n                        allStats.periodLength = allStats.timestamp - oldStats.timestamp;\n                    }\n                    rule.keys.forEach(function eachKey(key) {\n                        var testInt = parseInt(report[0].stat(key), 10);\n                        if (!isNaN(testInt)) {\n                            eachStat[key] = testInt;\n                        } else {\n                            eachStat[key] = report[0].stat(key);\n                        }\n\n                        if (deltas[key] && oldStats && oldStats[statType] &&\n                            [null, undefined].indexOf(oldStats[statType][key]) === -1) {\n                            eachStat[\"period\" + key.charAt(0).toUpperCase() + key.slice(1)] =\n                                (eachStat[key] - oldStats[statType][key]);\n                        }\n                    });\n                }\n                allStats[statType] = eachStat;\n            });\n            oldStats = allStats;\n            return allStats;\n        }\n\n        initStats();\n\n        return that;\n    }; // End respoke.MediaStatsParser\n}));",
            "ctx": {
                "type": "function",
                "name": "buildStats",
                "string": "buildStats()",
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "callback",
                    "string": "respoke.MediaStatsParser.statsHandler"
                },
                {
                    "type": "param",
                    "types": [
                        "respoke.MediaStats"
                    ],
                    "name": "",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>Success handler for methods that generate stats.</p>\n",
                "summary": "<p>Success handler for methods that generate stats.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "ctx": {
                "file": {
                    "input": "plugins/respoke-stats/respoke-stats.js",
                    "output": ".docs/site/plugins/respoke-stats/respoke-stats.js.json"
                }
            }
        }
    ]
}