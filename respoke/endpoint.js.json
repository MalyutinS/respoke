[
    {
        "tags": [],
        "description": {
            "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
            "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
            "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "var log = require('loglevel');\nvar Q = require('q');\nvar respoke = require('./respoke');",
        "ctx": {
            "type": "declaration",
            "name": "log",
            "value": "require('loglevel')",
            "string": "log",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "constructor",
                "string": ""
            },
            {
                "type": "class",
                "string": "respoke.Endpoint"
            },
            {
                "type": "augments",
                "otherClass": "respoke.Presentable"
            },
            {
                "type": "param",
                "types": [
                    "object"
                ],
                "name": "params",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "params.id",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "params.instanceId",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "respoke.client.resolvePresence"
                ],
                "name": "[params.resolvePresence]",
                "description": "An optional function for resolving presence for an endpoint."
            },
            {
                "type": "returns",
                "string": "{respoke.Endpoint}"
            }
        ],
        "description": {
            "full": "<p><code>respoke.Endpoint</code>s are users of a Respoke app.</p>\n<p>An Endpoint can be a person in a browser or device, or an app using Respoke APIs from a server.</p>\n<p>A Client can interact with endpoints through messages, audio or video calls, or direct connections.</p>\n<p>An Endpoint may be authenticated from multiple devices to the same app (each of\nwhich is represented by a Connection).</p>\n",
            "summary": "<p><code>respoke.Endpoint</code>s are users of a Respoke app.</p>\n",
            "body": "<p>An Endpoint can be a person in a browser or device, or an app using Respoke APIs from a server.</p>\n<p>A Client can interact with endpoints through messages, audio or video calls, or direct connections.</p>\n<p>An Endpoint may be authenticated from multiple devices to the same app (each of\nwhich is represented by a Connection).</p>\n"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "module.exports = function (params) {\n    \"use strict\";\n    params = params || {};",
        "ctx": {
            "type": "method",
            "receiver": "module",
            "name": "exports",
            "string": "module.exports()",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "name",
                "string": "instanceId"
            },
            {
                "type": "private",
                "visibility": "private"
            },
            {
                "type": "type",
                "types": [
                    "string"
                ]
            }
        ],
        "description": {
            "full": "<p>@memberof! respoke.Endpoint</p>\n",
            "summary": "<p>@memberof! respoke.Endpoint</p>\n",
            "body": ""
        },
        "isPrivate": true,
        "fires": [],
        "ignore": false,
        "code": "var instanceId = params.instanceId;\n    var that = respoke.Presentable(params);",
        "ctx": {
            "type": "declaration",
            "name": "instanceId",
            "value": "params.instanceId",
            "string": "instanceId",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "name",
                "string": "client"
            },
            {
                "type": "type",
                "types": [
                    "respoke.Client"
                ]
            },
            {
                "type": "private",
                "visibility": "private"
            }
        ],
        "description": {
            "full": "<p>@memberof! respoke.DirectConnection</p>\n",
            "summary": "<p>@memberof! respoke.DirectConnection</p>\n",
            "body": ""
        },
        "isPrivate": true,
        "fires": [],
        "ignore": false,
        "code": "var client = respoke.getClient(instanceId);",
        "ctx": {
            "type": "declaration",
            "name": "client",
            "value": "respoke.getClient(instanceId)",
            "string": "client",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "name",
                "string": "signalingChannel"
            },
            {
                "type": "type",
                "types": [
                    "respoke.SignalingChannel"
                ]
            },
            {
                "type": "private",
                "visibility": "private"
            }
        ],
        "description": {
            "full": "<p>@memberof! respoke.DirectConnection</p>\n",
            "summary": "<p>@memberof! respoke.DirectConnection</p>\n",
            "body": ""
        },
        "isPrivate": true,
        "fires": [],
        "ignore": false,
        "code": "var signalingChannel = params.signalingChannel;\n\n    var addCall = params.addCall;\n\n    delete that.signalingChannel;\n    delete that.instanceId;\n    delete that.connectionId;\n    delete that.addCall;",
        "ctx": {
            "type": "declaration",
            "name": "signalingChannel",
            "value": "params.signalingChannel",
            "string": "signalingChannel",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.Endpoint"
            },
            {
                "type": "name",
                "string": "className"
            },
            {
                "type": "type",
                "types": [
                    "string"
                ]
            }
        ],
        "description": {
            "full": "<p>A name to identify the type of this object.</p>\n",
            "summary": "<p>A name to identify the type of this object.</p>\n",
            "body": ""
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.className = 'respoke.Endpoint';",
        "ctx": {
            "type": "property",
            "receiver": "that",
            "name": "className",
            "value": "'respoke.Endpoint'",
            "string": "that.className",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.Endpoint"
            },
            {
                "type": "name",
                "string": "directConnection"
            },
            {
                "type": "type",
                "types": [
                    "respoke.DirectConnection"
                ]
            }
        ],
        "description": {
            "full": "<p>A direct connection to this endpoint. This can be used to send direct messages.</p>\n",
            "summary": "<p>A direct connection to this endpoint. This can be used to send direct messages.</p>\n",
            "body": ""
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.directConnection = null;",
        "ctx": {
            "type": "property",
            "receiver": "that",
            "name": "directConnection",
            "value": "null",
            "string": "that.directConnection",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.Endpoint"
            },
            {
                "type": "name",
                "string": "connections"
            },
            {
                "type": "type",
                "types": [
                    "Array<respoke.Connection>"
                ]
            }
        ],
        "description": {
            "full": "<p>Array of connections for this endpoint.</p>\n",
            "summary": "<p>Array of connections for this endpoint.</p>\n",
            "body": ""
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.connections = [];\n    client.listen('disconnect', function disconnectHandler() {\n        that.connections = [];\n    });\n\n    var resolveEndpointPresence = params.resolveEndpointPresence;\n    delete that.resolveEndpointPresence;",
        "ctx": {
            "type": "property",
            "receiver": "that",
            "name": "connections",
            "value": "[]",
            "string": "that.connections",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.Endpoint"
            },
            {
                "type": "method",
                "string": "respoke.Endpoint.sendMessage"
            },
            {
                "type": "param",
                "types": [
                    "object"
                ],
                "name": "params",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "params.message",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "[params.connectionId]",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "respoke.Client.successHandler"
                ],
                "name": "[params.onSuccess]",
                "description": "- Success handler for this invocation of this\nmethod only."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Client.errorHandler"
                ],
                "name": "[params.onError]",
                "description": "- Error handler for this invocation of this method\nonly."
            },
            {
                "type": "returns",
                "string": "{Promise|undefined}"
            }
        ],
        "description": {
            "full": "<p>Send a message to the endpoint through the infrastructure.</p>\n<p>   endpoint.sendMessage({\n       message: &quot;wassuuuuup&quot;\n   });</p>\n<p><strong>Using callbacks</strong> will disable promises.</p>\n",
            "summary": "<p>Send a message to the endpoint through the infrastructure.</p>\n",
            "body": "<p>   endpoint.sendMessage({\n       message: &quot;wassuuuuup&quot;\n   });</p>\n<p><strong>Using callbacks</strong> will disable promises.</p>\n"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.sendMessage = function (params) {\n        var promise;\n        var retVal;\n        params = params || {};\n\n        promise = signalingChannel.sendMessage({\n            connectionId: params.connectionId,\n            message: params.message,\n            recipient: that\n        });\n\n        retVal = respoke.handlePromise(promise, params.onSuccess, params.onError);\n        return retVal;\n    };",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "sendMessage",
            "string": "that.sendMessage()",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.Endpoint"
            },
            {
                "type": "method",
                "string": "respoke.Endpoint.startAudioCall"
            },
            {
                "type": "param",
                "types": [
                    "object"
                ],
                "name": "params",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onError"
                ],
                "name": "[params.onError]",
                "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onLocalMedia"
                ],
                "name": "[params.onLocalMedia]",
                "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onConnect"
                ],
                "name": "[params.onConnect]",
                "description": "- Callback for receiving an HTML5 Video\nelement with the remote\naudio and/or video attached."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onHangup"
                ],
                "name": "[params.onHangup]",
                "description": "- Callback for being notified when the call has been\nhung up."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onAllow"
                ],
                "name": "[params.onAllow]",
                "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onMute"
                ],
                "name": "[params.onMute]",
                "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onAnswer"
                ],
                "name": "[params.onAnswer]",
                "description": "- Callback for when the callee answers the call."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onApprove"
                ],
                "name": "[params.onApprove]",
                "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onRequestingMedia"
                ],
                "name": "[params.onRequestingMedia]",
                "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
            },
            {
                "type": "param",
                "types": [
                    "respoke.MediaStatsParser.statsHandler"
                ],
                "name": "[params.onStats]",
                "description": "- Callback for receiving statistical\ninformation."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.previewLocalMedia"
                ],
                "name": "[params.previewLocalMedia]",
                "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.receiveOnly]",
                "description": "- whether or not we accept media"
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.sendOnly]",
                "description": "- whether or not we send media"
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.needDirectConnection]",
                "description": "- flag to enable skipping media & opening direct connection."
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.forceTurn]",
                "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.disableTurn]",
                "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "[params.connectionId]",
                "description": "- The connection ID of the remoteEndpoint, if it is not desired to call\nall connections belonging to this endpoint."
            },
            {
                "type": "returns",
                "string": "{respoke.Call}"
            }
        ],
        "description": {
            "full": "<p>Create a new audio-only call.</p>\n<pre><code>endpoint.startAudioCall({\n    onConnect: function (evt) {}\n});\n</code></pre>",
            "summary": "<p>Create a new audio-only call.</p>\n",
            "body": "<pre><code>endpoint.startAudioCall({\n    onConnect: function (evt) {}\n});\n</code></pre>"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.startAudioCall = function (params) {\n        params = params || {};\n        params.constraints = {\n            video: false,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "startAudioCall",
            "string": "that.startAudioCall()",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.Endpoint"
            },
            {
                "type": "method",
                "string": "respoke.Endpoint.startVideoCall"
            },
            {
                "type": "param",
                "types": [
                    "object"
                ],
                "name": "params",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onError"
                ],
                "name": "[params.onError]",
                "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onLocalMedia"
                ],
                "name": "[params.onLocalMedia]",
                "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onConnect"
                ],
                "name": "[params.onConnect]",
                "description": "- Callback for receiving an HTML5 Video\nelement with the remote\naudio and/or video attached."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onHangup"
                ],
                "name": "[params.onHangup]",
                "description": "- Callback for being notified when the call has been\nhung up."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onAllow"
                ],
                "name": "[params.onAllow]",
                "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onMute"
                ],
                "name": "[params.onMute]",
                "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onAnswer"
                ],
                "name": "[params.onAnswer]",
                "description": "- Callback for when the callee answers the call."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onApprove"
                ],
                "name": "[params.onApprove]",
                "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onRequestingMedia"
                ],
                "name": "[params.onRequestingMedia]",
                "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
            },
            {
                "type": "param",
                "types": [
                    "respoke.MediaStatsParser.statsHandler"
                ],
                "name": "[params.onStats]",
                "description": "- Callback for receiving statistical\ninformation."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.previewLocalMedia"
                ],
                "name": "[params.previewLocalMedia]",
                "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.receiveOnly]",
                "description": "- whether or not we accept media"
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.sendOnly]",
                "description": "- whether or not we send media"
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.needDirectConnection]",
                "description": "- flag to enable skipping media & opening direct connection."
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.forceTurn]",
                "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.disableTurn]",
                "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "[params.connectionId]",
                "description": "- The connection ID of the remoteEndpoint, if it is not desired to call\nall connections belonging to this endpoint."
            },
            {
                "type": "returns",
                "string": "{respoke.Call}"
            }
        ],
        "description": {
            "full": "<p>Create a new call with audio and video.</p>\n<pre><code>endpoint.startVideoCall({\n    onConnect: function (evt) {}\n});\n</code></pre>",
            "summary": "<p>Create a new call with audio and video.</p>\n",
            "body": "<pre><code>endpoint.startVideoCall({\n    onConnect: function (evt) {}\n});\n</code></pre>"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.startVideoCall = function (params) {\n        params = params || {};\n        params.constraints = {\n            video: true,\n            audio: true,\n            optional: [],\n            mandatory: {}\n        };\n        return that.startCall(params);\n    };",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "startVideoCall",
            "string": "that.startVideoCall()",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.Endpoint"
            },
            {
                "type": "method",
                "string": "respoke.Endpoint.startCall"
            },
            {
                "type": "param",
                "types": [
                    "object"
                ],
                "name": "params",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onError"
                ],
                "name": "[params.onError]",
                "description": "- Callback for errors that happen during call setup or\nmedia renegotiation."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onLocalMedia"
                ],
                "name": "[params.onLocalMedia]",
                "description": "- Callback for receiving an HTML5 Video\nelement with the local audio and/or video attached."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onConnect"
                ],
                "name": "[params.onConnect]",
                "description": "- Callback for receiving an HTML5 Video\nelement with the remote\naudio and/or video attached."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onHangup"
                ],
                "name": "[params.onHangup]",
                "description": "- Callback for being notified when the call has been\nhung up."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onAllow"
                ],
                "name": "[params.onAllow]",
                "description": "- When setting up a call, receive notification that the\nbrowser has granted access to media."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onMute"
                ],
                "name": "[params.onMute]",
                "description": "- Callback for changing the mute state on any type of media.\nThis callback will be called when media is muted or unmuted."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onAnswer"
                ],
                "name": "[params.onAnswer]",
                "description": "- Callback for when the callee answers the call."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onApprove"
                ],
                "name": "[params.onApprove]",
                "description": "- Callback for when the user approves local media. This\ncallback will be called whether or not the approval was based on user feedback. I. e., it will be called even if\nthe approval was automatic."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.onRequestingMedia"
                ],
                "name": "[params.onRequestingMedia]",
                "description": "- Callback for when the app is waiting\nfor the user to give permission to start getting audio or video."
            },
            {
                "type": "param",
                "types": [
                    "respoke.MediaStatsParser.statsHandler"
                ],
                "name": "[params.onStats]",
                "description": "- Callback for receiving statistical\ninformation."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.previewLocalMedia"
                ],
                "name": "[params.previewLocalMedia]",
                "description": "- A function to call if the developer\nwants to perform an action between local media becoming available and calling approve()."
            },
            {
                "type": "param",
                "types": [
                    "RTCConstraints"
                ],
                "name": "[params.constraints]",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.receiveOnly]",
                "description": "- whether or not we accept media"
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.sendOnly]",
                "description": "- whether or not we send media"
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.needDirectConnection]",
                "description": "- flag to enable skipping media & opening direct connection."
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.forceTurn]",
                "description": "- If true, media is not allowed to flow peer-to-peer and must flow through\nrelay servers. If it cannot flow through relay servers, the call will fail."
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[params.disableTurn]",
                "description": "- If true, media is not allowed to flow through relay servers; it is\nrequired to flow peer-to-peer. If it cannot, the call will fail."
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "[params.connectionId]",
                "description": "- The connection ID of the remoteEndpoint, if it is not desired to call\nall connections belonging to this endpoint."
            },
            {
                "type": "param",
                "types": [
                    "HTMLVideoElement"
                ],
                "name": "[params.videoLocalElement]",
                "description": "- Pass in an optional html video element to have local video attached to it."
            },
            {
                "type": "param",
                "types": [
                    "HTMLVideoElement"
                ],
                "name": "[params.videoRemoteElement]",
                "description": "- Pass in an optional html video element to have remote video attached to it."
            },
            {
                "type": "returns",
                "string": "{respoke.Call}"
            }
        ],
        "description": {
            "full": "<p>Create a new call.</p>\n<pre><code>endpoint.startCall({\n    onConnect: function (evt) {}\n});\n</code></pre>",
            "summary": "<p>Create a new call.</p>\n",
            "body": "<pre><code>endpoint.startCall({\n    onConnect: function (evt) {}\n});\n</code></pre>"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.startCall = function (params) {\n        var call = null;\n        params = params || {};\n\n        log.debug('Endpoint.call');\n        client.verifyConnected();\n        if (params.caller === undefined) {\n            params.caller = true;\n        }\n\n        if (!that.id) {\n            log.error(\"Can't start a call without endpoint ID!\");\n            return;\n        }\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = that;\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalAnswer = function (signalParams) {\n            signalParams.signalType = 'answer';\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.connectionId = signalParams.call.connectionId;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalParams.recipient = that;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalModify = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendModify(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send modify.\", err.message, err.stack);\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n                log.warn(\"Couldn't send candidate.\", err.message, err.stack);\n            });\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'call';\n            signalParams.recipient = that;\n            signalParams.sessionId = signalParams.call.sessionId;\n            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            log.debug(\"Sending debug report\", signalParams.report);\n            signalingChannel.sendReport(signalParams).done(null, function errorHandler(err) {\n                log.warn(\"Couldn't debug report.\", err.message, err.stack);\n            });\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        return call;\n    };",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "startCall",
            "string": "that.startCall()",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.Endpoint"
            },
            {
                "type": "method",
                "string": "respoke.Endpoint.startDirectConnection"
            },
            {
                "type": "param",
                "types": [
                    "object"
                ],
                "name": "params",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "respoke.Call.directConnectionSuccessHandler"
                ],
                "name": "[params.onSuccess]",
                "description": "- Success handler for this\ninvocation of this method only."
            },
            {
                "type": "param",
                "types": [
                    "respoke.Client.errorHandler"
                ],
                "name": "[params.onError]",
                "description": "- Error handler for this invocation of this\nmethod only."
            },
            {
                "type": "param",
                "types": [
                    "respoke.DirectConnection.onStart"
                ],
                "name": "[params.onStart]",
                "description": "- A callback for when setup of the direct\nconnection begins. The direct connection will not be open yet."
            },
            {
                "type": "param",
                "types": [
                    "respoke.DirectConnection.onOpen"
                ],
                "name": "[params.onOpen]",
                "description": "- A callback for receiving notification of when\nthe DirectConnection is open and ready to be used."
            },
            {
                "type": "param",
                "types": [
                    "respoke.DirectConnection.onError"
                ],
                "name": "[params.onError]",
                "description": "- Callback for errors setting up the direct\nconnection."
            },
            {
                "type": "param",
                "types": [
                    "respoke.DirectConnection.onClose"
                ],
                "name": "[params.onClose]",
                "description": "- A callback for receiving notification of\nwhen the DirectConnection is closed and the two Endpoints are disconnected."
            },
            {
                "type": "param",
                "types": [
                    "respoke.DirectConnection.onAccept"
                ],
                "name": "[params.onAccept]",
                "description": "- Callback for when the user accepts the\nrequest for a direct connection and setup begins."
            },
            {
                "type": "param",
                "types": [
                    "respoke.DirectConnection.onMessage"
                ],
                "name": "[params.onMessage]",
                "description": "- A callback for receiving messages sent\nthrough the DirectConnection."
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "[params.connectionId]",
                "description": "- An optional connection ID to use for this connection. This allows\nthe connection to be made to a specific instance of an endpoint in the case that the same endpoint is logged\nin from multiple locations."
            },
            {
                "type": "returns",
                "string": "{respoke.DirectConnection} The DirectConnection which can be used to send data and messages\ndirectly to the other endpoint."
            }
        ],
        "description": {
            "full": "<p>Create a new DirectConnection.  This method creates a new Call as well, attaching this DirectConnection to\nit for the purposes of creating a peer-to-peer link for sending data such as messages to the other endpoint.\nInformation sent through a DirectConnection is not handled by the cloud infrastructure.  If there is already\na direct connection open, this method will resolve the promise with that direct connection instead of\nattempting to create a new one.</p>\n<pre><code>endpoint.startDirectConnection({\n    onOpen: function (evt) {}\n});\n</code></pre>",
            "summary": "<p>Create a new DirectConnection.  This method creates a new Call as well, attaching this DirectConnection to\nit for the purposes of creating a peer-to-peer link for sending data such as messages to the other endpoint.\nInformation sent through a DirectConnection is not handled by the cloud infrastructure.  If there is already\na direct connection open, this method will resolve the promise with that direct connection instead of\nattempting to create a new one.</p>\n",
            "body": "<pre><code>endpoint.startDirectConnection({\n    onOpen: function (evt) {}\n});\n</code></pre>"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.startDirectConnection = function (params) {\n        params = params || {};\n        var deferred = Q.defer();\n        var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n        var call;\n\n        try {\n            client.verifyConnected();\n        } catch (err) {\n            deferred.reject(err);\n            return retVal;\n        }\n\n        if (that.directConnection || params.create === false) {\n            deferred.resolve(that.directConnection);\n            return retVal;\n        }\n\n        log.debug('Endpoint.startDirectConnection', params);\n        if (params.caller === undefined) {\n            params.caller = true;\n        }\n\n        if (!that.id) {\n            deferred.reject(new Error(\"Can't start a direct connection without endpoint ID!\"));\n            return retVal;\n        }\n\n        params.instanceId = instanceId;\n        params.remoteEndpoint = that;\n\n        params.signalOffer = function (signalParams) {\n            var onSuccess = signalParams.onSuccess;\n            var onError = signalParams.onError;\n            delete signalParams.onSuccess;\n            delete signalParams.onError;\n\n            signalParams.signalType = 'offer';\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n\n            signalingChannel.sendSDP(signalParams).done(onSuccess, onError);\n        };\n        params.signalConnected = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendConnected(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send connected.\", err.message, err.stack);\n                signalParams.call.hangup();\n            });\n        };\n        params.signalAnswer = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalParams.signalType = 'answer';\n            signalingChannel.sendSDP(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't answer the call.\", err.message, err.stack);\n                signalParams.call.hangup({signal: false});\n            });\n        };\n        params.signalCandidate = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendCandidate(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send candidate.\", err.message, err.stack);\n            });\n        };\n        params.signalHangup = function (signalParams) {\n            signalParams.target = 'directConnection';\n            signalParams.recipient = that;\n            signalingChannel.sendHangup(signalParams).done(null, function errorHandler(err) {\n                log.error(\"Couldn't send hangup.\", err.message, err.stack);\n            });\n        };\n        params.signalReport = function (signalParams) {\n            signalParams.report.target = 'directConnection';\n            log.debug(\"Not sending report\");\n            log.debug(signalParams.report);\n        };\n        params.needDirectConnection = true;\n        // Don't include audio in the offer SDP\n        params.offerOptions = {\n            mandatory: {\n                OfferToReceiveAudio: false\n            }\n        };\n\n        params.signalingChannel = signalingChannel;\n        call = respoke.Call(params);\n        addCall({call: call});\n        call.listen('direct-connection', function directConnectionHandler(evt) {\n            that.directConnection = evt.directConnection;\n            if (params.caller !== true) {\n                if (!client.hasListeners('direct-connection') &&\n                        !client.hasListeners('direct-connection') &&\n                        !call.hasListeners('direct-connection')) {\n                    that.directConnection.reject();\n                    deferred.reject(new Error(\"Got an incoming direct connection with no handlers to accept it!\"));\n                    return;\n                }\n\n                deferred.resolve(that.directConnection);\n                that.directConnection.listen('close', function closeHandler(evt) {\n                    that.directConnection = undefined;\n                }, true);\n            }\n        }, true);\n\n        return retVal;\n    };",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "startDirectConnection",
            "string": "that.startDirectConnection()",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.Endpoint"
            },
            {
                "type": "method",
                "string": "respoke.Endpoint.resolvePresence"
            },
            {
                "type": "private",
                "visibility": "private"
            }
        ],
        "description": {
            "full": "<p>Find the presence out of all known connections with the highest priority (most availability)\nand set it as the endpoint&#39;s resolved presence.</p>\n",
            "summary": "<p>Find the presence out of all known connections with the highest priority (most availability)\nand set it as the endpoint&#39;s resolved presence.</p>\n",
            "body": ""
        },
        "isPrivate": true,
        "fires": [],
        "ignore": false,
        "code": "that.resolvePresence = function () {\n\n        var presenceList = that.connections.map(function (connection) {\n            return connection.presence;\n        });\n\n        if (resolveEndpointPresence !== undefined) {\n            that.presence = resolveEndpointPresence(presenceList);\n        } else {\n            var options = ['chat', 'available', 'away', 'dnd', 'xa', 'unavailable'];\n            var idList;",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "resolvePresence",
            "string": "that.resolvePresence()",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [],
        "description": {
            "full": "<p>Sort the connections array by the priority of the value of the presence of that\nconnectionId. This will cause the first element in the list to be the id of the\nsession with the highest priority presence so we can access it by the 0 index.\nTODO: If we don&#39;t really care about the sorting and only about the highest priority\nwe could use Array.prototype.every to improve this algorithm.</p>\n",
            "summary": "<p>Sort the connections array by the priority of the value of the presence of that\nconnectionId. This will cause the first element in the list to be the id of the\nsession with the highest priority presence so we can access it by the 0 index.\nTODO: If we don&#39;t really care about the sorting and only about the highest priority\nwe could use Array.prototype.every to improve this algorithm.</p>\n",
            "body": ""
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "idList = that.connections.sort(function sorter(a, b) {\n                var indexA = options.indexOf(a.presence);\n                var indexB = options.indexOf(b.presence);\n                // Move it to the end of the list if it isn't one of our accepted presence values\n                indexA = indexA === -1 ? 1000 : indexA;\n                indexB = indexB === -1 ? 1000 : indexB;\n                return indexA < indexB ? -1 : (indexB < indexA ? 1 : 0);\n            });\n\n            if (idList[0]) {\n                that.presence = idList[0].presence;\n            } else {\n                that.presence = 'unavailable';\n            }\n        }\n    };",
        "ctx": {
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.Endpoint"
            },
            {
                "type": "method",
                "string": "respoke.Endpoint.getConnection"
            },
            {
                "type": "private",
                "visibility": "private"
            },
            {
                "type": "param",
                "types": [
                    "object"
                ],
                "name": "params",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "[params.connectionId]",
                "description": ""
            },
            {
                "type": "return",
                "string": "{respoke.Connection}"
            }
        ],
        "description": {
            "full": "<p>Get the Connection with the specified id. The connection ID is optional if only one connection exists.</p>\n<pre><code>var connection = endpoint.getConnection({\n    connectionId: &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX&quot;\n});\n</code></pre>",
            "summary": "<p>Get the Connection with the specified id. The connection ID is optional if only one connection exists.</p>\n",
            "body": "<pre><code>var connection = endpoint.getConnection({\n    connectionId: &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX&quot;\n});\n</code></pre>"
        },
        "isPrivate": true,
        "fires": [],
        "ignore": false,
        "code": "that.getConnection = function (params) {\n        var connection = null;\n        params = params || {};\n        if (that.connections.length === 1 &&\n                (!params.connectionId || that.connections[0] === params.connectionId)) {\n            return that.connections[0];\n        }\n\n        if (!params || !params.connectionId) {\n            throw new Error(\"Can't find a connection without the connectionId.\");\n        }\n\n        that.connections.every(function eachConnection(conn) {\n            if (conn.id === params.connectionId) {\n                connection = conn;\n                return false;\n            }\n            return true;\n        });\n\n        return connection;\n    };\n\n    return that;\n}; // End respoke.Endpoint",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "getConnection",
            "string": "that.getConnection()",
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "callback",
                "string": "respoke.Endpoint.onMessage"
            },
            {
                "type": "param",
                "types": [
                    "respoke.Event"
                ],
                "name": "evt",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "respoke.TextMessage"
                ],
                "name": "evt.message",
                "description": "- the message"
            },
            {
                "type": "param",
                "types": [
                    "respoke.Endpoint"
                ],
                "name": "evt.target",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "evt.name",
                "description": "- the event name"
            }
        ],
        "description": {
            "full": "<p>Handle messages sent to the logged-in user from this one Endpoint.  This callback is called every time\nrespoke.Endpoint#message fires.</p>\n",
            "summary": "<p>Handle messages sent to the logged-in user from this one Endpoint.  This callback is called every time\nrespoke.Endpoint#message fires.</p>\n",
            "body": ""
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "ctx": {
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "callback",
                "string": "respoke.Endpoint.onPresence"
            },
            {
                "type": "param",
                "types": [
                    "respoke.Event"
                ],
                "name": "evt",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "string",
                    "number",
                    "object",
                    "Array"
                ],
                "name": "evt.presence",
                "description": "- the Endpoint's presence"
            },
            {
                "type": "param",
                "types": [
                    "respoke.Endpoint"
                ],
                "name": "evt.target",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "evt.name",
                "description": "- the event name"
            }
        ],
        "description": {
            "full": "<p>Handle presence notifications from this one Endpoint.  This callback is called every time\nrespoke.Endpoint#message fires.</p>\n",
            "summary": "<p>Handle presence notifications from this one Endpoint.  This callback is called every time\nrespoke.Endpoint#message fires.</p>\n",
            "body": ""
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "ctx": {
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "callback",
                "string": "respoke.Client.resolveEndpointPresence"
            },
            {
                "type": "param",
                "types": [
                    "Array<object>"
                ],
                "name": "connectionPresence",
                "description": ""
            },
            {
                "type": "returns",
                "string": "{object|string|number}"
            }
        ],
        "description": {
            "full": "<p>Handle resolving presence for this endpoint</p>\n",
            "summary": "<p>Handle resolving presence for this endpoint</p>\n",
            "body": ""
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "ctx": {
            "file": {
                "input": "respoke/endpoint.js",
                "output": ".docs/site/respoke/endpoint.js.json"
            }
        }
    }
]