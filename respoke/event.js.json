[
    {
        "tags": [],
        "description": {
            "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
            "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
            "body": "<p>This source code is licensed under The MIT License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "var respoke = require('./respoke');\nvar log = require('loglevel');",
        "ctx": {
            "type": "declaration",
            "name": "respoke",
            "value": "require('./respoke')",
            "string": "respoke",
            "file": {
                "input": "respoke/event.js",
                "output": ".docs/site/respoke/event.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "class",
                "string": "respoke.EventEmitter"
            },
            {
                "type": "inherits",
                "string": "respoke.Class"
            },
            {
                "type": "constructor",
                "string": ""
            },
            {
                "type": "param",
                "types": [
                    "object"
                ],
                "name": "params",
                "description": ""
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "params.instanceId",
                "description": ""
            },
            {
                "type": "returns",
                "string": "{respoke.EventEmitter}"
            }
        ],
        "description": {
            "full": "<p>A generic class for emitting and listening to events.</p>\n",
            "summary": "<p>A generic class for emitting and listening to events.</p>\n",
            "body": ""
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "var EventEmitter = module.exports = function (params) {\n    \"use strict\";\n    params = params || {};\n    var that = respoke.Class(params);",
        "ctx": {
            "type": "declaration",
            "name": "EventEmitter",
            "value": "module.exports = function (params) {",
            "string": "EventEmitter",
            "file": {
                "input": "respoke/event.js",
                "output": ".docs/site/respoke/event.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.EventEmitter"
            },
            {
                "type": "name",
                "string": "className"
            },
            {
                "type": "type",
                "types": [
                    "string"
                ]
            },
            {
                "type": "private",
                "visibility": "private"
            }
        ],
        "description": {
            "full": "<p>A name to identify the type of this object.</p>\n",
            "summary": "<p>A name to identify the type of this object.</p>\n",
            "body": ""
        },
        "isPrivate": true,
        "fires": [],
        "ignore": false,
        "code": "that.className = 'respoke.EventEmitter';",
        "ctx": {
            "type": "property",
            "receiver": "that",
            "name": "className",
            "value": "'respoke.EventEmitter'",
            "string": "that.className",
            "file": {
                "input": "respoke/event.js",
                "output": ".docs/site/respoke/event.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "name",
                "string": "eventList"
            },
            {
                "type": "private",
                "visibility": "private"
            },
            {
                "type": "type",
                "types": [
                    "object"
                ]
            }
        ],
        "description": {
            "full": "<p>@memberof! respoke.EventEmitter</p>\n",
            "summary": "<p>@memberof! respoke.EventEmitter</p>\n",
            "body": ""
        },
        "isPrivate": true,
        "fires": [],
        "ignore": false,
        "code": "var eventList = {};",
        "ctx": {
            "type": "declaration",
            "name": "eventList",
            "value": "{}",
            "string": "eventList",
            "file": {
                "input": "respoke/event.js",
                "output": ".docs/site/respoke/event.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.EventEmitter"
            },
            {
                "type": "method",
                "string": "respoke.EventEmitter.listen"
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "eventType",
                "description": "- A developer-specified string identifying the event."
            },
            {
                "type": "param",
                "types": [
                    "respoke.EventEmitter.eventListener"
                ],
                "name": "listener",
                "description": "- A function to call when the event is fire."
            },
            {
                "type": "param",
                "types": [
                    "boolean"
                ],
                "name": "[isInternal]",
                "description": "- A flag to indicate this listener was added by the library. This parameter should\nnot be used by developers who are using the library, only by developers who are working on the library itself."
            }
        ],
        "description": {
            "full": "<p>Add a listener that will only be called once to an object.  This method adds the given listener to the given\nevent in the case that the same\nlistener is not already registered to this event and the listener is a function.  The third argument &#39;isInternal&#39;\nis used only internally by the library to indicate that this listener is a library-used listener and should not\ncount when we are trying to determine if an event has listeners placed by the developer.</p>\n<pre><code>client.once(&#39;connect&#39;, function (evt) {\n    console.log(&quot;This is the first time we connected.&quot;);\n});\n</code></pre>",
            "summary": "<p>Add a listener that will only be called once to an object.  This method adds the given listener to the given\nevent in the case that the same\nlistener is not already registered to this event and the listener is a function.  The third argument &#39;isInternal&#39;\nis used only internally by the library to indicate that this listener is a library-used listener and should not\ncount when we are trying to determine if an event has listeners placed by the developer.</p>\n",
            "body": "<pre><code>client.once(&#39;connect&#39;, function (evt) {\n    console.log(&quot;This is the first time we connected.&quot;);\n});\n</code></pre>"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.once = function (eventType, listener, isInternal) {\n        var string = listener.toString();\n        listener = respoke.once(listener);\n        listener.toString = function () { return string; }\n        listener.once = true;\n        that.listen(eventType, listener, isInternal);\n    };",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "once",
            "string": "that.once()",
            "file": {
                "input": "respoke/event.js",
                "output": ".docs/site/respoke/event.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.EventEmitter"
            },
            {
                "type": "method",
                "string": "respoke.EventEmitter.listen"
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "eventType",
                "description": "- The name of the event."
            },
            {
                "type": "param",
                "types": [
                    "respoke.EventEmitter.eventListener"
                ],
                "name": "listener",
                "description": "- A function to call when the event is\nfired."
            },
            {
                "type": "arg",
                "string": "{boolean} isInternal - Internal use only. A flag to indicate this listener was \nadded by the library. This parameter should not be used by developers who are using\nthe library, only by developers who are working on the library itself."
            }
        ],
        "description": {
            "full": "<p>Add a <code>listener</code> function to an object.</p>\n<p>This method adds the <code>listener</code> to the event <code>eventName</code>.</p>\n<p>If an identical listener already registered to this event, it will <strong>not</strong> be added.</p>\n<h5 id=\"example-of-adding-an-event-listener-\">Example of adding an event listener.</h5>\n<pre><code>client.listen(&#39;connect&#39;, function (evt) {\n    console.log(&quot;We&#39;ve connected!&quot;, evt);\n});\n</code></pre>",
            "summary": "<p>Add a <code>listener</code> function to an object.</p>\n",
            "body": "<p>This method adds the <code>listener</code> to the event <code>eventName</code>.</p>\n<p>If an identical listener already registered to this event, it will <strong>not</strong> be added.</p>\n<h5 id=\"example-of-adding-an-event-listener-\">Example of adding an event listener.</h5>\n<pre><code>client.listen(&#39;connect&#39;, function (evt) {\n    console.log(&quot;We&#39;ve connected!&quot;, evt);\n});\n</code></pre>"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.listen = function (eventType, listener, isInternal) {\n        if (listener === undefined) {\n            return;\n        }\n        var invalidEventType = typeof eventType !== 'string' || !eventType;\n        var invalidListener = typeof listener !== 'function';\n        if (invalidEventType || invalidListener) {\n            log.error(\"Invalid request to add event listener to\", eventType, listener);\n            return;\n        }\n\n        eventList[eventType] = eventList[eventType] || [];\n        listener.isInternal = !!isInternal; // boolify\n\n        var toString = function (fn) {\n            return fn.toString();\n        };\n        var isNotAlreadyAdded = eventList[eventType].map(toString).indexOf(listener.toString()) === -1;\n\n        if (isNotAlreadyAdded) {\n            eventList[eventType].push(listener);\n        } else {\n            log.warn(\"Not adding duplicate listener to\", eventType, listener);\n        }\n    };",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "listen",
            "string": "that.listen()",
            "file": {
                "input": "respoke/event.js",
                "output": ".docs/site/respoke/event.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.EventEmitter"
            },
            {
                "type": "method",
                "string": "respoke.EventEmitter.ignore"
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "[eventType]",
                "description": "- An optional developer-specified string identifying the event."
            },
            {
                "type": "param",
                "types": [
                    "function"
                ],
                "name": "[listener]",
                "description": "- An optional function to remove from the specified event."
            }
        ],
        "description": {
            "full": "<p>Remove a listener from an object. If no eventType is specified, all eventTypes will be\ncleared. If an eventType is specified but no listener is specified, all listeners will be\nremoved from the specified eventType.  If a listener is also specified, only that listener\nwill be removed.</p>\n<pre><code>client.ignore(&#39;connect&#39;, connectHandler);\n</code></pre>",
            "summary": "<p>Remove a listener from an object. If no eventType is specified, all eventTypes will be\ncleared. If an eventType is specified but no listener is specified, all listeners will be\nremoved from the specified eventType.  If a listener is also specified, only that listener\nwill be removed.</p>\n",
            "body": "<pre><code>client.ignore(&#39;connect&#39;, connectHandler);\n</code></pre>"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.ignore = function (eventType, listener) {\n        // Remove all events from this object\n        if (eventType === undefined) {\n            eventList = {};\n            return;\n        }\n\n        // Remove all listeners from this event.\n        if (listener === undefined || !eventList[eventType]) {\n            eventList[eventType] = [];\n            return;\n        }\n\n        // Remove only one listener from this event.\n        for (var i = eventList[eventType].length - 1; i >= 0; i -= 1) {\n            if (listener === eventList[eventType][i]) {\n                eventList[eventType].splice(i, 1);\n                return;\n            }\n        }\n    };",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "ignore",
            "string": "that.ignore()",
            "file": {
                "input": "respoke/event.js",
                "output": ".docs/site/respoke/event.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.EventEmitter"
            },
            {
                "type": "method",
                "string": "respoke.EventEmitter.fire"
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "eventType",
                "description": "- A developer-specified string identifying the event to fire."
            },
            {
                "type": "param",
                "types": [
                    "string",
                    "number",
                    "object",
                    "array"
                ],
                "name": "evt",
                "description": "- Any number of optional parameters to be passed to\nthe listener"
            },
            {
                "type": "private",
                "visibility": "private"
            }
        ],
        "description": {
            "full": "<p>Trigger an event on an object. All listeners for the specified eventType will be called.\nListeners will be bound to the object (&#39;this&#39; will refer to the object), and additional\narguments to fire() will be passed into each listener.</p>\n",
            "summary": "<p>Trigger an event on an object. All listeners for the specified eventType will be called.\nListeners will be bound to the object (&#39;this&#39; will refer to the object), and additional\narguments to fire() will be passed into each listener.</p>\n",
            "body": ""
        },
        "isPrivate": true,
        "fires": [],
        "ignore": false,
        "code": "that.fire = function (eventType, evt) {\n        var args = null;\n        var count = 0;\n        var toRemove = [];\n\n        evt = evt || {};\n        evt.name = eventType;\n        evt.target = that;\n\n        if (!eventType) {\n            return;\n        }\n\n        if (!eventList[eventType]) {\n            log.debug(\"fired \" + that.className + \"#\" + eventType + \" 0 listeners called with params\", evt);\n            return;\n        }\n\n        for (var i = 0; i < eventList[eventType].length; i += 1) {\n            var listener = eventList[eventType][i];\n            if (typeof listener === 'function') {\n                setTimeout(listenerBuilder(listener, evt, eventType));\n\n                count += 1;\n                if (listener.once === true) {\n                    toRemove.push(i);\n                }\n            }\n        }\n\n        for (var i = (toRemove.length - 1); i >= 0; i -= 1) {\n            eventList[eventType].splice(toRemove[i], 1);\n        }\n\n        log.debug(\"fired \" + that.className + \"#\" + eventType + \" \" + count + \" listeners called with params\", evt);\n    };\n\n    function listenerBuilder(listener, evt, eventType) {\n        return function () {\n            try {\n                listener.call(that, evt);\n            } catch (e) {\n                log.error('Error in ' + that.className + \"#\" + eventType, e.message, e.stack);\n            }\n        };\n    }",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "fire",
            "string": "that.fire()",
            "file": {
                "input": "respoke/event.js",
                "output": ".docs/site/respoke/event.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "memberof",
                "string": "respoke.EventEmitter"
            },
            {
                "type": "method",
                "string": "respoke.EventEmitter.hasListeners"
            },
            {
                "type": "param",
                "types": [
                    "string"
                ],
                "name": "eventType",
                "description": "- The name of the event"
            },
            {
                "type": "returns",
                "string": "{boolean} Whether this event has any listeners that are external to this library."
            }
        ],
        "description": {
            "full": "<p>Determine if an object has had any listeners registered for a given event outside the library. This method\nchecks for the isInternal flag on each listener and doesn&#39;t count it toward an event being listened to. This\nmethod is used in the library to handle situations where an action is needed if an event won&#39;t be acted on.\nFor instance, if a call comes in for the logged-in user, but the developer isn&#39;t listening to\n{respoke.Client#call}, we&#39;ll need to reject the call immediately.</p>\n<pre><code>if (client.hasListeners(&#39;call&#39;)) {\n    // already handled!\n}\n</code></pre>",
            "summary": "<p>Determine if an object has had any listeners registered for a given event outside the library. This method\nchecks for the isInternal flag on each listener and doesn&#39;t count it toward an event being listened to. This\nmethod is used in the library to handle situations where an action is needed if an event won&#39;t be acted on.\nFor instance, if a call comes in for the logged-in user, but the developer isn&#39;t listening to\n{respoke.Client#call}, we&#39;ll need to reject the call immediately.</p>\n",
            "body": "<pre><code>if (client.hasListeners(&#39;call&#39;)) {\n    // already handled!\n}\n</code></pre>"
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "code": "that.hasListeners = function (eventType) {\n        if (eventType === undefined) {\n            throw new Error(\"Missing required parameter event type.\");\n        }\n\n        if (!eventList[eventType]) {\n            return false;\n        }\n\n        return !eventList[eventType].every(function eachListener(listener) {\n            return listener.isInternal;\n        });\n    };\n\n    return that;\n}; // End respoke.EventEmitter",
        "ctx": {
            "type": "method",
            "receiver": "that",
            "name": "hasListeners",
            "string": "that.hasListeners()",
            "file": {
                "input": "respoke/event.js",
                "output": ".docs/site/respoke/event.js.json"
            }
        }
    },
    {
        "tags": [
            {
                "type": "param",
                "types": [
                    "respoke.Event"
                ],
                "name": "evt",
                "description": ""
            }
        ],
        "description": {
            "full": "<p>@callback respoke.EventEmitter.eventListener</p>\n",
            "summary": "<p>@callback respoke.EventEmitter.eventListener</p>\n",
            "body": ""
        },
        "isPrivate": false,
        "fires": [],
        "ignore": false,
        "ctx": {
            "file": {
                "input": "respoke/event.js",
                "output": ".docs/site/respoke/event.js.json"
            }
        }
    }
]